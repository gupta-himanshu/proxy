/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.10.59
 * apibuilder 0.15.33 app.apibuilder.io/flow/price/latest/play_2_x_json
 */
package io.flow.price.v0.models {

  /**
   * De Minimis describes the country specific rules for exactly how tax and duties
   * are calculated, as well as any exemptions that apply. See
   * https://en.wikipedia.org/wiki/De_minimis for more information.
   */
  sealed trait Deminimis extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type Deminimis
   */
  sealed trait DeminimisDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object DeminimisDiscriminator {

    case object DeminimisSimple extends DeminimisDiscriminator { override def toString = "deminimis_simple" }
    case object DeminimisPerItem extends DeminimisDiscriminator { override def toString = "deminimis_per_item" }

    final case class UNDEFINED(override val toString: String) extends DeminimisDiscriminator

    val all: scala.List[DeminimisDiscriminator] = scala.List(DeminimisSimple, DeminimisPerItem)

    private[this] val byName: Map[String, DeminimisDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DeminimisDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DeminimisDiscriminator] = byName.get(value.toLowerCase)

  }

  final case class CurrencyFormat(
    symbol: io.flow.common.v0.models.CurrencySymbolFormat,
    labelFormatters: Seq[io.flow.common.v0.models.CurrencyLabelFormatter]
  )

  /**
   * De Minimis per item describes rules which require minimum and/or maximum values
   * per item
   *
   * @param currency The ISO-4217 3 character currency code in which the value is calculated
   * @param minimum If specified, the minimum amount due per item
   * @param maximum If specified, the maximum amount due per item
   */
  final case class DeminimisPerItem(
    currency: String,
    minimum: _root_.scala.Option[BigDecimal] = None,
    maximum: _root_.scala.Option[BigDecimal] = None
  ) extends Deminimis

  /**
   * De Minimis for most common example which includes a value threshold and rules on
   * what components are used in the duty calculation
   *
   * @param value The value below which no tax or duty is collected, which is a sum of the values
   *        associated with the de minimis components.
   * @param currency The ISO-4217 3 character currency code in which the value is calculated.
   * @param components The components that are used to determine the value. Note that these components
   *        may be different from the components for the VAT or duty itself.
   * @param minimum If the calculated VAT or duty amount is less than the minimum, no VAT or duty is
   *        owed. In other words, this is the minimum payable amount.
   */
  final case class DeminimisSimple(
    value: _root_.scala.Option[BigDecimal] = None,
    currency: String,
    components: Seq[io.flow.price.v0.models.LevyComponent],
    minimum: _root_.scala.Option[BigDecimal] = None
  ) extends Deminimis

  /**
   * Represents a simple model of duties that apply to a given item / trade lane.
   *
   * @param rate The combined duty rate. A value of 25 indicates a duty rate of 25%
   * @param components The components to which duty is applied.
   * @param deminimis Describes the duty de minimis if there is one for this destination
   * @param name Generally used for Where this rate came from and potentially its type.
   */
  final case class Duty(
    rate: BigDecimal,
    components: Seq[io.flow.price.v0.models.LevyComponent],
    deminimis: _root_.scala.Option[io.flow.price.v0.models.Deminimis] = None,
    name: _root_.scala.Option[String] = None
  )

  /**
   * @param base Contains the localized price details, but converted to the base currency of the
   *        organization.
   * @param local Contains the localized price details in the currency of the experience.
   * @param discount Contains the amount subtracted post-VAT/Duty/Rounding due to a percent discount.
   * @param localBeforeDiscount Contains the amount subtracted post-VAT/Duty/Rounding due to a percent discount.
   */
  final case class LocalPriceDetails(
    base: io.flow.price.v0.models.PriceDetails,
    local: io.flow.price.v0.models.PriceDetails,
    discount: _root_.scala.Option[io.flow.price.v0.models.PriceDetail] = None,
    localBeforeDiscount: _root_.scala.Option[io.flow.price.v0.models.PriceDetail] = None
  )

  /**
   * Represents a list of target prices in a specific currency that can override any
   * subset of item prices within an experience.
   *
   * @param id A unique string that identifies a price book within Flow.
   * @param key A unique string that identifies a price book within an organization, which
   *        defaults to the id if none is set.
   * @param currency The currency for which the price book is valid.
   * @param name A display name for the price book.
   * @param includes Describes which levies are included in the price book item prices.
   * @param status Represents the status of a price book within Flow.
   */
  final case class PriceBook(
    id: String,
    key: String,
    currency: String,
    name: String,
    includes: io.flow.common.v0.models.IncludedLevies,
    status: io.flow.common.v0.models.PriceBookStatus
  )

  /**
   * Represents a price book for a specific currency that can override any subset of
   * item prices within an experience.
   *
   * @param currency The currency for which the price book is valid.
   * @param name A display name for the price book.
   * @param includes Describes which levies are included in the price book item prices.
   * @param status Represents the status of a price book within Flow.
   */
  final case class PriceBookForm(
    currency: String,
    name: String,
    includes: io.flow.common.v0.models.IncludedLevyKey,
    status: io.flow.common.v0.models.PriceBookStatus = io.flow.common.v0.models.PriceBookStatus.Draft
  )

  /**
   * Represents the price of a single item within a price book.
   *
   * @param itemNumber Corresponds with the product id from the ingested price book.
   * @param schedule The schedule used to indicate when the price applies to the price book item.
   */
  final case class PriceBookItem(
    id: String,
    key: String,
    priceBook: io.flow.price.v0.models.PriceBookReference,
    price: io.flow.common.v0.models.Price,
    itemNumber: String,
    schedule: io.flow.price.v0.models.PriceBookItemSchedule,
    itemAttributes: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * Represents the form to create an item in a pricebook.
   *
   * @param priceBookKey Corresponds with the price book key to which this price book item belongs.
   * @param itemNumber Corresponds with the unique product id from the ingested price book.
   * @param amount The item price amount, in the currency of the price book
   * @param schedule The schedule used to indicate when the price applies to the price book item.
   * @param itemAttributes Optionally specify values for any of the catalog item attributes that have an
   *        intent of price, e.g. add a 'compare_at' or 'msrp' price here.
   */
  final case class PriceBookItemForm(
    priceBookKey: String,
    itemNumber: String,
    amount: BigDecimal,
    schedule: _root_.scala.Option[io.flow.price.v0.models.PriceBookItemSchedule] = None,
    itemAttributes: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * Used to create price book items for multiple items matching a query
   *
   * @param priceBookKey Corresponds with the price book key to which this price book item belongs.
   * @param itemQuery This query will be used to select all matching items, setting the price for all
   *        the items that match this query.
   * @param amount The item price amount, in the currency of the price book
   * @param schedule The schedule used to indicate when the price applies to the price book item.
   * @param itemAttributes Optionally specify values for any of the catalog item attributes that have an
   *        intent of price, e.g. add a 'compare_at' or 'msrp' price here.
   */
  final case class PriceBookItemQueryForm(
    priceBookKey: String,
    itemQuery: String,
    amount: BigDecimal,
    schedule: _root_.scala.Option[io.flow.price.v0.models.PriceBookItemSchedule] = None,
    itemAttributes: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * Represents schedule applied to a price book item
   *
   * @param startsAt The date and time for the price to take effect.
   * @param endsAt The date and time for the price to stop taking effect. If not provided, no
   *        default end time will be set.
   */
  final case class PriceBookItemSchedule(
    startsAt: _root_.org.joda.time.DateTime,
    endsAt: _root_.scala.Option[_root_.org.joda.time.DateTime] = None
  )

  final case class PriceBookReference(
    id: String,
    key: String
  )

  /**
   * @param display Contains the (estimated) price details that are displayed to the user. These
   *        details will never change.
   * @param `final` Contains the final price details, which are initially equal to the display
   *        details. At the order level (when shipping address is known), these details may
   *        be adjusted.
   */
  final case class PriceCheck(
    display: io.flow.price.v0.models.LocalPriceDetails,
    `final`: io.flow.price.v0.models.LocalPriceDetails
  )

  /**
   * Represents a top-level price detail, e.g. 'Subtotal' or 'VAT'.
   *
   * @param key The key indicating what this price detail represents.
   * @param label The formatted label to display for this detail, e.g. '$123.45 CAD'.
   * @param name The display name for this price detail.
   * @param basis The taxable/dutiable basis from which this levy component was produced. Should
   *        be equal to total / rate.
   */
  final case class PriceDetail(
    key: io.flow.price.v0.models.PriceDetailKey,
    components: Seq[io.flow.price.v0.models.PriceDetailComponent],
    amount: BigDecimal,
    label: String,
    name: _root_.scala.Option[String] = None,
    basis: _root_.scala.Option[BigDecimal] = None
  )

  /**
   * @param label The formatted label to display for this component, e.g. '$123.45 CAD'.
   * @param name The display name for this price detail component.
   */
  final case class PriceDetailComponent(
    key: io.flow.price.v0.models.PriceDetailComponentKey,
    amount: BigDecimal,
    label: String,
    name: _root_.scala.Option[String] = None
  )

  /**
   * Detailed information for the pricing of a given item within an experience.
   *
   * @param currency The currency in which these price details were calculated.
   * @param itemPrice Details of the item's base price in the catalog, including any applicable
   *        discounts.
   * @param margins Contains the currency margin, percent item margin, and fixed item margin.
   * @param vat The total amount of VAT applied. VAT is applied to the item price and optionally
   *        to the duty/shipping prices based on the destination country.
   * @param duty The total amount of DUTY applied. Duty is applied to the item price and
   *        optionally to the shipping prices based on the destination country, and also
   *        will take into account de minimis (thus amount may be zero if de minimis
   *        applies).
   * @param rounding The amount required to meet the rounding requirements from the experience's
   *        settings. For example, if an item price is 121.50, and the rounding setting is
   *        up to the nearest '1.00', rounding would return .50 here.
   * @param price The rounded price of the item as seen by customers in price detail pages, which
   *        takes into account VAT and duty pricing settings of the experience.
   * @param total The total price of the item as seen by customers at checkout, which includes the
   *        base price, discount, margins, VAT, duty, and rounding.
   * @param adjustment The total amount the total price was altered due to sales margins. A negative
   *        value indicates a discount.
   */
  final case class PriceDetails(
    currency: String,
    itemPrice: io.flow.price.v0.models.PriceDetail,
    margins: io.flow.price.v0.models.PriceDetail,
    vat: io.flow.price.v0.models.PriceDetail,
    duty: io.flow.price.v0.models.PriceDetail,
    rounding: io.flow.price.v0.models.PriceDetail,
    price: io.flow.common.v0.models.Price,
    total: io.flow.common.v0.models.Price,
    adjustment: _root_.scala.Option[io.flow.price.v0.models.PriceDetail] = None
  )

  /**
   * @param contractedRate The value of the contracted currency conversion rate between Flow and an
   *        organization.
   * @param rate The value of the currency conversion rate that includes an organization-specific
   *        margin if applicable.
   * @param pricing Contains pricing settings for VAT, duty, and rounding.
   * @param basePrice The base price of the product.
   * @param discount The discount to apply to the base price of the product in the same currency as
   *        the base product.
   * @param fixedMargin A fixed amount to add, e.g 2.5 would add an absolute margin of 2.5 in the base
   *        currency of your item.
   * @param percentMargin A percent of the base cost to add, e.g. 1.2 would represent a 1.2% increase.
   * @param insurance The insurance information associated with the product.
   * @param freight The freight information associated with the product.
   * @param duty The duty rate applicable to the product. A value of 15 indicates a duty rate of
   *        15%.
   * @param tax The tax rate applicable to the product. A value of 17 indicates a tax rate of
   *        17%.
   * @param percentSalesMargin A percent sales margin to apply after the other margins, duties, taxes and
   *        margins. A value of 17 indicates an increase of 17%. A value of 5.5 indicates a
   *        discount of 5.5%
   */
  final case class PriceEquation(
    contractedRate: BigDecimal,
    rate: BigDecimal,
    pricing: io.flow.price.v0.models.Pricing,
    basePrice: BigDecimal,
    discount: BigDecimal,
    fixedMargin: BigDecimal,
    percentMargin: BigDecimal,
    insurance: BigDecimal,
    freight: BigDecimal,
    duty: _root_.scala.Option[io.flow.price.v0.models.Duty] = None,
    tax: _root_.scala.Option[io.flow.price.v0.models.Tax] = None,
    percentSalesMargin: BigDecimal = 0
  )

  /**
   * Pricing determines how the item price is calculated when items are requests via
   * the experience.
   *
   * @param vat Determines how VAT is treated within this experience - whether it is included in
   *        the item price, displayed as a stand alone line item, or ignored - and only used
   *        in checkout (see the orders resource)
   * @param duty Determines how Duty is treated within this experience - whether it is included
   *        in the item price, displayed as a stand alone line item, or ignored - and only
   *        used in checkout (see the orders resource)
   * @param rounding If specified, we will round prices in this experience
   */
  final case class Pricing(
    vat: io.flow.price.v0.models.PricingLevySetting,
    duty: io.flow.price.v0.models.PricingLevySetting,
    rounding: _root_.scala.Option[io.flow.common.v0.models.Rounding] = None
  )

  /**
   * Represents a simple model of taxes that apply to a given item / destination.
   *
   * @param name The name of the taxes being applied
   * @param rate The combined tax rate. A value of 17 indicates a tax rate of 17%
   * @param components The components to which tax is applied.
   * @param deminimis Describes the tax de minimis if there is one for this destination
   */
  final case class Tax(
    name: String,
    rate: BigDecimal,
    components: Seq[io.flow.price.v0.models.LevyComponent],
    deminimis: _root_.scala.Option[io.flow.price.v0.models.Deminimis] = None
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union Deminimis, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class DeminimisUndefinedType(
    description: String
  ) extends Deminimis
  sealed trait LevyComponent extends _root_.scala.Product with _root_.scala.Serializable

  object LevyComponent {

    /**
     * The value of goods
     */
    case object Goods extends LevyComponent { override def toString = "goods" }
    case object Duty extends LevyComponent { override def toString = "duty" }
    case object Insurance extends LevyComponent { override def toString = "insurance" }
    case object Freight extends LevyComponent { override def toString = "freight" }
    /**
     * Value-Added Tax
     */
    case object Vat extends LevyComponent { override def toString = "vat" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends LevyComponent

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[LevyComponent] = scala.List(Goods, Duty, Insurance, Freight, Vat)

    private[this]
    val byName: Map[String, LevyComponent] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): LevyComponent = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[LevyComponent] = byName.get(value.toLowerCase)

  }

  sealed trait LevyStrategy extends _root_.scala.Product with _root_.scala.Serializable

  object LevyStrategy {

    case object Minimum extends LevyStrategy { override def toString = "minimum" }
    case object Average extends LevyStrategy { override def toString = "average" }
    case object Maximum extends LevyStrategy { override def toString = "maximum" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends LevyStrategy

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[LevyStrategy] = scala.List(Minimum, Average, Maximum)

    private[this]
    val byName: Map[String, LevyStrategy] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): LevyStrategy = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[LevyStrategy] = byName.get(value.toLowerCase)

  }

  /**
   * Used to identify the accuracy of a price.
   */
  sealed trait PriceAccuracy extends _root_.scala.Product with _root_.scala.Serializable

  object PriceAccuracy {

    /**
     * The price shown is accurate and will not change unless information already
     * provided also changes.
     */
    case object Calculated extends PriceAccuracy { override def toString = "calculated" }
    /**
     * The price shown is based on the best information provided; given a more precise
     * address, the price may change.
     */
    case object EstimatedFromPartialDestination extends PriceAccuracy { override def toString = "estimated_from_partial_destination" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends PriceAccuracy

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[PriceAccuracy] = scala.List(Calculated, EstimatedFromPartialDestination)

    private[this]
    val byName: Map[String, PriceAccuracy] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PriceAccuracy = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PriceAccuracy] = byName.get(value.toLowerCase)

  }

  sealed trait PriceDetailComponentKey extends _root_.scala.Product with _root_.scala.Serializable

  object PriceDetailComponentKey {

    /**
     * The base price of the item.
     */
    case object BasePrice extends PriceDetailComponentKey { override def toString = "base_price" }
    /**
     * A discount applied to the base price of the item.
     */
    case object Discount extends PriceDetailComponentKey { override def toString = "discount" }
    /**
     * The amount added to the post-discount item price due to FX markup, as configured
     * in the organization's currency settings.
     */
    case object CurrencyMargin extends PriceDetailComponentKey { override def toString = "currency_margin" }
    /**
     * The amount added to the post-discount item price from a percent item margin.
     * Negative amounts represent discounts.
     */
    case object PercentItemMargin extends PriceDetailComponentKey { override def toString = "percent_item_margin" }
    /**
     * The amount added to the post-discount item price from a fixed item margin.
     * Negative amounts represent discounts.
     */
    case object FixedItemMargin extends PriceDetailComponentKey { override def toString = "fixed_item_margin" }
    /**
     * The duty owed on the post-discount base item price.
     */
    case object DutiesItemPrice extends PriceDetailComponentKey { override def toString = "duties_item_price" }
    /**
     * The duty owed on the sum of the currency margin, percent item margin, and fixed
     * item margin.
     */
    case object DutiesAddedMargin extends PriceDetailComponentKey { override def toString = "duties_added_margin" }
    /**
     * The duty owed on any rounding applied to the total item price.
     */
    case object DutiesRounding extends PriceDetailComponentKey { override def toString = "duties_rounding" }
    /**
     * An adjustment made if the item does not meet the duty de minimis rule.
     */
    case object DutiesDeminimis extends PriceDetailComponentKey { override def toString = "duties_deminimis" }
    /**
     * The VAT owed on the post-discount base item price.
     */
    case object VatItemPrice extends PriceDetailComponentKey { override def toString = "vat_item_price" }
    /**
     * The VAT owed on the sum of the currency margin, percent item margin, and fixed
     * item margin.
     */
    case object VatAddedMargin extends PriceDetailComponentKey { override def toString = "vat_added_margin" }
    /**
     * The VAT owed on any rounding applied to the total item price.
     */
    case object VatRounding extends PriceDetailComponentKey { override def toString = "vat_rounding" }
    /**
     * The VAT owed on the duty owed on the post-discount base item price.
     */
    case object VatDutiesItemPrice extends PriceDetailComponentKey { override def toString = "vat_duties_item_price" }
    /**
     * The VAT owed on the duty owed on the sum of the currency margin, percent item
     * margin, and fixed item margin.
     */
    case object VatDutiesAddedMargin extends PriceDetailComponentKey { override def toString = "vat_duties_added_margin" }
    /**
     * The VAT owed on the duty owed on any rounding applied to the total item price.
     */
    case object VatDutiesRounding extends PriceDetailComponentKey { override def toString = "vat_duties_rounding" }
    /**
     * An adjustment made if the item does not meet the VAT de minimis rule.
     */
    case object VatDeminimis extends PriceDetailComponentKey { override def toString = "vat_deminimis" }
    /**
     * An adjustment made to the item price as a result of a percent sales margin.
     */
    case object ItemPricePercentSalesMargin extends PriceDetailComponentKey { override def toString = "item_price_percent_sales_margin" }
    /**
     * An adjustment made to the item margins as a result of a percent sales margin.
     */
    case object MarginsPercentSalesMargin extends PriceDetailComponentKey { override def toString = "margins_percent_sales_margin" }
    /**
     * An adjustment made to rounding as a result of a percent sales margin.
     */
    case object RoundingPercentSalesMargin extends PriceDetailComponentKey { override def toString = "rounding_percent_sales_margin" }
    /**
     * An adjustment made to VAT owed as a result of a percent sales margin.
     */
    case object VatPercentSalesMargin extends PriceDetailComponentKey { override def toString = "vat_percent_sales_margin" }
    /**
     * An adjustment made to VAT on duties (e.g. VAT on duties on item price) owed as a
     * result of a percent sales margin.
     */
    case object VatDutyPercentSalesMargin extends PriceDetailComponentKey { override def toString = "vat_duty_percent_sales_margin" }
    /**
     * An adjustment made to duty owed as a result of a percent sales margin.
     */
    case object DutyPercentSalesMargin extends PriceDetailComponentKey { override def toString = "duty_percent_sales_margin" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends PriceDetailComponentKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[PriceDetailComponentKey] = scala.List(BasePrice, Discount, CurrencyMargin, PercentItemMargin, FixedItemMargin, DutiesItemPrice, DutiesAddedMargin, DutiesRounding, DutiesDeminimis, VatItemPrice, VatAddedMargin, VatRounding, VatDutiesItemPrice, VatDutiesAddedMargin, VatDutiesRounding, VatDeminimis, ItemPricePercentSalesMargin, MarginsPercentSalesMargin, RoundingPercentSalesMargin, VatPercentSalesMargin, VatDutyPercentSalesMargin, DutyPercentSalesMargin)

    private[this]
    val byName: Map[String, PriceDetailComponentKey] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PriceDetailComponentKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PriceDetailComponentKey] = byName.get(value.toLowerCase)

  }

  sealed trait PriceDetailKey extends _root_.scala.Product with _root_.scala.Serializable

  object PriceDetailKey {

    /**
     * The details of the item price.
     */
    case object ItemPrice extends PriceDetailKey { override def toString = "item_price" }
    /**
     * The details of any margins added to the item price.
     */
    case object Margins extends PriceDetailKey { override def toString = "margins" }
    /**
     * The details of any VAT owed on the item.
     */
    case object Vat extends PriceDetailKey { override def toString = "vat" }
    /**
     * The details of any duties owed on the item.
     */
    case object Duty extends PriceDetailKey { override def toString = "duty" }
    /**
     * The details of any rounding added to the item.
     */
    case object Rounding extends PriceDetailKey { override def toString = "rounding" }
    /**
     * The details of any price adjustments due to sales margins. A negative value
     * indicates a discount.
     */
    case object Adjustment extends PriceDetailKey { override def toString = "adjustment" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends PriceDetailKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[PriceDetailKey] = scala.List(ItemPrice, Margins, Vat, Duty, Rounding, Adjustment)

    private[this]
    val byName: Map[String, PriceDetailKey] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PriceDetailKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PriceDetailKey] = byName.get(value.toLowerCase)

  }

  sealed trait PricingLevySetting extends _root_.scala.Product with _root_.scala.Serializable

  object PricingLevySetting {

    case object Included extends PricingLevySetting { override def toString = "included" }
    case object Displayed extends PricingLevySetting { override def toString = "displayed" }
    case object Ignored extends PricingLevySetting { override def toString = "ignored" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends PricingLevySetting

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[PricingLevySetting] = scala.List(Included, Displayed, Ignored)

    private[this]
    val byName: Map[String, PricingLevySetting] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PricingLevySetting = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PricingLevySetting] = byName.get(value.toLowerCase)

  }

}

package io.flow.price.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.common.v0.models.json._
    import io.flow.error.v0.models.json._
    import io.flow.price.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map { str =>
      _root_.java.util.UUID.fromString(str)
    }

    private[v0] implicit val jsonWritesUUID = new Writes[_root_.java.util.UUID] {
      def writes(x: _root_.java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[_root_.org.joda.time.DateTime] {
      def writes(x: _root_.org.joda.time.DateTime) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x))
      }
    }

    private[v0] implicit val jsonReadsJodaLocalDate = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(str)
    }

    private[v0] implicit val jsonWritesJodaLocalDate = new Writes[_root_.org.joda.time.LocalDate] {
      def writes(x: _root_.org.joda.time.LocalDate) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.date.print(x))
      }
    }

    implicit val jsonReadsPriceLevyComponent = new play.api.libs.json.Reads[io.flow.price.v0.models.LevyComponent] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.price.v0.models.LevyComponent] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.price.v0.models.LevyComponent(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.price.v0.models.LevyComponent(v))
              case err: play.api.libs.json.JsError =>
                (js \ "levy_component").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.price.v0.models.LevyComponent(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPriceLevyComponent(obj: io.flow.price.v0.models.LevyComponent) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectLevyComponent(obj: io.flow.price.v0.models.LevyComponent) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPriceLevyComponent: play.api.libs.json.Writes[LevyComponent] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.LevyComponent] {
        def writes(obj: io.flow.price.v0.models.LevyComponent) = {
          jsonWritesPriceLevyComponent(obj)
        }
      }
    }

    implicit val jsonReadsPriceLevyStrategy = new play.api.libs.json.Reads[io.flow.price.v0.models.LevyStrategy] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.price.v0.models.LevyStrategy] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.price.v0.models.LevyStrategy(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.price.v0.models.LevyStrategy(v))
              case err: play.api.libs.json.JsError =>
                (js \ "levy_strategy").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.price.v0.models.LevyStrategy(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPriceLevyStrategy(obj: io.flow.price.v0.models.LevyStrategy) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectLevyStrategy(obj: io.flow.price.v0.models.LevyStrategy) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPriceLevyStrategy: play.api.libs.json.Writes[LevyStrategy] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.LevyStrategy] {
        def writes(obj: io.flow.price.v0.models.LevyStrategy) = {
          jsonWritesPriceLevyStrategy(obj)
        }
      }
    }

    implicit val jsonReadsPricePriceAccuracy = new play.api.libs.json.Reads[io.flow.price.v0.models.PriceAccuracy] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.price.v0.models.PriceAccuracy] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PriceAccuracy(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PriceAccuracy(v))
              case err: play.api.libs.json.JsError =>
                (js \ "price_accuracy").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PriceAccuracy(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPricePriceAccuracy(obj: io.flow.price.v0.models.PriceAccuracy) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPriceAccuracy(obj: io.flow.price.v0.models.PriceAccuracy) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPricePriceAccuracy: play.api.libs.json.Writes[PriceAccuracy] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceAccuracy] {
        def writes(obj: io.flow.price.v0.models.PriceAccuracy) = {
          jsonWritesPricePriceAccuracy(obj)
        }
      }
    }

    implicit val jsonReadsPricePriceDetailComponentKey = new play.api.libs.json.Reads[io.flow.price.v0.models.PriceDetailComponentKey] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.price.v0.models.PriceDetailComponentKey] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PriceDetailComponentKey(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PriceDetailComponentKey(v))
              case err: play.api.libs.json.JsError =>
                (js \ "price_detail_component_key").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PriceDetailComponentKey(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPricePriceDetailComponentKey(obj: io.flow.price.v0.models.PriceDetailComponentKey) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPriceDetailComponentKey(obj: io.flow.price.v0.models.PriceDetailComponentKey) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPricePriceDetailComponentKey: play.api.libs.json.Writes[PriceDetailComponentKey] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceDetailComponentKey] {
        def writes(obj: io.flow.price.v0.models.PriceDetailComponentKey) = {
          jsonWritesPricePriceDetailComponentKey(obj)
        }
      }
    }

    implicit val jsonReadsPricePriceDetailKey = new play.api.libs.json.Reads[io.flow.price.v0.models.PriceDetailKey] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.price.v0.models.PriceDetailKey] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PriceDetailKey(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PriceDetailKey(v))
              case err: play.api.libs.json.JsError =>
                (js \ "price_detail_key").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PriceDetailKey(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPricePriceDetailKey(obj: io.flow.price.v0.models.PriceDetailKey) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPriceDetailKey(obj: io.flow.price.v0.models.PriceDetailKey) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPricePriceDetailKey: play.api.libs.json.Writes[PriceDetailKey] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceDetailKey] {
        def writes(obj: io.flow.price.v0.models.PriceDetailKey) = {
          jsonWritesPricePriceDetailKey(obj)
        }
      }
    }

    implicit val jsonReadsPricePricingLevySetting = new play.api.libs.json.Reads[io.flow.price.v0.models.PricingLevySetting] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.price.v0.models.PricingLevySetting] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PricingLevySetting(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PricingLevySetting(v))
              case err: play.api.libs.json.JsError =>
                (js \ "pricing_levy_setting").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.price.v0.models.PricingLevySetting(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPricePricingLevySetting(obj: io.flow.price.v0.models.PricingLevySetting) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPricingLevySetting(obj: io.flow.price.v0.models.PricingLevySetting) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPricePricingLevySetting: play.api.libs.json.Writes[PricingLevySetting] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PricingLevySetting] {
        def writes(obj: io.flow.price.v0.models.PricingLevySetting) = {
          jsonWritesPricePricingLevySetting(obj)
        }
      }
    }

    implicit def jsonReadsPriceCurrencyFormat: play.api.libs.json.Reads[CurrencyFormat] = {
      for {
        symbol <- (__ \ "symbol").read[io.flow.common.v0.models.CurrencySymbolFormat]
        labelFormatters <- (__ \ "label_formatters").read[Seq[io.flow.common.v0.models.CurrencyLabelFormatter]]
      } yield CurrencyFormat(symbol, labelFormatters)
    }

    def jsObjectCurrencyFormat(obj: io.flow.price.v0.models.CurrencyFormat): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "symbol" -> play.api.libs.json.JsString(obj.symbol.toString),
        "label_formatters" -> play.api.libs.json.Json.toJson(obj.labelFormatters)
      )
    }

    implicit def jsonWritesPriceCurrencyFormat: play.api.libs.json.Writes[CurrencyFormat] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.CurrencyFormat] {
        def writes(obj: io.flow.price.v0.models.CurrencyFormat) = {
          jsObjectCurrencyFormat(obj)
        }
      }
    }

    implicit def jsonReadsPriceDeminimisPerItem: play.api.libs.json.Reads[DeminimisPerItem] = {
      for {
        currency <- (__ \ "currency").read[String]
        minimum <- (__ \ "minimum").readNullable[BigDecimal]
        maximum <- (__ \ "maximum").readNullable[BigDecimal]
      } yield DeminimisPerItem(currency, minimum, maximum)
    }

    def jsObjectDeminimisPerItem(obj: io.flow.price.v0.models.DeminimisPerItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.minimum match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("minimum" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.maximum match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("maximum" -> play.api.libs.json.JsNumber(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "deminimis_per_item")
    }

    implicit def jsonWritesPriceDeminimisPerItem: play.api.libs.json.Writes[DeminimisPerItem] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.DeminimisPerItem] {
        def writes(obj: io.flow.price.v0.models.DeminimisPerItem) = {
          jsObjectDeminimisPerItem(obj)
        }
      }
    }

    implicit def jsonReadsPriceDeminimisSimple: play.api.libs.json.Reads[DeminimisSimple] = {
      for {
        value <- (__ \ "value").readNullable[BigDecimal]
        currency <- (__ \ "currency").read[String]
        components <- (__ \ "components").read[Seq[io.flow.price.v0.models.LevyComponent]]
        minimum <- (__ \ "minimum").readNullable[BigDecimal]
      } yield DeminimisSimple(value, currency, components, minimum)
    }

    def jsObjectDeminimisSimple(obj: io.flow.price.v0.models.DeminimisSimple): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "components" -> play.api.libs.json.Json.toJson(obj.components)
      ) ++ (obj.value match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.minimum match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("minimum" -> play.api.libs.json.JsNumber(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "deminimis_simple")
    }

    implicit def jsonWritesPriceDeminimisSimple: play.api.libs.json.Writes[DeminimisSimple] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.DeminimisSimple] {
        def writes(obj: io.flow.price.v0.models.DeminimisSimple) = {
          jsObjectDeminimisSimple(obj)
        }
      }
    }

    implicit def jsonReadsPriceDuty: play.api.libs.json.Reads[Duty] = {
      for {
        rate <- (__ \ "rate").read[BigDecimal]
        components <- (__ \ "components").read[Seq[io.flow.price.v0.models.LevyComponent]]
        deminimis <- (__ \ "deminimis").readNullable[io.flow.price.v0.models.Deminimis]
        name <- (__ \ "name").readNullable[String]
      } yield Duty(rate, components, deminimis, name)
    }

    def jsObjectDuty(obj: io.flow.price.v0.models.Duty): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "rate" -> play.api.libs.json.JsNumber(obj.rate),
        "components" -> play.api.libs.json.Json.toJson(obj.components)
      ) ++ (obj.deminimis match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("deminimis" -> jsObjectDeminimis(x))
      }) ++
      (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesPriceDuty: play.api.libs.json.Writes[Duty] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.Duty] {
        def writes(obj: io.flow.price.v0.models.Duty) = {
          jsObjectDuty(obj)
        }
      }
    }

    implicit def jsonReadsPriceLocalPriceDetails: play.api.libs.json.Reads[LocalPriceDetails] = {
      for {
        base <- (__ \ "base").read[io.flow.price.v0.models.PriceDetails]
        local <- (__ \ "local").read[io.flow.price.v0.models.PriceDetails]
        discount <- (__ \ "discount").readNullable[io.flow.price.v0.models.PriceDetail]
        localBeforeDiscount <- (__ \ "local_before_discount").readNullable[io.flow.price.v0.models.PriceDetail]
      } yield LocalPriceDetails(base, local, discount, localBeforeDiscount)
    }

    def jsObjectLocalPriceDetails(obj: io.flow.price.v0.models.LocalPriceDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "base" -> jsObjectPriceDetails(obj.base),
        "local" -> jsObjectPriceDetails(obj.local)
      ) ++ (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> jsObjectPriceDetail(x))
      }) ++
      (obj.localBeforeDiscount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("local_before_discount" -> jsObjectPriceDetail(x))
      })
    }

    implicit def jsonWritesPriceLocalPriceDetails: play.api.libs.json.Writes[LocalPriceDetails] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.LocalPriceDetails] {
        def writes(obj: io.flow.price.v0.models.LocalPriceDetails) = {
          jsObjectLocalPriceDetails(obj)
        }
      }
    }

    implicit def jsonReadsPricePriceBook: play.api.libs.json.Reads[PriceBook] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        currency <- (__ \ "currency").read[String]
        name <- (__ \ "name").read[String]
        includes <- (__ \ "includes").read[io.flow.common.v0.models.IncludedLevies]
        status <- (__ \ "status").read[io.flow.common.v0.models.PriceBookStatus]
      } yield PriceBook(id, key, currency, name, includes, status)
    }

    def jsObjectPriceBook(obj: io.flow.price.v0.models.PriceBook): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "name" -> play.api.libs.json.JsString(obj.name),
        "includes" -> io.flow.common.v0.models.json.jsObjectIncludedLevies(obj.includes),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      )
    }

    implicit def jsonWritesPricePriceBook: play.api.libs.json.Writes[PriceBook] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceBook] {
        def writes(obj: io.flow.price.v0.models.PriceBook) = {
          jsObjectPriceBook(obj)
        }
      }
    }

    implicit def jsonReadsPricePriceBookForm: play.api.libs.json.Reads[PriceBookForm] = {
      for {
        currency <- (__ \ "currency").read[String]
        name <- (__ \ "name").read[String]
        includes <- (__ \ "includes").read[io.flow.common.v0.models.IncludedLevyKey]
        status <- (__ \ "status").readWithDefault[io.flow.common.v0.models.PriceBookStatus](io.flow.common.v0.models.PriceBookStatus.Draft)
      } yield PriceBookForm(currency, name, includes, status)
    }

    def jsObjectPriceBookForm(obj: io.flow.price.v0.models.PriceBookForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "name" -> play.api.libs.json.JsString(obj.name),
        "includes" -> play.api.libs.json.JsString(obj.includes.toString),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      )
    }

    implicit def jsonWritesPricePriceBookForm: play.api.libs.json.Writes[PriceBookForm] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceBookForm] {
        def writes(obj: io.flow.price.v0.models.PriceBookForm) = {
          jsObjectPriceBookForm(obj)
        }
      }
    }

    implicit def jsonReadsPricePriceBookItem: play.api.libs.json.Reads[PriceBookItem] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        priceBook <- (__ \ "price_book").read[io.flow.price.v0.models.PriceBookReference]
        price <- (__ \ "price").read[io.flow.common.v0.models.Price]
        itemNumber <- (__ \ "item_number").read[String]
        schedule <- (__ \ "schedule").read[io.flow.price.v0.models.PriceBookItemSchedule]
        itemAttributes <- (__ \ "item_attributes").readNullable[Map[String, String]]
      } yield PriceBookItem(id, key, priceBook, price, itemNumber, schedule, itemAttributes)
    }

    def jsObjectPriceBookItem(obj: io.flow.price.v0.models.PriceBookItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "price_book" -> jsObjectPriceBookReference(obj.priceBook),
        "price" -> io.flow.common.v0.models.json.jsObjectPrice(obj.price),
        "item_number" -> play.api.libs.json.JsString(obj.itemNumber),
        "schedule" -> jsObjectPriceBookItemSchedule(obj.schedule)
      ) ++ (obj.itemAttributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("item_attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesPricePriceBookItem: play.api.libs.json.Writes[PriceBookItem] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceBookItem] {
        def writes(obj: io.flow.price.v0.models.PriceBookItem) = {
          jsObjectPriceBookItem(obj)
        }
      }
    }

    implicit def jsonReadsPricePriceBookItemForm: play.api.libs.json.Reads[PriceBookItemForm] = {
      for {
        priceBookKey <- (__ \ "price_book_key").read[String]
        itemNumber <- (__ \ "item_number").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        schedule <- (__ \ "schedule").readNullable[io.flow.price.v0.models.PriceBookItemSchedule]
        itemAttributes <- (__ \ "item_attributes").readNullable[Map[String, String]]
      } yield PriceBookItemForm(priceBookKey, itemNumber, amount, schedule, itemAttributes)
    }

    def jsObjectPriceBookItemForm(obj: io.flow.price.v0.models.PriceBookItemForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "price_book_key" -> play.api.libs.json.JsString(obj.priceBookKey),
        "item_number" -> play.api.libs.json.JsString(obj.itemNumber),
        "amount" -> play.api.libs.json.JsNumber(obj.amount)
      ) ++ (obj.schedule match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("schedule" -> jsObjectPriceBookItemSchedule(x))
      }) ++
      (obj.itemAttributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("item_attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesPricePriceBookItemForm: play.api.libs.json.Writes[PriceBookItemForm] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceBookItemForm] {
        def writes(obj: io.flow.price.v0.models.PriceBookItemForm) = {
          jsObjectPriceBookItemForm(obj)
        }
      }
    }

    implicit def jsonReadsPricePriceBookItemQueryForm: play.api.libs.json.Reads[PriceBookItemQueryForm] = {
      for {
        priceBookKey <- (__ \ "price_book_key").read[String]
        itemQuery <- (__ \ "item_query").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        schedule <- (__ \ "schedule").readNullable[io.flow.price.v0.models.PriceBookItemSchedule]
        itemAttributes <- (__ \ "item_attributes").readNullable[Map[String, String]]
      } yield PriceBookItemQueryForm(priceBookKey, itemQuery, amount, schedule, itemAttributes)
    }

    def jsObjectPriceBookItemQueryForm(obj: io.flow.price.v0.models.PriceBookItemQueryForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "price_book_key" -> play.api.libs.json.JsString(obj.priceBookKey),
        "item_query" -> play.api.libs.json.JsString(obj.itemQuery),
        "amount" -> play.api.libs.json.JsNumber(obj.amount)
      ) ++ (obj.schedule match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("schedule" -> jsObjectPriceBookItemSchedule(x))
      }) ++
      (obj.itemAttributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("item_attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesPricePriceBookItemQueryForm: play.api.libs.json.Writes[PriceBookItemQueryForm] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceBookItemQueryForm] {
        def writes(obj: io.flow.price.v0.models.PriceBookItemQueryForm) = {
          jsObjectPriceBookItemQueryForm(obj)
        }
      }
    }

    implicit def jsonReadsPricePriceBookItemSchedule: play.api.libs.json.Reads[PriceBookItemSchedule] = {
      for {
        startsAt <- (__ \ "starts_at").read[_root_.org.joda.time.DateTime]
        endsAt <- (__ \ "ends_at").readNullable[_root_.org.joda.time.DateTime]
      } yield PriceBookItemSchedule(startsAt, endsAt)
    }

    def jsObjectPriceBookItemSchedule(obj: io.flow.price.v0.models.PriceBookItemSchedule): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "starts_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.startsAt))
      ) ++ (obj.endsAt match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ends_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      })
    }

    implicit def jsonWritesPricePriceBookItemSchedule: play.api.libs.json.Writes[PriceBookItemSchedule] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceBookItemSchedule] {
        def writes(obj: io.flow.price.v0.models.PriceBookItemSchedule) = {
          jsObjectPriceBookItemSchedule(obj)
        }
      }
    }

    implicit def jsonReadsPricePriceBookReference: play.api.libs.json.Reads[PriceBookReference] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
      } yield PriceBookReference(id, key)
    }

    def jsObjectPriceBookReference(obj: io.flow.price.v0.models.PriceBookReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonWritesPricePriceBookReference: play.api.libs.json.Writes[PriceBookReference] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceBookReference] {
        def writes(obj: io.flow.price.v0.models.PriceBookReference) = {
          jsObjectPriceBookReference(obj)
        }
      }
    }

    implicit def jsonReadsPricePriceCheck: play.api.libs.json.Reads[PriceCheck] = {
      for {
        display <- (__ \ "display").read[io.flow.price.v0.models.LocalPriceDetails]
        `final` <- (__ \ "final").read[io.flow.price.v0.models.LocalPriceDetails]
      } yield PriceCheck(display, `final`)
    }

    def jsObjectPriceCheck(obj: io.flow.price.v0.models.PriceCheck): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "display" -> jsObjectLocalPriceDetails(obj.display),
        "final" -> jsObjectLocalPriceDetails(obj.`final`)
      )
    }

    implicit def jsonWritesPricePriceCheck: play.api.libs.json.Writes[PriceCheck] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceCheck] {
        def writes(obj: io.flow.price.v0.models.PriceCheck) = {
          jsObjectPriceCheck(obj)
        }
      }
    }

    implicit def jsonReadsPricePriceDetail: play.api.libs.json.Reads[PriceDetail] = {
      for {
        key <- (__ \ "key").read[io.flow.price.v0.models.PriceDetailKey]
        components <- (__ \ "components").read[Seq[io.flow.price.v0.models.PriceDetailComponent]]
        amount <- (__ \ "amount").read[BigDecimal]
        label <- (__ \ "label").read[String]
        name <- (__ \ "name").readNullable[String]
        basis <- (__ \ "basis").readNullable[BigDecimal]
      } yield PriceDetail(key, components, amount, label, name, basis)
    }

    def jsObjectPriceDetail(obj: io.flow.price.v0.models.PriceDetail): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "components" -> play.api.libs.json.Json.toJson(obj.components),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.basis match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("basis" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesPricePriceDetail: play.api.libs.json.Writes[PriceDetail] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceDetail] {
        def writes(obj: io.flow.price.v0.models.PriceDetail) = {
          jsObjectPriceDetail(obj)
        }
      }
    }

    implicit def jsonReadsPricePriceDetailComponent: play.api.libs.json.Reads[PriceDetailComponent] = {
      for {
        key <- (__ \ "key").read[io.flow.price.v0.models.PriceDetailComponentKey]
        amount <- (__ \ "amount").read[BigDecimal]
        label <- (__ \ "label").read[String]
        name <- (__ \ "name").readNullable[String]
      } yield PriceDetailComponent(key, amount, label, name)
    }

    def jsObjectPriceDetailComponent(obj: io.flow.price.v0.models.PriceDetailComponent): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesPricePriceDetailComponent: play.api.libs.json.Writes[PriceDetailComponent] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceDetailComponent] {
        def writes(obj: io.flow.price.v0.models.PriceDetailComponent) = {
          jsObjectPriceDetailComponent(obj)
        }
      }
    }

    implicit def jsonReadsPricePriceDetails: play.api.libs.json.Reads[PriceDetails] = {
      for {
        currency <- (__ \ "currency").read[String]
        itemPrice <- (__ \ "item_price").read[io.flow.price.v0.models.PriceDetail]
        margins <- (__ \ "margins").read[io.flow.price.v0.models.PriceDetail]
        vat <- (__ \ "vat").read[io.flow.price.v0.models.PriceDetail]
        duty <- (__ \ "duty").read[io.flow.price.v0.models.PriceDetail]
        rounding <- (__ \ "rounding").read[io.flow.price.v0.models.PriceDetail]
        price <- (__ \ "price").read[io.flow.common.v0.models.Price]
        total <- (__ \ "total").read[io.flow.common.v0.models.Price]
        adjustment <- (__ \ "adjustment").readNullable[io.flow.price.v0.models.PriceDetail]
      } yield PriceDetails(currency, itemPrice, margins, vat, duty, rounding, price, total, adjustment)
    }

    def jsObjectPriceDetails(obj: io.flow.price.v0.models.PriceDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "item_price" -> jsObjectPriceDetail(obj.itemPrice),
        "margins" -> jsObjectPriceDetail(obj.margins),
        "vat" -> jsObjectPriceDetail(obj.vat),
        "duty" -> jsObjectPriceDetail(obj.duty),
        "rounding" -> jsObjectPriceDetail(obj.rounding),
        "price" -> io.flow.common.v0.models.json.jsObjectPrice(obj.price),
        "total" -> io.flow.common.v0.models.json.jsObjectPrice(obj.total)
      ) ++ (obj.adjustment match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("adjustment" -> jsObjectPriceDetail(x))
      })
    }

    implicit def jsonWritesPricePriceDetails: play.api.libs.json.Writes[PriceDetails] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceDetails] {
        def writes(obj: io.flow.price.v0.models.PriceDetails) = {
          jsObjectPriceDetails(obj)
        }
      }
    }

    implicit def jsonReadsPricePriceEquation: play.api.libs.json.Reads[PriceEquation] = {
      for {
        contractedRate <- (__ \ "contracted_rate").read[BigDecimal]
        rate <- (__ \ "rate").read[BigDecimal]
        pricing <- (__ \ "pricing").read[io.flow.price.v0.models.Pricing]
        basePrice <- (__ \ "base_price").read[BigDecimal]
        discount <- (__ \ "discount").read[BigDecimal]
        fixedMargin <- (__ \ "fixed_margin").read[BigDecimal]
        percentMargin <- (__ \ "percent_margin").read[BigDecimal]
        insurance <- (__ \ "insurance").read[BigDecimal]
        freight <- (__ \ "freight").read[BigDecimal]
        duty <- (__ \ "duty").readNullable[io.flow.price.v0.models.Duty]
        tax <- (__ \ "tax").readNullable[io.flow.price.v0.models.Tax]
        percentSalesMargin <- (__ \ "percent_sales_margin").read[BigDecimal]
      } yield PriceEquation(contractedRate, rate, pricing, basePrice, discount, fixedMargin, percentMargin, insurance, freight, duty, tax, percentSalesMargin)
    }

    def jsObjectPriceEquation(obj: io.flow.price.v0.models.PriceEquation): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "contracted_rate" -> play.api.libs.json.JsNumber(obj.contractedRate),
        "rate" -> play.api.libs.json.JsNumber(obj.rate),
        "pricing" -> jsObjectPricing(obj.pricing),
        "base_price" -> play.api.libs.json.JsNumber(obj.basePrice),
        "discount" -> play.api.libs.json.JsNumber(obj.discount),
        "fixed_margin" -> play.api.libs.json.JsNumber(obj.fixedMargin),
        "percent_margin" -> play.api.libs.json.JsNumber(obj.percentMargin),
        "insurance" -> play.api.libs.json.JsNumber(obj.insurance),
        "freight" -> play.api.libs.json.JsNumber(obj.freight),
        "percent_sales_margin" -> play.api.libs.json.JsNumber(obj.percentSalesMargin)
      ) ++ (obj.duty match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("duty" -> jsObjectDuty(x))
      }) ++
      (obj.tax match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tax" -> jsObjectTax(x))
      })
    }

    implicit def jsonWritesPricePriceEquation: play.api.libs.json.Writes[PriceEquation] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.PriceEquation] {
        def writes(obj: io.flow.price.v0.models.PriceEquation) = {
          jsObjectPriceEquation(obj)
        }
      }
    }

    implicit def jsonReadsPricePricing: play.api.libs.json.Reads[Pricing] = {
      for {
        vat <- (__ \ "vat").read[io.flow.price.v0.models.PricingLevySetting]
        duty <- (__ \ "duty").read[io.flow.price.v0.models.PricingLevySetting]
        rounding <- (__ \ "rounding").readNullable[io.flow.common.v0.models.Rounding]
      } yield Pricing(vat, duty, rounding)
    }

    def jsObjectPricing(obj: io.flow.price.v0.models.Pricing): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "vat" -> play.api.libs.json.JsString(obj.vat.toString),
        "duty" -> play.api.libs.json.JsString(obj.duty.toString)
      ) ++ (obj.rounding match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("rounding" -> io.flow.common.v0.models.json.jsObjectRounding(x))
      })
    }

    implicit def jsonWritesPricePricing: play.api.libs.json.Writes[Pricing] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.Pricing] {
        def writes(obj: io.flow.price.v0.models.Pricing) = {
          jsObjectPricing(obj)
        }
      }
    }

    implicit def jsonReadsPriceTax: play.api.libs.json.Reads[Tax] = {
      for {
        name <- (__ \ "name").read[String]
        rate <- (__ \ "rate").read[BigDecimal]
        components <- (__ \ "components").read[Seq[io.flow.price.v0.models.LevyComponent]]
        deminimis <- (__ \ "deminimis").readNullable[io.flow.price.v0.models.Deminimis]
      } yield Tax(name, rate, components, deminimis)
    }

    def jsObjectTax(obj: io.flow.price.v0.models.Tax): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "rate" -> play.api.libs.json.JsNumber(obj.rate),
        "components" -> play.api.libs.json.Json.toJson(obj.components)
      ) ++ (obj.deminimis match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("deminimis" -> jsObjectDeminimis(x))
      })
    }

    implicit def jsonWritesPriceTax: play.api.libs.json.Writes[Tax] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.Tax] {
        def writes(obj: io.flow.price.v0.models.Tax) = {
          jsObjectTax(obj)
        }
      }
    }

    implicit def jsonReadsPriceDeminimis: play.api.libs.json.Reads[Deminimis] = new play.api.libs.json.Reads[Deminimis] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[Deminimis] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[Deminimis] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "deminimis_simple" => js.validate[io.flow.price.v0.models.DeminimisSimple]
          case "deminimis_per_item" => js.validate[io.flow.price.v0.models.DeminimisPerItem]
          case other => play.api.libs.json.JsSuccess(io.flow.price.v0.models.DeminimisUndefinedType(other))
        }
      }
    }

    def jsObjectDeminimis(obj: io.flow.price.v0.models.Deminimis): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.price.v0.models.DeminimisSimple => jsObjectDeminimisSimple(x)
        case x: io.flow.price.v0.models.DeminimisPerItem => jsObjectDeminimisPerItem(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPriceDeminimis: play.api.libs.json.Writes[Deminimis] = {
      new play.api.libs.json.Writes[io.flow.price.v0.models.Deminimis] {
        def writes(obj: io.flow.price.v0.models.Deminimis) = {
          jsObjectDeminimis(obj)
        }
      }
    }
  }
}

package io.flow.price.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}

    // import models directly for backwards compatibility with prior versions of the generator
    import Core._
    import Models._

    object Core {
      implicit def pathBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.DateTime] = ApibuilderPathBindable(ApibuilderTypes.dateTimeIso8601)
      implicit def queryStringBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.DateTime] = ApibuilderQueryStringBindable(ApibuilderTypes.dateTimeIso8601)

      implicit def pathBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.LocalDate] = ApibuilderPathBindable(ApibuilderTypes.dateIso8601)
      implicit def queryStringBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.LocalDate] = ApibuilderQueryStringBindable(ApibuilderTypes.dateIso8601)
    }

    object Models {
      import io.flow.price.v0.models._

      val levyComponentConverter: ApibuilderTypeConverter[io.flow.price.v0.models.LevyComponent] = new ApibuilderTypeConverter[io.flow.price.v0.models.LevyComponent] {
        override def convert(value: String): io.flow.price.v0.models.LevyComponent = io.flow.price.v0.models.LevyComponent(value)
        override def convert(value: io.flow.price.v0.models.LevyComponent): String = value.toString
        override def example: io.flow.price.v0.models.LevyComponent = io.flow.price.v0.models.LevyComponent.Goods
        override def validValues: Seq[io.flow.price.v0.models.LevyComponent] = io.flow.price.v0.models.LevyComponent.all
      }
      implicit def pathBindableLevyComponent(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.price.v0.models.LevyComponent] = ApibuilderPathBindable(levyComponentConverter)
      implicit def queryStringBindableLevyComponent(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.price.v0.models.LevyComponent] = ApibuilderQueryStringBindable(levyComponentConverter)

      val levyStrategyConverter: ApibuilderTypeConverter[io.flow.price.v0.models.LevyStrategy] = new ApibuilderTypeConverter[io.flow.price.v0.models.LevyStrategy] {
        override def convert(value: String): io.flow.price.v0.models.LevyStrategy = io.flow.price.v0.models.LevyStrategy(value)
        override def convert(value: io.flow.price.v0.models.LevyStrategy): String = value.toString
        override def example: io.flow.price.v0.models.LevyStrategy = io.flow.price.v0.models.LevyStrategy.Minimum
        override def validValues: Seq[io.flow.price.v0.models.LevyStrategy] = io.flow.price.v0.models.LevyStrategy.all
      }
      implicit def pathBindableLevyStrategy(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.price.v0.models.LevyStrategy] = ApibuilderPathBindable(levyStrategyConverter)
      implicit def queryStringBindableLevyStrategy(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.price.v0.models.LevyStrategy] = ApibuilderQueryStringBindable(levyStrategyConverter)

      val priceAccuracyConverter: ApibuilderTypeConverter[io.flow.price.v0.models.PriceAccuracy] = new ApibuilderTypeConverter[io.flow.price.v0.models.PriceAccuracy] {
        override def convert(value: String): io.flow.price.v0.models.PriceAccuracy = io.flow.price.v0.models.PriceAccuracy(value)
        override def convert(value: io.flow.price.v0.models.PriceAccuracy): String = value.toString
        override def example: io.flow.price.v0.models.PriceAccuracy = io.flow.price.v0.models.PriceAccuracy.Calculated
        override def validValues: Seq[io.flow.price.v0.models.PriceAccuracy] = io.flow.price.v0.models.PriceAccuracy.all
      }
      implicit def pathBindablePriceAccuracy(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.price.v0.models.PriceAccuracy] = ApibuilderPathBindable(priceAccuracyConverter)
      implicit def queryStringBindablePriceAccuracy(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.price.v0.models.PriceAccuracy] = ApibuilderQueryStringBindable(priceAccuracyConverter)

      val priceDetailComponentKeyConverter: ApibuilderTypeConverter[io.flow.price.v0.models.PriceDetailComponentKey] = new ApibuilderTypeConverter[io.flow.price.v0.models.PriceDetailComponentKey] {
        override def convert(value: String): io.flow.price.v0.models.PriceDetailComponentKey = io.flow.price.v0.models.PriceDetailComponentKey(value)
        override def convert(value: io.flow.price.v0.models.PriceDetailComponentKey): String = value.toString
        override def example: io.flow.price.v0.models.PriceDetailComponentKey = io.flow.price.v0.models.PriceDetailComponentKey.BasePrice
        override def validValues: Seq[io.flow.price.v0.models.PriceDetailComponentKey] = io.flow.price.v0.models.PriceDetailComponentKey.all
      }
      implicit def pathBindablePriceDetailComponentKey(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.price.v0.models.PriceDetailComponentKey] = ApibuilderPathBindable(priceDetailComponentKeyConverter)
      implicit def queryStringBindablePriceDetailComponentKey(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.price.v0.models.PriceDetailComponentKey] = ApibuilderQueryStringBindable(priceDetailComponentKeyConverter)

      val priceDetailKeyConverter: ApibuilderTypeConverter[io.flow.price.v0.models.PriceDetailKey] = new ApibuilderTypeConverter[io.flow.price.v0.models.PriceDetailKey] {
        override def convert(value: String): io.flow.price.v0.models.PriceDetailKey = io.flow.price.v0.models.PriceDetailKey(value)
        override def convert(value: io.flow.price.v0.models.PriceDetailKey): String = value.toString
        override def example: io.flow.price.v0.models.PriceDetailKey = io.flow.price.v0.models.PriceDetailKey.ItemPrice
        override def validValues: Seq[io.flow.price.v0.models.PriceDetailKey] = io.flow.price.v0.models.PriceDetailKey.all
      }
      implicit def pathBindablePriceDetailKey(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.price.v0.models.PriceDetailKey] = ApibuilderPathBindable(priceDetailKeyConverter)
      implicit def queryStringBindablePriceDetailKey(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.price.v0.models.PriceDetailKey] = ApibuilderQueryStringBindable(priceDetailKeyConverter)

      val pricingLevySettingConverter: ApibuilderTypeConverter[io.flow.price.v0.models.PricingLevySetting] = new ApibuilderTypeConverter[io.flow.price.v0.models.PricingLevySetting] {
        override def convert(value: String): io.flow.price.v0.models.PricingLevySetting = io.flow.price.v0.models.PricingLevySetting(value)
        override def convert(value: io.flow.price.v0.models.PricingLevySetting): String = value.toString
        override def example: io.flow.price.v0.models.PricingLevySetting = io.flow.price.v0.models.PricingLevySetting.Included
        override def validValues: Seq[io.flow.price.v0.models.PricingLevySetting] = io.flow.price.v0.models.PricingLevySetting.all
      }
      implicit def pathBindablePricingLevySetting(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.price.v0.models.PricingLevySetting] = ApibuilderPathBindable(pricingLevySettingConverter)
      implicit def queryStringBindablePricingLevySetting(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.price.v0.models.PricingLevySetting] = ApibuilderQueryStringBindable(pricingLevySettingConverter)
    }

    trait ApibuilderTypeConverter[T] {

      def convert(value: String): T

      def convert(value: T): String

      def example: T

      def validValues: Seq[T] = Nil

      def errorMessage(key: String, value: String, ex: java.lang.Exception): String = {
        val base = s"Invalid value '$value' for parameter '$key'. "
        validValues.toList match {
          case Nil => base + "Ex: " + convert(example)
          case values => base + ". Valid values are: " + values.mkString("'", "', '", "'")
        }
      }
    }

    object ApibuilderTypes {
      val dateTimeIso8601: ApibuilderTypeConverter[_root_.org.joda.time.DateTime] = new ApibuilderTypeConverter[_root_.org.joda.time.DateTime] {
        override def convert(value: String): _root_.org.joda.time.DateTime = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(value)
        override def convert(value: _root_.org.joda.time.DateTime): String = _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(value)
        override def example: _root_.org.joda.time.DateTime = _root_.org.joda.time.DateTime.now
      }

      val dateIso8601: ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] = new ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] {
        override def convert(value: String): _root_.org.joda.time.LocalDate = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(value)
        override def convert(value: _root_.org.joda.time.LocalDate): String = _root_.org.joda.time.format.ISODateTimeFormat.date.print(value)
        override def example: _root_.org.joda.time.LocalDate = _root_.org.joda.time.LocalDate.now
      }
    }

    final case class ApibuilderQueryStringBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends QueryStringBindable[T] {

      override def bind(key: String, params: Map[String, Seq[String]]): _root_.scala.Option[_root_.scala.Either[String, T]] = {
        params.getOrElse(key, Nil).headOption.map { v =>
          try {
            Right(
              converters.convert(v)
            )
          } catch {
            case ex: java.lang.Exception => Left(
              converters.errorMessage(key, v, ex)
            )
          }
        }
      }

      override def unbind(key: String, value: T): String = {
        s"$key=${converters.convert(value)}"
      }
    }

    final case class ApibuilderPathBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends PathBindable[T] {

      override def bind(key: String, value: String): _root_.scala.Either[String, T] = {
        try {
          Right(
            converters.convert(value)
          )
        } catch {
          case ex: java.lang.Exception => Left(
            converters.errorMessage(key, value, ex)
          )
        }
      }

      override def unbind(key: String, value: T): String = {
        converters.convert(value)
      }
    }

  }

}
