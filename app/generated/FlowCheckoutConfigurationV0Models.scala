/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.13.57
 * apibuilder 0.15.33 app.apibuilder.io/flow/checkout-configuration/latest/play_2_x_json
 */
package io.flow.checkout.configuration.v0.models {

  /**
   * Differentiated by the type of tracker integration
   */
  sealed trait Tracker extends _root_.scala.Product with _root_.scala.Serializable {
    def trackerDiscriminator: TrackerDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type Tracker
   */
  sealed trait TrackerDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object TrackerDiscriminator {

    case object GoogleAnalytics extends TrackerDiscriminator { override def toString = "google_analytics" }
    case object GoogleGlobalSiteTag extends TrackerDiscriminator { override def toString = "google_global_site_tag" }
    case object GoogleTagManager extends TrackerDiscriminator { override def toString = "google_tag_manager" }
    case object FacebookPixel extends TrackerDiscriminator { override def toString = "facebook_pixel" }
    case object SnapchatPixel extends TrackerDiscriminator { override def toString = "snapchat_pixel" }

    final case class UNDEFINED(override val toString: String) extends TrackerDiscriminator

    val all: scala.List[TrackerDiscriminator] = scala.List(GoogleAnalytics, GoogleGlobalSiteTag, GoogleTagManager, FacebookPixel, SnapchatPixel)

    private[this] val byName: Map[String, TrackerDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TrackerDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TrackerDiscriminator] = byName.get(value.toLowerCase)

  }
  /**
   * Information about the analytics configurations and integrations for this
   * checkout session
   *
   * @param useBaseCurrency Whether or not to submit amounts in the base currency or the local currency
   *        https://github.com/flowcommerce/browser-javascript/tree/1e408d20d7b6123205db60b4ade068affdffb4d1/packages/pixel#usebasecurrency-boolean
   */

  final case class CheckoutAnalytics(
    trackers: Seq[io.flow.checkout.configuration.v0.models.Tracker],
    useBaseCurrency: Boolean
  )

  final case class CheckoutAsset(
    url: String,
    `type`: io.flow.checkout.configuration.v0.models.CheckoutAssetType
  )

  final case class CheckoutBehavior(
    shippingAddress: io.flow.checkout.configuration.v0.models.CheckoutBehaviorShippingAddress,
    shippingMethod: io.flow.checkout.configuration.v0.models.CheckoutBehaviorShippingMethod,
    customerInfo: io.flow.checkout.configuration.v0.models.CheckoutBehaviorCustomerInfo
  )

  final case class CheckoutBehaviorCustomerInfo(
    email: io.flow.checkout.configuration.v0.models.CheckoutBehaviorCustomerInfoEmail
  )

  final case class CheckoutBehaviorCustomerInfoEmail(
    prompt: io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior = io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior.Incomplete
  )

  final case class CheckoutBehaviorShippingAddress(
    prompt: io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior
  )

  final case class CheckoutBehaviorShippingMethod(
    prompt: io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior
  )

  /**
   * @param domain The merchant's host domain for the checkout session
   */

  final case class CheckoutConfiguration(
    id: String,
    behavior: io.flow.checkout.configuration.v0.models.CheckoutBehavior,
    settings: io.flow.checkout.configuration.v0.models.CheckoutSettings,
    analytics: _root_.scala.Option[io.flow.checkout.configuration.v0.models.CheckoutAnalytics] = None,
    domain: _root_.scala.Option[String] = None
  )

  /**
   * @param domain The merchant's host domain for the checkout session
   */

  final case class CheckoutConfigurationForm(
    behavior: io.flow.checkout.configuration.v0.models.CheckoutBehavior,
    settings: io.flow.checkout.configuration.v0.models.CheckoutSettings,
    analytics: _root_.scala.Option[io.flow.checkout.configuration.v0.models.CheckoutAnalytics] = None,
    domain: _root_.scala.Option[String] = None
  )

  final case class CheckoutConfigurationReference(
    id: String
  )

  /**
   * @param sessionPersistenceTimeout The session persistence timeout controls how long we persist data in checkout
   *        (e.g. shipping address) as users navigate between cart and checkout. If set to 1
   *        week, for example, then when a user starts a new checkout session, we will
   *        default their order to the last checkout they had in their session, pre
   *        populating data like the shipping address.
   * @param sessionPersistenceAttributeKeys If specified, we require an opt in with the provided attribute key in order to
   *        enable session persistence
   * @param locales Supported locales. Which are used to determine which languages are offered in
   *        checkout. Defined in https://api.flow.io/reference/locales
   * @param urls Urls used in Checkout UI
   * @param assets Assets used in Checkout UI
   */

  final case class CheckoutSettings(
    sessionPersistenceTimeout: _root_.scala.Option[io.flow.common.v0.models.Duration] = None,
    sessionPersistenceAttributeKeys: _root_.scala.Option[Seq[String]] = None,
    locales: _root_.scala.Option[Seq[String]] = None,
    urls: _root_.scala.Option[Seq[io.flow.checkout.configuration.v0.models.CheckoutUrl]] = None,
    assets: _root_.scala.Option[Seq[io.flow.checkout.configuration.v0.models.CheckoutAsset]] = None
  )

  final case class CheckoutUrl(
    url: String,
    `type`: io.flow.checkout.configuration.v0.models.CheckoutUrlType
  )

  /**
   * Integration details for facebook pixel integrations
   * https://developers.facebook.com/docs/facebook-pixel
   *
   * @param name Descriptive name of the tracker
   * @param trackerId Unique identifier of the pixel
   */

  final case class FacebookPixel(
    name: _root_.scala.Option[String] = None,
    trackerId: String
  ) extends Tracker {
    override val trackerDiscriminator: TrackerDiscriminator = TrackerDiscriminator.FacebookPixel
  }

  /**
   * Integration details for google analytics integrations
   * https://developers.google.com/analytics/devguides/collection/analyticsjs
   *
   * @param name Descriptive name of the tracker
   * @param trackerId Unique identifier of the google measurement account
   *        https://support.google.com/analytics/answer/9310895?hl=en
   */

  final case class GoogleAnalytics(
    name: _root_.scala.Option[String] = None,
    trackerId: String,
    plugins: Seq[io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin],
    linker: _root_.scala.Option[io.flow.checkout.configuration.v0.models.GoogleLinker] = None
  ) extends Tracker {
    override val trackerDiscriminator: TrackerDiscriminator = TrackerDiscriminator.GoogleAnalytics
  }

  /**
   * Integration details for google analytics integrations done using gtag
   * https://developers.google.com/analytics/devguides/collection/gtagjs
   *
   * @param name Descriptive name of the tracker
   * @param trackerId Unique identifier of the google measurement account
   *        https://support.google.com/analytics/answer/9310895?hl=en
   */

  final case class GoogleGlobalSiteTag(
    name: _root_.scala.Option[String] = None,
    trackerId: String,
    linker: _root_.scala.Option[io.flow.checkout.configuration.v0.models.GoogleLinker] = None
  ) extends Tracker {
    override val trackerDiscriminator: TrackerDiscriminator = TrackerDiscriminator.GoogleGlobalSiteTag
  }

  /**
   * https://developers.google.com/analytics/devguides/collection/analyticsjs/linker
   */

  final case class GoogleLinker(
    domains: Seq[String]
  )

  /**
   * Configuration for Google Tag Manager integrations
   *
   * @param trackerId Unique identifier for the Google Tag Manager container identifier
   */

  final case class GoogleTagManager(
    trackerId: String
  ) extends Tracker {
    override val trackerDiscriminator: TrackerDiscriminator = TrackerDiscriminator.GoogleTagManager
  }

  /**
   * Integration details for snapchat pixel integrations
   * https://businesshelp.snapchat.com/en-US/article/snap-pixel-about
   *
   * @param name Descriptive name of the tracker
   * @param trackerId Unique identifier of the pixel
   */

  final case class SnapchatPixel(
    name: _root_.scala.Option[String] = None,
    trackerId: String
  ) extends Tracker {
    override val trackerDiscriminator: TrackerDiscriminator = TrackerDiscriminator.SnapchatPixel
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union Tracker, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class TrackerUndefinedType(
    description: String
  ) extends Tracker {
    override val trackerDiscriminator: TrackerDiscriminator = TrackerDiscriminator.UNDEFINED(description)
  }
  sealed trait CheckoutAssetType extends _root_.scala.Product with _root_.scala.Serializable

  object CheckoutAssetType {

    case object Stylesheet extends CheckoutAssetType { override def toString = "stylesheet" }
    case object Javascript extends CheckoutAssetType { override def toString = "javascript" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CheckoutAssetType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CheckoutAssetType] = scala.List(Stylesheet, Javascript)

    private[this]
    val byName: Map[String, CheckoutAssetType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CheckoutAssetType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CheckoutAssetType] = byName.get(value.toLowerCase)

  }

  /**
   * The checkout prompt behavior specifies when or if a user should by prompted to
   * provided certain information. For example, if the shipping info prompt is
   * 'incomplete', this means that as a user enters Checkout, we will present the
   * form to specify a shipping address only if we do not have a complete shipping
   * address. If the shipping address was already present (e.g. for a repeat
   * customer), this step of Checkout can be skipped.
   */
  sealed trait CheckoutPromptBehavior extends _root_.scala.Product with _root_.scala.Serializable

  object CheckoutPromptBehavior {

    case object Always extends CheckoutPromptBehavior { override def toString = "always" }
    /**
     * Only prompt if the order does not have a complete shipping address field present
     */
    case object Incomplete extends CheckoutPromptBehavior {
      override def toString = "incomplete"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CheckoutPromptBehavior

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CheckoutPromptBehavior] = scala.List(Always, Incomplete)

    private[this]
    val byName: Map[String, CheckoutPromptBehavior] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CheckoutPromptBehavior = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CheckoutPromptBehavior] = byName.get(value.toLowerCase)

  }

  /**
   * Controls when we display the 'choose your shipping method' step of checkout
   */
  sealed trait CheckoutShippingMethodPromptBehavior extends _root_.scala.Product with _root_.scala.Serializable

  object CheckoutShippingMethodPromptBehavior {

    case object Always extends CheckoutShippingMethodPromptBehavior { override def toString = "always" }
    /**
     * Prompt the user to select a shipping method only if there are more than 1
     * shipping method options available for this order
     */
    case object Multiple extends CheckoutShippingMethodPromptBehavior {
      override def toString = "multiple"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CheckoutShippingMethodPromptBehavior

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CheckoutShippingMethodPromptBehavior] = scala.List(Always, Multiple)

    private[this]
    val byName: Map[String, CheckoutShippingMethodPromptBehavior] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CheckoutShippingMethodPromptBehavior = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CheckoutShippingMethodPromptBehavior] = byName.get(value.toLowerCase)

  }

  sealed trait CheckoutUrlType extends _root_.scala.Product with _root_.scala.Serializable

  object CheckoutUrlType {

    case object ContinueShopping extends CheckoutUrlType { override def toString = "continue_shopping" }
    case object Confirmation extends CheckoutUrlType { override def toString = "confirmation" }
    case object InvalidCheckout extends CheckoutUrlType { override def toString = "invalid_checkout" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CheckoutUrlType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CheckoutUrlType] = scala.List(ContinueShopping, Confirmation, InvalidCheckout)

    private[this]
    val byName: Map[String, CheckoutUrlType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CheckoutUrlType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CheckoutUrlType] = byName.get(value.toLowerCase)

  }

  /**
   * Google analytics plugins that need to be instantiated
   * https://developers.google.com/analytics/devguides/collection/analyticsjs/using-plugins
   */
  sealed trait GoogleAnalyticsPlugin extends _root_.scala.Product with _root_.scala.Serializable

  object GoogleAnalyticsPlugin {

    /**
     * Enhanced Ecommerce
     * https://developers.google.com/analytics/devguides/collection/analyticsjs/enhanced-ecommerce
     */
    case object Ec extends GoogleAnalyticsPlugin {
      override def toString = "ec"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends GoogleAnalyticsPlugin

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[GoogleAnalyticsPlugin] = scala.List(Ec)

    private[this]
    val byName: Map[String, GoogleAnalyticsPlugin] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): GoogleAnalyticsPlugin = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[GoogleAnalyticsPlugin] = byName.get(value.toLowerCase)

  }

}

package io.flow.checkout.configuration.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.checkout.configuration.v0.models.json._
    import io.flow.common.v0.models.json._
    import io.flow.error.v0.models.json._
    import io.flow.permission.v0.models.json._

    private[v0] implicit val jsonReadsUUID: play.api.libs.json.Reads[_root_.java.util.UUID] = __.read[String].map { str =>
      _root_.java.util.UUID.fromString(str)
    }

    private[v0] implicit val jsonWritesUUID: play.api.libs.json.Writes[_root_.java.util.UUID] = (x: _root_.java.util.UUID) => play.api.libs.json.JsString(x.toString)

    private[v0] implicit val jsonReadsJodaDateTime: play.api.libs.json.Reads[_root_.org.joda.time.DateTime] = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime: play.api.libs.json.Writes[_root_.org.joda.time.DateTime] = (x: _root_.org.joda.time.DateTime) => {
      play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x))
    }

    private[v0] implicit val jsonReadsJodaLocalDate: play.api.libs.json.Reads[_root_.org.joda.time.LocalDate] = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(str)
    }

    private[v0] implicit val jsonWritesJodaLocalDate: play.api.libs.json.Writes[_root_.org.joda.time.LocalDate] = (x: _root_.org.joda.time.LocalDate) => {
      play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.date.print(x))
    }

    implicit val jsonReadsCheckoutConfigurationCheckoutAssetType: play.api.libs.json.Reads[io.flow.checkout.configuration.v0.models.CheckoutAssetType] = new play.api.libs.json.Reads[io.flow.checkout.configuration.v0.models.CheckoutAssetType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.checkout.configuration.v0.models.CheckoutAssetType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.checkout.configuration.v0.models.CheckoutAssetType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.checkout.configuration.v0.models.CheckoutAssetType(v))
              case err: play.api.libs.json.JsError =>
                (js \ "checkout_asset_type").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.checkout.configuration.v0.models.CheckoutAssetType(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesCheckoutConfigurationCheckoutAssetType(obj: io.flow.checkout.configuration.v0.models.CheckoutAssetType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCheckoutAssetType(obj: io.flow.checkout.configuration.v0.models.CheckoutAssetType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCheckoutConfigurationCheckoutAssetType: play.api.libs.json.Writes[CheckoutAssetType] = {
      (obj: io.flow.checkout.configuration.v0.models.CheckoutAssetType) => {
        jsonWritesCheckoutConfigurationCheckoutAssetType(obj)
      }
    }

    implicit val jsonReadsCheckoutConfigurationCheckoutPromptBehavior: play.api.libs.json.Reads[io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior] = new play.api.libs.json.Reads[io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior(v))
              case err: play.api.libs.json.JsError =>
                (js \ "checkout_prompt_behavior").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesCheckoutConfigurationCheckoutPromptBehavior(obj: io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCheckoutPromptBehavior(obj: io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCheckoutConfigurationCheckoutPromptBehavior: play.api.libs.json.Writes[CheckoutPromptBehavior] = {
      (obj: io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior) => {
        jsonWritesCheckoutConfigurationCheckoutPromptBehavior(obj)
      }
    }

    implicit val jsonReadsCheckoutConfigurationCheckoutShippingMethodPromptBehavior: play.api.libs.json.Reads[io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior] = new play.api.libs.json.Reads[io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior(v))
              case err: play.api.libs.json.JsError =>
                (js \ "checkout_shipping_method_prompt_behavior").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesCheckoutConfigurationCheckoutShippingMethodPromptBehavior(obj: io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCheckoutShippingMethodPromptBehavior(obj: io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCheckoutConfigurationCheckoutShippingMethodPromptBehavior: play.api.libs.json.Writes[CheckoutShippingMethodPromptBehavior] = {
      (obj: io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior) => {
        jsonWritesCheckoutConfigurationCheckoutShippingMethodPromptBehavior(obj)
      }
    }

    implicit val jsonReadsCheckoutConfigurationCheckoutUrlType: play.api.libs.json.Reads[io.flow.checkout.configuration.v0.models.CheckoutUrlType] = new play.api.libs.json.Reads[io.flow.checkout.configuration.v0.models.CheckoutUrlType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.checkout.configuration.v0.models.CheckoutUrlType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.checkout.configuration.v0.models.CheckoutUrlType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.checkout.configuration.v0.models.CheckoutUrlType(v))
              case err: play.api.libs.json.JsError =>
                (js \ "checkout_url_type").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.checkout.configuration.v0.models.CheckoutUrlType(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesCheckoutConfigurationCheckoutUrlType(obj: io.flow.checkout.configuration.v0.models.CheckoutUrlType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCheckoutUrlType(obj: io.flow.checkout.configuration.v0.models.CheckoutUrlType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCheckoutConfigurationCheckoutUrlType: play.api.libs.json.Writes[CheckoutUrlType] = {
      (obj: io.flow.checkout.configuration.v0.models.CheckoutUrlType) => {
        jsonWritesCheckoutConfigurationCheckoutUrlType(obj)
      }
    }

    implicit val jsonReadsCheckoutConfigurationGoogleAnalyticsPlugin: play.api.libs.json.Reads[io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin] = new play.api.libs.json.Reads[io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin(v))
              case err: play.api.libs.json.JsError =>
                (js \ "google_analytics_plugin").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesCheckoutConfigurationGoogleAnalyticsPlugin(obj: io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectGoogleAnalyticsPlugin(obj: io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesCheckoutConfigurationGoogleAnalyticsPlugin: play.api.libs.json.Writes[GoogleAnalyticsPlugin] = {
      (obj: io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin) => {
        jsonWritesCheckoutConfigurationGoogleAnalyticsPlugin(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationCheckoutAnalytics: play.api.libs.json.Reads[CheckoutAnalytics] = {
      for {
        trackers <- (__ \ "trackers").read[Seq[io.flow.checkout.configuration.v0.models.Tracker]]
        useBaseCurrency <- (__ \ "use_base_currency").read[Boolean]
      } yield CheckoutAnalytics(trackers, useBaseCurrency)
    }

    def jsObjectCheckoutAnalytics(obj: io.flow.checkout.configuration.v0.models.CheckoutAnalytics): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "trackers" -> play.api.libs.json.Json.toJson(obj.trackers),
        "use_base_currency" -> play.api.libs.json.JsBoolean(obj.useBaseCurrency)
      )
    }

    implicit def jsonWritesCheckoutConfigurationCheckoutAnalytics: play.api.libs.json.Writes[CheckoutAnalytics] = {
      (obj: io.flow.checkout.configuration.v0.models.CheckoutAnalytics) => {
        jsObjectCheckoutAnalytics(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationCheckoutAsset: play.api.libs.json.Reads[CheckoutAsset] = {
      for {
        url <- (__ \ "url").read[String]
        `type` <- (__ \ "type").read[io.flow.checkout.configuration.v0.models.CheckoutAssetType]
      } yield CheckoutAsset(url, `type`)
    }

    def jsObjectCheckoutAsset(obj: io.flow.checkout.configuration.v0.models.CheckoutAsset): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "url" -> play.api.libs.json.JsString(obj.url),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      )
    }

    implicit def jsonWritesCheckoutConfigurationCheckoutAsset: play.api.libs.json.Writes[CheckoutAsset] = {
      (obj: io.flow.checkout.configuration.v0.models.CheckoutAsset) => {
        jsObjectCheckoutAsset(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationCheckoutBehavior: play.api.libs.json.Reads[CheckoutBehavior] = {
      for {
        shippingAddress <- (__ \ "shipping_address").read[io.flow.checkout.configuration.v0.models.CheckoutBehaviorShippingAddress]
        shippingMethod <- (__ \ "shipping_method").read[io.flow.checkout.configuration.v0.models.CheckoutBehaviorShippingMethod]
        customerInfo <- (__ \ "customer_info").read[io.flow.checkout.configuration.v0.models.CheckoutBehaviorCustomerInfo]
      } yield CheckoutBehavior(shippingAddress, shippingMethod, customerInfo)
    }

    def jsObjectCheckoutBehavior(obj: io.flow.checkout.configuration.v0.models.CheckoutBehavior): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "shipping_address" -> jsObjectCheckoutBehaviorShippingAddress(obj.shippingAddress),
        "shipping_method" -> jsObjectCheckoutBehaviorShippingMethod(obj.shippingMethod),
        "customer_info" -> jsObjectCheckoutBehaviorCustomerInfo(obj.customerInfo)
      )
    }

    implicit def jsonWritesCheckoutConfigurationCheckoutBehavior: play.api.libs.json.Writes[CheckoutBehavior] = {
      (obj: io.flow.checkout.configuration.v0.models.CheckoutBehavior) => {
        jsObjectCheckoutBehavior(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationCheckoutBehaviorCustomerInfo: play.api.libs.json.Reads[CheckoutBehaviorCustomerInfo] = {
      (__ \ "email").read[io.flow.checkout.configuration.v0.models.CheckoutBehaviorCustomerInfoEmail].map { x => new CheckoutBehaviorCustomerInfo(email = x) }
    }

    def jsObjectCheckoutBehaviorCustomerInfo(obj: io.flow.checkout.configuration.v0.models.CheckoutBehaviorCustomerInfo): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "email" -> jsObjectCheckoutBehaviorCustomerInfoEmail(obj.email)
      )
    }

    implicit def jsonWritesCheckoutConfigurationCheckoutBehaviorCustomerInfo: play.api.libs.json.Writes[CheckoutBehaviorCustomerInfo] = {
      (obj: io.flow.checkout.configuration.v0.models.CheckoutBehaviorCustomerInfo) => {
        jsObjectCheckoutBehaviorCustomerInfo(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationCheckoutBehaviorCustomerInfoEmail: play.api.libs.json.Reads[CheckoutBehaviorCustomerInfoEmail] = {
      (__ \ "prompt").read[io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior].map { x => new CheckoutBehaviorCustomerInfoEmail(prompt = x) }
    }

    def jsObjectCheckoutBehaviorCustomerInfoEmail(obj: io.flow.checkout.configuration.v0.models.CheckoutBehaviorCustomerInfoEmail): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "prompt" -> play.api.libs.json.JsString(obj.prompt.toString)
      )
    }

    implicit def jsonWritesCheckoutConfigurationCheckoutBehaviorCustomerInfoEmail: play.api.libs.json.Writes[CheckoutBehaviorCustomerInfoEmail] = {
      (obj: io.flow.checkout.configuration.v0.models.CheckoutBehaviorCustomerInfoEmail) => {
        jsObjectCheckoutBehaviorCustomerInfoEmail(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationCheckoutBehaviorShippingAddress: play.api.libs.json.Reads[CheckoutBehaviorShippingAddress] = {
      (__ \ "prompt").read[io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior].map { x => new CheckoutBehaviorShippingAddress(prompt = x) }
    }

    def jsObjectCheckoutBehaviorShippingAddress(obj: io.flow.checkout.configuration.v0.models.CheckoutBehaviorShippingAddress): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "prompt" -> play.api.libs.json.JsString(obj.prompt.toString)
      )
    }

    implicit def jsonWritesCheckoutConfigurationCheckoutBehaviorShippingAddress: play.api.libs.json.Writes[CheckoutBehaviorShippingAddress] = {
      (obj: io.flow.checkout.configuration.v0.models.CheckoutBehaviorShippingAddress) => {
        jsObjectCheckoutBehaviorShippingAddress(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationCheckoutBehaviorShippingMethod: play.api.libs.json.Reads[CheckoutBehaviorShippingMethod] = {
      (__ \ "prompt").read[io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior].map { x => new CheckoutBehaviorShippingMethod(prompt = x) }
    }

    def jsObjectCheckoutBehaviorShippingMethod(obj: io.flow.checkout.configuration.v0.models.CheckoutBehaviorShippingMethod): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "prompt" -> play.api.libs.json.JsString(obj.prompt.toString)
      )
    }

    implicit def jsonWritesCheckoutConfigurationCheckoutBehaviorShippingMethod: play.api.libs.json.Writes[CheckoutBehaviorShippingMethod] = {
      (obj: io.flow.checkout.configuration.v0.models.CheckoutBehaviorShippingMethod) => {
        jsObjectCheckoutBehaviorShippingMethod(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationCheckoutConfiguration: play.api.libs.json.Reads[CheckoutConfiguration] = {
      for {
        id <- (__ \ "id").read[String]
        behavior <- (__ \ "behavior").read[io.flow.checkout.configuration.v0.models.CheckoutBehavior]
        settings <- (__ \ "settings").read[io.flow.checkout.configuration.v0.models.CheckoutSettings]
        analytics <- (__ \ "analytics").readNullable[io.flow.checkout.configuration.v0.models.CheckoutAnalytics]
        domain <- (__ \ "domain").readNullable[String]
      } yield CheckoutConfiguration(id, behavior, settings, analytics, domain)
    }

    def jsObjectCheckoutConfiguration(obj: io.flow.checkout.configuration.v0.models.CheckoutConfiguration): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "behavior" -> jsObjectCheckoutBehavior(obj.behavior),
        "settings" -> jsObjectCheckoutSettings(obj.settings)
      ) ++ (obj.analytics match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("analytics" -> jsObjectCheckoutAnalytics(x))
      }) ++
      (obj.domain match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("domain" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesCheckoutConfigurationCheckoutConfiguration: play.api.libs.json.Writes[CheckoutConfiguration] = {
      (obj: io.flow.checkout.configuration.v0.models.CheckoutConfiguration) => {
        jsObjectCheckoutConfiguration(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationCheckoutConfigurationForm: play.api.libs.json.Reads[CheckoutConfigurationForm] = {
      for {
        behavior <- (__ \ "behavior").read[io.flow.checkout.configuration.v0.models.CheckoutBehavior]
        settings <- (__ \ "settings").read[io.flow.checkout.configuration.v0.models.CheckoutSettings]
        analytics <- (__ \ "analytics").readNullable[io.flow.checkout.configuration.v0.models.CheckoutAnalytics]
        domain <- (__ \ "domain").readNullable[String]
      } yield CheckoutConfigurationForm(behavior, settings, analytics, domain)
    }

    def jsObjectCheckoutConfigurationForm(obj: io.flow.checkout.configuration.v0.models.CheckoutConfigurationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "behavior" -> jsObjectCheckoutBehavior(obj.behavior),
        "settings" -> jsObjectCheckoutSettings(obj.settings)
      ) ++ (obj.analytics match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("analytics" -> jsObjectCheckoutAnalytics(x))
      }) ++
      (obj.domain match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("domain" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesCheckoutConfigurationCheckoutConfigurationForm: play.api.libs.json.Writes[CheckoutConfigurationForm] = {
      (obj: io.flow.checkout.configuration.v0.models.CheckoutConfigurationForm) => {
        jsObjectCheckoutConfigurationForm(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationCheckoutConfigurationReference: play.api.libs.json.Reads[CheckoutConfigurationReference] = {
      (__ \ "id").read[String].map { x => new CheckoutConfigurationReference(id = x) }
    }

    def jsObjectCheckoutConfigurationReference(obj: io.flow.checkout.configuration.v0.models.CheckoutConfigurationReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesCheckoutConfigurationCheckoutConfigurationReference: play.api.libs.json.Writes[CheckoutConfigurationReference] = {
      (obj: io.flow.checkout.configuration.v0.models.CheckoutConfigurationReference) => {
        jsObjectCheckoutConfigurationReference(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationCheckoutSettings: play.api.libs.json.Reads[CheckoutSettings] = {
      for {
        sessionPersistenceTimeout <- (__ \ "session_persistence_timeout").readNullable[io.flow.common.v0.models.Duration]
        sessionPersistenceAttributeKeys <- (__ \ "session_persistence_attribute_keys").readNullable[Seq[String]]
        locales <- (__ \ "locales").readNullable[Seq[String]]
        urls <- (__ \ "urls").readNullable[Seq[io.flow.checkout.configuration.v0.models.CheckoutUrl]]
        assets <- (__ \ "assets").readNullable[Seq[io.flow.checkout.configuration.v0.models.CheckoutAsset]]
      } yield CheckoutSettings(sessionPersistenceTimeout, sessionPersistenceAttributeKeys, locales, urls, assets)
    }

    def jsObjectCheckoutSettings(obj: io.flow.checkout.configuration.v0.models.CheckoutSettings): play.api.libs.json.JsObject = {
      (obj.sessionPersistenceTimeout match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("session_persistence_timeout" -> io.flow.common.v0.models.json.jsObjectDuration(x))
      }) ++
      (obj.sessionPersistenceAttributeKeys match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("session_persistence_attribute_keys" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.locales match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("locales" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.urls match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("urls" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.assets match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("assets" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesCheckoutConfigurationCheckoutSettings: play.api.libs.json.Writes[CheckoutSettings] = {
      (obj: io.flow.checkout.configuration.v0.models.CheckoutSettings) => {
        jsObjectCheckoutSettings(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationCheckoutUrl: play.api.libs.json.Reads[CheckoutUrl] = {
      for {
        url <- (__ \ "url").read[String]
        `type` <- (__ \ "type").read[io.flow.checkout.configuration.v0.models.CheckoutUrlType]
      } yield CheckoutUrl(url, `type`)
    }

    def jsObjectCheckoutUrl(obj: io.flow.checkout.configuration.v0.models.CheckoutUrl): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "url" -> play.api.libs.json.JsString(obj.url),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      )
    }

    implicit def jsonWritesCheckoutConfigurationCheckoutUrl: play.api.libs.json.Writes[CheckoutUrl] = {
      (obj: io.flow.checkout.configuration.v0.models.CheckoutUrl) => {
        jsObjectCheckoutUrl(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationFacebookPixel: play.api.libs.json.Reads[FacebookPixel] = {
      for {
        name <- (__ \ "name").readNullable[String]
        trackerId <- (__ \ "tracker_id").read[String]
      } yield FacebookPixel(name, trackerId)
    }

    def jsObjectFacebookPixel(obj: io.flow.checkout.configuration.v0.models.FacebookPixel): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "tracker_id" -> play.api.libs.json.JsString(obj.trackerId)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "facebook_pixel")
    }

    implicit def jsonWritesCheckoutConfigurationFacebookPixel: play.api.libs.json.Writes[FacebookPixel] = {
      (obj: io.flow.checkout.configuration.v0.models.FacebookPixel) => {
        jsObjectFacebookPixel(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationGoogleAnalytics: play.api.libs.json.Reads[GoogleAnalytics] = {
      for {
        name <- (__ \ "name").readNullable[String]
        trackerId <- (__ \ "tracker_id").read[String]
        plugins <- (__ \ "plugins").read[Seq[io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin]]
        linker <- (__ \ "linker").readNullable[io.flow.checkout.configuration.v0.models.GoogleLinker]
      } yield GoogleAnalytics(name, trackerId, plugins, linker)
    }

    def jsObjectGoogleAnalytics(obj: io.flow.checkout.configuration.v0.models.GoogleAnalytics): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "tracker_id" -> play.api.libs.json.JsString(obj.trackerId),
        "plugins" -> play.api.libs.json.Json.toJson(obj.plugins)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.linker match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("linker" -> jsObjectGoogleLinker(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "google_analytics")
    }

    implicit def jsonWritesCheckoutConfigurationGoogleAnalytics: play.api.libs.json.Writes[GoogleAnalytics] = {
      (obj: io.flow.checkout.configuration.v0.models.GoogleAnalytics) => {
        jsObjectGoogleAnalytics(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationGoogleGlobalSiteTag: play.api.libs.json.Reads[GoogleGlobalSiteTag] = {
      for {
        name <- (__ \ "name").readNullable[String]
        trackerId <- (__ \ "tracker_id").read[String]
        linker <- (__ \ "linker").readNullable[io.flow.checkout.configuration.v0.models.GoogleLinker]
      } yield GoogleGlobalSiteTag(name, trackerId, linker)
    }

    def jsObjectGoogleGlobalSiteTag(obj: io.flow.checkout.configuration.v0.models.GoogleGlobalSiteTag): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "tracker_id" -> play.api.libs.json.JsString(obj.trackerId)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.linker match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("linker" -> jsObjectGoogleLinker(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "google_global_site_tag")
    }

    implicit def jsonWritesCheckoutConfigurationGoogleGlobalSiteTag: play.api.libs.json.Writes[GoogleGlobalSiteTag] = {
      (obj: io.flow.checkout.configuration.v0.models.GoogleGlobalSiteTag) => {
        jsObjectGoogleGlobalSiteTag(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationGoogleLinker: play.api.libs.json.Reads[GoogleLinker] = {
      (__ \ "domains").read[Seq[String]].map { x => new GoogleLinker(domains = x) }
    }

    def jsObjectGoogleLinker(obj: io.flow.checkout.configuration.v0.models.GoogleLinker): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "domains" -> play.api.libs.json.Json.toJson(obj.domains)
      )
    }

    implicit def jsonWritesCheckoutConfigurationGoogleLinker: play.api.libs.json.Writes[GoogleLinker] = {
      (obj: io.flow.checkout.configuration.v0.models.GoogleLinker) => {
        jsObjectGoogleLinker(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationGoogleTagManager: play.api.libs.json.Reads[GoogleTagManager] = {
      (__ \ "tracker_id").read[String].map { x => new GoogleTagManager(trackerId = x) }
    }

    def jsObjectGoogleTagManager(obj: io.flow.checkout.configuration.v0.models.GoogleTagManager): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "tracker_id" -> play.api.libs.json.JsString(obj.trackerId)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "google_tag_manager")
    }

    implicit def jsonWritesCheckoutConfigurationGoogleTagManager: play.api.libs.json.Writes[GoogleTagManager] = {
      (obj: io.flow.checkout.configuration.v0.models.GoogleTagManager) => {
        jsObjectGoogleTagManager(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationSnapchatPixel: play.api.libs.json.Reads[SnapchatPixel] = {
      for {
        name <- (__ \ "name").readNullable[String]
        trackerId <- (__ \ "tracker_id").read[String]
      } yield SnapchatPixel(name, trackerId)
    }

    def jsObjectSnapchatPixel(obj: io.flow.checkout.configuration.v0.models.SnapchatPixel): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "tracker_id" -> play.api.libs.json.JsString(obj.trackerId)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "snapchat_pixel")
    }

    implicit def jsonWritesCheckoutConfigurationSnapchatPixel: play.api.libs.json.Writes[SnapchatPixel] = {
      (obj: io.flow.checkout.configuration.v0.models.SnapchatPixel) => {
        jsObjectSnapchatPixel(obj)
      }
    }

    implicit def jsonReadsCheckoutConfigurationTracker: play.api.libs.json.Reads[Tracker] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "google_analytics" => js.validate[io.flow.checkout.configuration.v0.models.GoogleAnalytics]
          case "google_global_site_tag" => js.validate[io.flow.checkout.configuration.v0.models.GoogleGlobalSiteTag]
          case "google_tag_manager" => js.validate[io.flow.checkout.configuration.v0.models.GoogleTagManager]
          case "facebook_pixel" => js.validate[io.flow.checkout.configuration.v0.models.FacebookPixel]
          case "snapchat_pixel" => js.validate[io.flow.checkout.configuration.v0.models.SnapchatPixel]
          case other => play.api.libs.json.JsSuccess(io.flow.checkout.configuration.v0.models.TrackerUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectTracker(obj: io.flow.checkout.configuration.v0.models.Tracker): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.checkout.configuration.v0.models.GoogleAnalytics => jsObjectGoogleAnalytics(x)
        case x: io.flow.checkout.configuration.v0.models.GoogleGlobalSiteTag => jsObjectGoogleGlobalSiteTag(x)
        case x: io.flow.checkout.configuration.v0.models.GoogleTagManager => jsObjectGoogleTagManager(x)
        case x: io.flow.checkout.configuration.v0.models.FacebookPixel => jsObjectFacebookPixel(x)
        case x: io.flow.checkout.configuration.v0.models.SnapchatPixel => jsObjectSnapchatPixel(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesCheckoutConfigurationTracker: play.api.libs.json.Writes[Tracker] = {
      (obj: io.flow.checkout.configuration.v0.models.Tracker) => {
        jsObjectTracker(obj)
      }
    }
  }
}

package io.flow.checkout.configuration.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}

    // import models directly for backwards compatibility with prior versions of the generator
    import Core._
    import Models._

    object Core {
      implicit def pathBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.DateTime] = ApibuilderPathBindable(ApibuilderTypes.dateTimeIso8601)
      implicit def queryStringBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.DateTime] = ApibuilderQueryStringBindable(ApibuilderTypes.dateTimeIso8601)

      implicit def pathBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.LocalDate] = ApibuilderPathBindable(ApibuilderTypes.dateIso8601)
      implicit def queryStringBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.LocalDate] = ApibuilderQueryStringBindable(ApibuilderTypes.dateIso8601)
    }

    object Models {
      import io.flow.checkout.configuration.v0.models._

      val checkoutAssetTypeConverter: ApibuilderTypeConverter[io.flow.checkout.configuration.v0.models.CheckoutAssetType] = new ApibuilderTypeConverter[io.flow.checkout.configuration.v0.models.CheckoutAssetType] {
        override def convert(value: String): io.flow.checkout.configuration.v0.models.CheckoutAssetType = io.flow.checkout.configuration.v0.models.CheckoutAssetType(value)
        override def convert(value: io.flow.checkout.configuration.v0.models.CheckoutAssetType): String = value.toString
        override def example: io.flow.checkout.configuration.v0.models.CheckoutAssetType = io.flow.checkout.configuration.v0.models.CheckoutAssetType.Stylesheet
        override def validValues: Seq[io.flow.checkout.configuration.v0.models.CheckoutAssetType] = io.flow.checkout.configuration.v0.models.CheckoutAssetType.all
      }
      implicit def pathBindableCheckoutAssetType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.checkout.configuration.v0.models.CheckoutAssetType] = ApibuilderPathBindable(checkoutAssetTypeConverter)
      implicit def queryStringBindableCheckoutAssetType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.checkout.configuration.v0.models.CheckoutAssetType] = ApibuilderQueryStringBindable(checkoutAssetTypeConverter)

      val checkoutPromptBehaviorConverter: ApibuilderTypeConverter[io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior] = new ApibuilderTypeConverter[io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior] {
        override def convert(value: String): io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior = io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior(value)
        override def convert(value: io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior): String = value.toString
        override def example: io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior = io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior.Always
        override def validValues: Seq[io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior] = io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior.all
      }
      implicit def pathBindableCheckoutPromptBehavior(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior] = ApibuilderPathBindable(checkoutPromptBehaviorConverter)
      implicit def queryStringBindableCheckoutPromptBehavior(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.checkout.configuration.v0.models.CheckoutPromptBehavior] = ApibuilderQueryStringBindable(checkoutPromptBehaviorConverter)

      val checkoutShippingMethodPromptBehaviorConverter: ApibuilderTypeConverter[io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior] = new ApibuilderTypeConverter[io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior] {
        override def convert(value: String): io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior = io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior(value)
        override def convert(value: io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior): String = value.toString
        override def example: io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior = io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior.Always
        override def validValues: Seq[io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior] = io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior.all
      }
      implicit def pathBindableCheckoutShippingMethodPromptBehavior(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior] = ApibuilderPathBindable(checkoutShippingMethodPromptBehaviorConverter)
      implicit def queryStringBindableCheckoutShippingMethodPromptBehavior(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.checkout.configuration.v0.models.CheckoutShippingMethodPromptBehavior] = ApibuilderQueryStringBindable(checkoutShippingMethodPromptBehaviorConverter)

      val checkoutUrlTypeConverter: ApibuilderTypeConverter[io.flow.checkout.configuration.v0.models.CheckoutUrlType] = new ApibuilderTypeConverter[io.flow.checkout.configuration.v0.models.CheckoutUrlType] {
        override def convert(value: String): io.flow.checkout.configuration.v0.models.CheckoutUrlType = io.flow.checkout.configuration.v0.models.CheckoutUrlType(value)
        override def convert(value: io.flow.checkout.configuration.v0.models.CheckoutUrlType): String = value.toString
        override def example: io.flow.checkout.configuration.v0.models.CheckoutUrlType = io.flow.checkout.configuration.v0.models.CheckoutUrlType.ContinueShopping
        override def validValues: Seq[io.flow.checkout.configuration.v0.models.CheckoutUrlType] = io.flow.checkout.configuration.v0.models.CheckoutUrlType.all
      }
      implicit def pathBindableCheckoutUrlType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.checkout.configuration.v0.models.CheckoutUrlType] = ApibuilderPathBindable(checkoutUrlTypeConverter)
      implicit def queryStringBindableCheckoutUrlType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.checkout.configuration.v0.models.CheckoutUrlType] = ApibuilderQueryStringBindable(checkoutUrlTypeConverter)

      val googleAnalyticsPluginConverter: ApibuilderTypeConverter[io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin] = new ApibuilderTypeConverter[io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin] {
        override def convert(value: String): io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin = io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin(value)
        override def convert(value: io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin): String = value.toString
        override def example: io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin = io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin.Ec
        override def validValues: Seq[io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin] = io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin.all
      }
      implicit def pathBindableGoogleAnalyticsPlugin(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin] = ApibuilderPathBindable(googleAnalyticsPluginConverter)
      implicit def queryStringBindableGoogleAnalyticsPlugin(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.checkout.configuration.v0.models.GoogleAnalyticsPlugin] = ApibuilderQueryStringBindable(googleAnalyticsPluginConverter)
    }

    trait ApibuilderTypeConverter[T] {

      def convert(value: String): T

      def convert(value: T): String

      def example: T

      def validValues: Seq[T] = Nil

      def errorMessage(key: String, value: String, ex: java.lang.Exception): String = {
        val base = s"Invalid value '$value' for parameter '$key'. "
        validValues.toList match {
          case Nil => base + "Ex: " + convert(example)
          case values => base + ". Valid values are: " + values.mkString("'", "', '", "'")
        }
      }
    }

    object ApibuilderTypes {
      val dateTimeIso8601: ApibuilderTypeConverter[_root_.org.joda.time.DateTime] = new ApibuilderTypeConverter[_root_.org.joda.time.DateTime] {
        override def convert(value: String): _root_.org.joda.time.DateTime = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(value)
        override def convert(value: _root_.org.joda.time.DateTime): String = _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(value)
        override def example: _root_.org.joda.time.DateTime = _root_.org.joda.time.DateTime.now
      }

      val dateIso8601: ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] = new ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] {
        override def convert(value: String): _root_.org.joda.time.LocalDate = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(value)
        override def convert(value: _root_.org.joda.time.LocalDate): String = _root_.org.joda.time.format.ISODateTimeFormat.date.print(value)
        override def example: _root_.org.joda.time.LocalDate = _root_.org.joda.time.LocalDate.now
      }
    }

    final case class ApibuilderQueryStringBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends QueryStringBindable[T] {

      override def bind(key: String, params: Map[String, Seq[String]]): _root_.scala.Option[_root_.scala.Either[String, T]] = {
        params.getOrElse(key, Nil).headOption.map { v =>
          try {
            Right(
              converters.convert(v)
            )
          } catch {
            case ex: java.lang.Exception => Left(
              converters.errorMessage(key, v, ex)
            )
          }
        }
      }

      override def unbind(key: String, value: T): String = {
        s"$key=${converters.convert(value)}"
      }
    }

    final case class ApibuilderPathBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends PathBindable[T] {

      override def bind(key: String, value: String): _root_.scala.Either[String, T] = {
        try {
          Right(
            converters.convert(value)
          )
        } catch {
          case ex: java.lang.Exception => Left(
            converters.errorMessage(key, value, ex)
          )
        }
      }

      override def unbind(key: String, value: T): String = {
        converters.convert(value)
      }
    }

  }

}
