/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.10.75
 * apibuilder 0.15.33 app.apibuilder.io/flow/harmonization/latest/play_2_x_json
 */
package io.flow.harmonization.v0.models {

  /**
   * Result of looking up a specific tax registration number. Includes details of
   * both the consumer request and the VIES response.
   *
   * @param consumerCompanyName The company name the consumer entered at checkout
   * @param number The tax registration number
   * @param country The country of registration for a tax registration number
   * @param success Indicates whether this tax registration request was considered sucessful by
   *        Flow.
   * @param viesResultReason Additional details - e.g. why the result was invalid
   * @param viesCompanyName The name associated with the tax registration number from VIES.
   * @param viesCompanyAddress The address associated with the tax registration number from VIES.
   * @param companyNameMatchResult Results of the Flow company name match. Note that when we are unable to validate
   *        due to unexpected data in a valid response from VIES, we will consider this
   *        registration request successful.
   * @param companyNameMatchResultReason Details of why a name match could not be performed.
   */

  final case class DetailedTaxRegistration(
    id: String,
    key: String,
    consumerCompanyName: _root_.scala.Option[String] = None,
    number: String,
    country: String,
    success: Boolean,
    timestamp: _root_.org.joda.time.DateTime,
    viesResult: io.flow.harmonization.v0.models.TaxVerificationResult,
    viesResultReason: _root_.scala.Option[String] = None,
    viesCompanyName: _root_.scala.Option[String] = None,
    viesCompanyAddress: _root_.scala.Option[String] = None,
    companyNameMatchResult: io.flow.harmonization.v0.models.TaxVerificationResult,
    companyNameMatchResultReason: _root_.scala.Option[String] = None
  )

  final case class HarmonizedCategoryReference(
    id: String
  )

  /**
   * A harmonized item stores explicit information about this item for the purposes
   * of harmonization / classification. The harmonization process begins by creating
   * a harmonized item; this kicks off the internal processes. Once assigned, codes
   * will be available via the hs6 and hs10 resources
   *
   * @param description Generic description used to harmonize/classify the item and assign hs6 and hs10
   *        codes.
   */

  final case class HarmonizedItem(
    id: String,
    number: String,
    name: String,
    categories: Seq[String] = Nil,
    attributes: Map[String, String] = Map.empty,
    description: _root_.scala.Option[String] = None
  )

  /**
   * @param currency ISO 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   * @param price The actual price of the item as offered to a customer. This price must be in the
   *        currency specified for this item.
   */

  final case class HarmonizedItemForm(
    name: String,
    number: String,
    currency: String,
    price: Double,
    categories: _root_.scala.Option[Seq[String]] = None,
    description: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * @param currency ISO 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   * @param price The actual price of the item as offered to a customer. This price must be in the
   *        currency specified for this item.
   */

  final case class HarmonizedItemPutForm(
    name: String,
    currency: String,
    price: Double,
    categories: _root_.scala.Option[Seq[String]] = None,
    description: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  final case class HarmonizedItemReference(
    id: String,
    number: String,
    description: _root_.scala.Option[String] = None
  )

  /**
   * Summary of landed cost data (taxes and duties) for 1 or more items going to a
   * single destination country. Records are unique based on (item.number, country of
   * origin).
   *
   * @param address The destination address
   */

  final case class HarmonizedLandedCost(
    address: io.flow.common.v0.models.Address,
    items: Seq[io.flow.harmonization.v0.models.HarmonizedLandedCostItem],
    taxRegistration: _root_.scala.Option[io.flow.harmonization.v0.models.TaxRegistration] = None
  )

  /**
   * Allows calculation of duty and tax for multiple items in one API call for items
   * going to a specific destination country
   *
   * @param address The destination address. At a minimum, country code is required, but more
   *        precise information will lead to more precise rates.
   * @param sourceAddress The center address from where the items were shipped
   * @param orderNumber The order number
   * @param taxRegistrationId The ID of a tax registration to use to evaluate the tax rates as the
   *        registration may affect applicable rates. e.g. EU VAT registration number.
   * @param billingAddress The billing address. Used in some cases to determine tax jurisdiction.
   */

  final case class HarmonizedLandedCostForm(
    address: io.flow.common.v0.models.Address,
    itemNumbers: Seq[String],
    sourceAddress: _root_.scala.Option[io.flow.common.v0.models.Address] = None,
    orderNumber: _root_.scala.Option[String] = None,
    lineItems: _root_.scala.Option[Seq[io.flow.common.v0.models.LineItem]] = None,
    taxRegistrationId: _root_.scala.Option[String] = None,
    billingAddress: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None
  )

  /**
   * Duty and tax information for a given item. Note that the internal implementation
   * supports multiple countries of origin.
   */

  final case class HarmonizedLandedCostItem(
    item: io.flow.harmonization.v0.models.HarmonizedItemReference,
    duty: io.flow.price.v0.models.Duty,
    tax: io.flow.price.v0.models.Tax,
    taxApplicability: _root_.scala.Option[io.flow.harmonization.v0.models.TaxApplicability] = None
  )

  /**
   * The (Harmonized System) HS-10 code assigned to an item with a given
   * origin/destination pair.
   *
   * @param item The item to which this code is assigned
   * @param origin The ISO 3166 3 character code for the country of origin
   * @param destination The ISO 3166 3 character code for the destination country
   * @param code The assigned HS-10 code
   */

  final case class Hs10(
    id: String,
    item: io.flow.harmonization.v0.models.HarmonizedItemReference,
    origin: String,
    destination: String,
    code: String
  )

  final case class Hs10Version(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    hs10: io.flow.harmonization.v0.models.Hs10
  )

  /**
   * The (Harmonized System) HS-6 code assigned to an item.
   *
   * @param item The item to which this code is assigned
   * @param code The assigned HS-6 code
   */

  final case class Hs6(
    id: String,
    item: io.flow.harmonization.v0.models.HarmonizedItemReference,
    code: String
  )

  /**
   * The tariff codes, duty rates and tax rates associated with an origin/destination
   * pair. Does not take into account sales province
   *
   * @param origin The ISO 3166 3 character code for the country of origin
   * @param destination The ISO 3166 3 character code for the destination country
   * @param tariffCode The assigned tariff code for a product
   * @param effectiveDuty A percentage duty rate. Note that in the case of complex duties this will be
   *        calculated from the details of the item in question and may not scale with
   *        changes to price.
   */

  final case class LaneLandedCost(
    origin: String,
    destination: String,
    tariffCode: String,
    effectiveDuty: io.flow.price.v0.models.Duty,
    tax: io.flow.price.v0.models.Tax
  )

  /**
   * Result of looking up a specific tax registration number. Indicates validity of a
   * number for a specific country and (if valid) the associated person/company.
   *
   * @param number The tax registration number
   * @param resultReason Additional details - e.g. why the result was invalid
   * @param name The name associated with the tax registration number.
   * @param address The address associated with the tax registration number.
   */

  final case class TaxRegistration(
    id: String,
    key: String,
    number: String,
    timestamp: _root_.org.joda.time.DateTime,
    result: io.flow.harmonization.v0.models.TaxVerificationResult,
    resultReason: _root_.scala.Option[String] = None,
    name: _root_.scala.Option[String] = None,
    address: _root_.scala.Option[String] = None,
    companyName: _root_.scala.Option[String] = None
  )

  /**
   * @param number The tax registration number
   */

  final case class TaxRegistrationForm(
    number: String,
    companyName: _root_.scala.Option[String] = None
  )
  sealed trait TaxApplicability extends _root_.scala.Product with _root_.scala.Serializable

  object TaxApplicability {

    /**
     * In no scenario should a customer pay tax within the Flow system.
     */
    case object None extends TaxApplicability {
      override def toString = "none"
    }
    /**
     * In all scenarios a customer should pay tax within the Flow system.
     */
    case object All extends TaxApplicability {
      override def toString = "all"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends TaxApplicability

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[TaxApplicability] = scala.List(None, All)

    private[this]
    val byName: Map[String, TaxApplicability] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TaxApplicability = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TaxApplicability] = byName.get(value.toLowerCase)

  }

  sealed trait TaxVerificationResult extends _root_.scala.Product with _root_.scala.Serializable

  object TaxVerificationResult {

    case object Valid extends TaxVerificationResult { override def toString = "valid" }
    case object Invalid extends TaxVerificationResult { override def toString = "invalid" }
    case object UnableToValidate extends TaxVerificationResult { override def toString = "unable_to_validate" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends TaxVerificationResult

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[TaxVerificationResult] = scala.List(Valid, Invalid, UnableToValidate)

    private[this]
    val byName: Map[String, TaxVerificationResult] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TaxVerificationResult = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TaxVerificationResult] = byName.get(value.toLowerCase)

  }

}

package io.flow.harmonization.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.common.v0.models.json._
    import io.flow.error.v0.models.json._
    import io.flow.harmonization.v0.models.json._
    import io.flow.permission.v0.models.json._
    import io.flow.price.v0.models.json._

    private[v0] implicit val jsonReadsUUID: play.api.libs.json.Reads[_root_.java.util.UUID] = __.read[String].map { str =>
      _root_.java.util.UUID.fromString(str)
    }

    private[v0] implicit val jsonWritesUUID: play.api.libs.json.Writes[_root_.java.util.UUID] = (x: _root_.java.util.UUID) => play.api.libs.json.JsString(x.toString)

    private[v0] implicit val jsonReadsJodaDateTime: play.api.libs.json.Reads[_root_.org.joda.time.DateTime] = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime: play.api.libs.json.Writes[_root_.org.joda.time.DateTime] = (x: _root_.org.joda.time.DateTime) => {
      play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x))
    }

    private[v0] implicit val jsonReadsJodaLocalDate: play.api.libs.json.Reads[_root_.org.joda.time.LocalDate] = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(str)
    }

    private[v0] implicit val jsonWritesJodaLocalDate: play.api.libs.json.Writes[_root_.org.joda.time.LocalDate] = (x: _root_.org.joda.time.LocalDate) => {
      play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.date.print(x))
    }

    implicit val jsonReadsHarmonizationTaxApplicability: play.api.libs.json.Reads[io.flow.harmonization.v0.models.TaxApplicability] = new play.api.libs.json.Reads[io.flow.harmonization.v0.models.TaxApplicability] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.harmonization.v0.models.TaxApplicability] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.harmonization.v0.models.TaxApplicability(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.harmonization.v0.models.TaxApplicability(v))
              case err: play.api.libs.json.JsError =>
                (js \ "tax_applicability").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.harmonization.v0.models.TaxApplicability(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesHarmonizationTaxApplicability(obj: io.flow.harmonization.v0.models.TaxApplicability) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTaxApplicability(obj: io.flow.harmonization.v0.models.TaxApplicability) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesHarmonizationTaxApplicability: play.api.libs.json.Writes[TaxApplicability] = {
      (obj: io.flow.harmonization.v0.models.TaxApplicability) => {
        jsonWritesHarmonizationTaxApplicability(obj)
      }
    }

    implicit val jsonReadsHarmonizationTaxVerificationResult: play.api.libs.json.Reads[io.flow.harmonization.v0.models.TaxVerificationResult] = new play.api.libs.json.Reads[io.flow.harmonization.v0.models.TaxVerificationResult] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.harmonization.v0.models.TaxVerificationResult] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.harmonization.v0.models.TaxVerificationResult(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.harmonization.v0.models.TaxVerificationResult(v))
              case err: play.api.libs.json.JsError =>
                (js \ "tax_verification_result").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.harmonization.v0.models.TaxVerificationResult(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesHarmonizationTaxVerificationResult(obj: io.flow.harmonization.v0.models.TaxVerificationResult) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTaxVerificationResult(obj: io.flow.harmonization.v0.models.TaxVerificationResult) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesHarmonizationTaxVerificationResult: play.api.libs.json.Writes[TaxVerificationResult] = {
      (obj: io.flow.harmonization.v0.models.TaxVerificationResult) => {
        jsonWritesHarmonizationTaxVerificationResult(obj)
      }
    }

    implicit def jsonReadsHarmonizationDetailedTaxRegistration: play.api.libs.json.Reads[DetailedTaxRegistration] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        consumerCompanyName <- (__ \ "consumer_company_name").readNullable[String]
        number <- (__ \ "number").read[String]
        country <- (__ \ "country").read[String]
        success <- (__ \ "success").read[Boolean]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        viesResult <- (__ \ "vies_result").read[io.flow.harmonization.v0.models.TaxVerificationResult]
        viesResultReason <- (__ \ "vies_result_reason").readNullable[String]
        viesCompanyName <- (__ \ "vies_company_name").readNullable[String]
        viesCompanyAddress <- (__ \ "vies_company_address").readNullable[String]
        companyNameMatchResult <- (__ \ "company_name_match_result").read[io.flow.harmonization.v0.models.TaxVerificationResult]
        companyNameMatchResultReason <- (__ \ "company_name_match_result_reason").readNullable[String]
      } yield DetailedTaxRegistration(id, key, consumerCompanyName, number, country, success, timestamp, viesResult, viesResultReason, viesCompanyName, viesCompanyAddress, companyNameMatchResult, companyNameMatchResultReason)
    }

    def jsObjectDetailedTaxRegistration(obj: io.flow.harmonization.v0.models.DetailedTaxRegistration): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "number" -> play.api.libs.json.JsString(obj.number),
        "country" -> play.api.libs.json.JsString(obj.country),
        "success" -> play.api.libs.json.JsBoolean(obj.success),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "vies_result" -> play.api.libs.json.JsString(obj.viesResult.toString),
        "company_name_match_result" -> play.api.libs.json.JsString(obj.companyNameMatchResult.toString)
      ) ++ (obj.consumerCompanyName match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("consumer_company_name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.viesResultReason match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("vies_result_reason" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.viesCompanyName match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("vies_company_name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.viesCompanyAddress match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("vies_company_address" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.companyNameMatchResultReason match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("company_name_match_result_reason" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesHarmonizationDetailedTaxRegistration: play.api.libs.json.Writes[DetailedTaxRegistration] = {
      (obj: io.flow.harmonization.v0.models.DetailedTaxRegistration) => {
        jsObjectDetailedTaxRegistration(obj)
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedCategoryReference: play.api.libs.json.Reads[HarmonizedCategoryReference] = {
      (__ \ "id").read[String].map { x => new HarmonizedCategoryReference(id = x) }
    }

    def jsObjectHarmonizedCategoryReference(obj: io.flow.harmonization.v0.models.HarmonizedCategoryReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesHarmonizationHarmonizedCategoryReference: play.api.libs.json.Writes[HarmonizedCategoryReference] = {
      (obj: io.flow.harmonization.v0.models.HarmonizedCategoryReference) => {
        jsObjectHarmonizedCategoryReference(obj)
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedItem: play.api.libs.json.Reads[HarmonizedItem] = {
      for {
        id <- (__ \ "id").read[String]
        number <- (__ \ "number").read[String]
        name <- (__ \ "name").read[String]
        categories <- (__ \ "categories").read[Seq[String]]
        attributes <- (__ \ "attributes").read[Map[String, String]]
        description <- (__ \ "description").readNullable[String]
      } yield HarmonizedItem(id, number, name, categories, attributes, description)
    }

    def jsObjectHarmonizedItem(obj: io.flow.harmonization.v0.models.HarmonizedItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number),
        "name" -> play.api.libs.json.JsString(obj.name),
        "categories" -> play.api.libs.json.Json.toJson(obj.categories),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesHarmonizationHarmonizedItem: play.api.libs.json.Writes[HarmonizedItem] = {
      (obj: io.flow.harmonization.v0.models.HarmonizedItem) => {
        jsObjectHarmonizedItem(obj)
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedItemForm: play.api.libs.json.Reads[HarmonizedItemForm] = {
      for {
        name <- (__ \ "name").read[String]
        number <- (__ \ "number").read[String]
        currency <- (__ \ "currency").read[String]
        price <- (__ \ "price").read[Double]
        categories <- (__ \ "categories").readNullable[Seq[String]]
        description <- (__ \ "description").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield HarmonizedItemForm(name, number, currency, price, categories, description, attributes)
    }

    def jsObjectHarmonizedItemForm(obj: io.flow.harmonization.v0.models.HarmonizedItemForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "number" -> play.api.libs.json.JsString(obj.number),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "price" -> play.api.libs.json.JsNumber(obj.price)
      ) ++ (obj.categories match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("categories" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesHarmonizationHarmonizedItemForm: play.api.libs.json.Writes[HarmonizedItemForm] = {
      (obj: io.flow.harmonization.v0.models.HarmonizedItemForm) => {
        jsObjectHarmonizedItemForm(obj)
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedItemPutForm: play.api.libs.json.Reads[HarmonizedItemPutForm] = {
      for {
        name <- (__ \ "name").read[String]
        currency <- (__ \ "currency").read[String]
        price <- (__ \ "price").read[Double]
        categories <- (__ \ "categories").readNullable[Seq[String]]
        description <- (__ \ "description").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield HarmonizedItemPutForm(name, currency, price, categories, description, attributes)
    }

    def jsObjectHarmonizedItemPutForm(obj: io.flow.harmonization.v0.models.HarmonizedItemPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "price" -> play.api.libs.json.JsNumber(obj.price)
      ) ++ (obj.categories match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("categories" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesHarmonizationHarmonizedItemPutForm: play.api.libs.json.Writes[HarmonizedItemPutForm] = {
      (obj: io.flow.harmonization.v0.models.HarmonizedItemPutForm) => {
        jsObjectHarmonizedItemPutForm(obj)
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedItemReference: play.api.libs.json.Reads[HarmonizedItemReference] = {
      for {
        id <- (__ \ "id").read[String]
        number <- (__ \ "number").read[String]
        description <- (__ \ "description").readNullable[String]
      } yield HarmonizedItemReference(id, number, description)
    }

    def jsObjectHarmonizedItemReference(obj: io.flow.harmonization.v0.models.HarmonizedItemReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesHarmonizationHarmonizedItemReference: play.api.libs.json.Writes[HarmonizedItemReference] = {
      (obj: io.flow.harmonization.v0.models.HarmonizedItemReference) => {
        jsObjectHarmonizedItemReference(obj)
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedLandedCost: play.api.libs.json.Reads[HarmonizedLandedCost] = {
      for {
        address <- (__ \ "address").read[io.flow.common.v0.models.Address]
        items <- (__ \ "items").read[Seq[io.flow.harmonization.v0.models.HarmonizedLandedCostItem]]
        taxRegistration <- (__ \ "tax_registration").readNullable[io.flow.harmonization.v0.models.TaxRegistration]
      } yield HarmonizedLandedCost(address, items, taxRegistration)
    }

    def jsObjectHarmonizedLandedCost(obj: io.flow.harmonization.v0.models.HarmonizedLandedCost): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "address" -> io.flow.common.v0.models.json.jsObjectAddress(obj.address),
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.taxRegistration match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tax_registration" -> jsObjectTaxRegistration(x))
      })
    }

    implicit def jsonWritesHarmonizationHarmonizedLandedCost: play.api.libs.json.Writes[HarmonizedLandedCost] = {
      (obj: io.flow.harmonization.v0.models.HarmonizedLandedCost) => {
        jsObjectHarmonizedLandedCost(obj)
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedLandedCostForm: play.api.libs.json.Reads[HarmonizedLandedCostForm] = {
      for {
        address <- (__ \ "address").read[io.flow.common.v0.models.Address]
        itemNumbers <- (__ \ "item_numbers").read[Seq[String]]
        sourceAddress <- (__ \ "source_address").readNullable[io.flow.common.v0.models.Address]
        orderNumber <- (__ \ "order_number").readNullable[String]
        lineItems <- (__ \ "line_items").readNullable[Seq[io.flow.common.v0.models.LineItem]]
        taxRegistrationId <- (__ \ "tax_registration_id").readNullable[String]
        billingAddress <- (__ \ "billing_address").readNullable[io.flow.common.v0.models.BillingAddress]
      } yield HarmonizedLandedCostForm(address, itemNumbers, sourceAddress, orderNumber, lineItems, taxRegistrationId, billingAddress)
    }

    def jsObjectHarmonizedLandedCostForm(obj: io.flow.harmonization.v0.models.HarmonizedLandedCostForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "address" -> io.flow.common.v0.models.json.jsObjectAddress(obj.address),
        "item_numbers" -> play.api.libs.json.Json.toJson(obj.itemNumbers)
      ) ++ (obj.sourceAddress match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("source_address" -> io.flow.common.v0.models.json.jsObjectAddress(x))
      }) ++
      (obj.orderNumber match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order_number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.lineItems match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("line_items" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.taxRegistrationId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tax_registration_id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.billingAddress match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("billing_address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      })
    }

    implicit def jsonWritesHarmonizationHarmonizedLandedCostForm: play.api.libs.json.Writes[HarmonizedLandedCostForm] = {
      (obj: io.flow.harmonization.v0.models.HarmonizedLandedCostForm) => {
        jsObjectHarmonizedLandedCostForm(obj)
      }
    }

    implicit def jsonReadsHarmonizationHarmonizedLandedCostItem: play.api.libs.json.Reads[HarmonizedLandedCostItem] = {
      for {
        item <- (__ \ "item").read[io.flow.harmonization.v0.models.HarmonizedItemReference]
        duty <- (__ \ "duty").read[io.flow.price.v0.models.Duty]
        tax <- (__ \ "tax").read[io.flow.price.v0.models.Tax]
        taxApplicability <- (__ \ "tax_applicability").readNullable[io.flow.harmonization.v0.models.TaxApplicability]
      } yield HarmonizedLandedCostItem(item, duty, tax, taxApplicability)
    }

    def jsObjectHarmonizedLandedCostItem(obj: io.flow.harmonization.v0.models.HarmonizedLandedCostItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "item" -> jsObjectHarmonizedItemReference(obj.item),
        "duty" -> io.flow.price.v0.models.json.jsObjectDuty(obj.duty),
        "tax" -> io.flow.price.v0.models.json.jsObjectTax(obj.tax)
      ) ++ (obj.taxApplicability match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tax_applicability" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesHarmonizationHarmonizedLandedCostItem: play.api.libs.json.Writes[HarmonizedLandedCostItem] = {
      (obj: io.flow.harmonization.v0.models.HarmonizedLandedCostItem) => {
        jsObjectHarmonizedLandedCostItem(obj)
      }
    }

    implicit def jsonReadsHarmonizationHs10: play.api.libs.json.Reads[Hs10] = {
      for {
        id <- (__ \ "id").read[String]
        item <- (__ \ "item").read[io.flow.harmonization.v0.models.HarmonizedItemReference]
        origin <- (__ \ "origin").read[String]
        destination <- (__ \ "destination").read[String]
        code <- (__ \ "code").read[String]
      } yield Hs10(id, item, origin, destination, code)
    }

    def jsObjectHs10(obj: io.flow.harmonization.v0.models.Hs10): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "item" -> jsObjectHarmonizedItemReference(obj.item),
        "origin" -> play.api.libs.json.JsString(obj.origin),
        "destination" -> play.api.libs.json.JsString(obj.destination),
        "code" -> play.api.libs.json.JsString(obj.code)
      )
    }

    implicit def jsonWritesHarmonizationHs10: play.api.libs.json.Writes[Hs10] = {
      (obj: io.flow.harmonization.v0.models.Hs10) => {
        jsObjectHs10(obj)
      }
    }

    implicit def jsonReadsHarmonizationHs10Version: play.api.libs.json.Reads[Hs10Version] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        hs10 <- (__ \ "hs10").read[io.flow.harmonization.v0.models.Hs10]
      } yield Hs10Version(id, timestamp, `type`, hs10)
    }

    def jsObjectHs10Version(obj: io.flow.harmonization.v0.models.Hs10Version): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "hs10" -> jsObjectHs10(obj.hs10)
      )
    }

    implicit def jsonWritesHarmonizationHs10Version: play.api.libs.json.Writes[Hs10Version] = {
      (obj: io.flow.harmonization.v0.models.Hs10Version) => {
        jsObjectHs10Version(obj)
      }
    }

    implicit def jsonReadsHarmonizationHs6: play.api.libs.json.Reads[Hs6] = {
      for {
        id <- (__ \ "id").read[String]
        item <- (__ \ "item").read[io.flow.harmonization.v0.models.HarmonizedItemReference]
        code <- (__ \ "code").read[String]
      } yield Hs6(id, item, code)
    }

    def jsObjectHs6(obj: io.flow.harmonization.v0.models.Hs6): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "item" -> jsObjectHarmonizedItemReference(obj.item),
        "code" -> play.api.libs.json.JsString(obj.code)
      )
    }

    implicit def jsonWritesHarmonizationHs6: play.api.libs.json.Writes[Hs6] = {
      (obj: io.flow.harmonization.v0.models.Hs6) => {
        jsObjectHs6(obj)
      }
    }

    implicit def jsonReadsHarmonizationLaneLandedCost: play.api.libs.json.Reads[LaneLandedCost] = {
      for {
        origin <- (__ \ "origin").read[String]
        destination <- (__ \ "destination").read[String]
        tariffCode <- (__ \ "tariff_code").read[String]
        effectiveDuty <- (__ \ "effective_duty").read[io.flow.price.v0.models.Duty]
        tax <- (__ \ "tax").read[io.flow.price.v0.models.Tax]
      } yield LaneLandedCost(origin, destination, tariffCode, effectiveDuty, tax)
    }

    def jsObjectLaneLandedCost(obj: io.flow.harmonization.v0.models.LaneLandedCost): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "origin" -> play.api.libs.json.JsString(obj.origin),
        "destination" -> play.api.libs.json.JsString(obj.destination),
        "tariff_code" -> play.api.libs.json.JsString(obj.tariffCode),
        "effective_duty" -> io.flow.price.v0.models.json.jsObjectDuty(obj.effectiveDuty),
        "tax" -> io.flow.price.v0.models.json.jsObjectTax(obj.tax)
      )
    }

    implicit def jsonWritesHarmonizationLaneLandedCost: play.api.libs.json.Writes[LaneLandedCost] = {
      (obj: io.flow.harmonization.v0.models.LaneLandedCost) => {
        jsObjectLaneLandedCost(obj)
      }
    }

    implicit def jsonReadsHarmonizationTaxRegistration: play.api.libs.json.Reads[TaxRegistration] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        number <- (__ \ "number").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        result <- (__ \ "result").read[io.flow.harmonization.v0.models.TaxVerificationResult]
        resultReason <- (__ \ "result_reason").readNullable[String]
        name <- (__ \ "name").readNullable[String]
        address <- (__ \ "address").readNullable[String]
        companyName <- (__ \ "company_name").readNullable[String]
      } yield TaxRegistration(id, key, number, timestamp, result, resultReason, name, address, companyName)
    }

    def jsObjectTaxRegistration(obj: io.flow.harmonization.v0.models.TaxRegistration): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "number" -> play.api.libs.json.JsString(obj.number),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "result" -> play.api.libs.json.JsString(obj.result.toString)
      ) ++ (obj.resultReason match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("result_reason" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.address match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("address" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.companyName match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("company_name" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesHarmonizationTaxRegistration: play.api.libs.json.Writes[TaxRegistration] = {
      (obj: io.flow.harmonization.v0.models.TaxRegistration) => {
        jsObjectTaxRegistration(obj)
      }
    }

    implicit def jsonReadsHarmonizationTaxRegistrationForm: play.api.libs.json.Reads[TaxRegistrationForm] = {
      for {
        number <- (__ \ "number").read[String]
        companyName <- (__ \ "company_name").readNullable[String]
      } yield TaxRegistrationForm(number, companyName)
    }

    def jsObjectTaxRegistrationForm(obj: io.flow.harmonization.v0.models.TaxRegistrationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number)
      ) ++ (obj.companyName match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("company_name" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesHarmonizationTaxRegistrationForm: play.api.libs.json.Writes[TaxRegistrationForm] = {
      (obj: io.flow.harmonization.v0.models.TaxRegistrationForm) => {
        jsObjectTaxRegistrationForm(obj)
      }
    }
  }
}

package io.flow.harmonization.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}

    // import models directly for backwards compatibility with prior versions of the generator
    import Core._
    import Models._

    object Core {
      implicit def pathBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.DateTime] = ApibuilderPathBindable(ApibuilderTypes.dateTimeIso8601)
      implicit def queryStringBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.DateTime] = ApibuilderQueryStringBindable(ApibuilderTypes.dateTimeIso8601)

      implicit def pathBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.LocalDate] = ApibuilderPathBindable(ApibuilderTypes.dateIso8601)
      implicit def queryStringBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.LocalDate] = ApibuilderQueryStringBindable(ApibuilderTypes.dateIso8601)
    }

    object Models {
      import io.flow.harmonization.v0.models._

      val taxApplicabilityConverter: ApibuilderTypeConverter[io.flow.harmonization.v0.models.TaxApplicability] = new ApibuilderTypeConverter[io.flow.harmonization.v0.models.TaxApplicability] {
        override def convert(value: String): io.flow.harmonization.v0.models.TaxApplicability = io.flow.harmonization.v0.models.TaxApplicability(value)
        override def convert(value: io.flow.harmonization.v0.models.TaxApplicability): String = value.toString
        override def example: io.flow.harmonization.v0.models.TaxApplicability = io.flow.harmonization.v0.models.TaxApplicability.None
        override def validValues: Seq[io.flow.harmonization.v0.models.TaxApplicability] = io.flow.harmonization.v0.models.TaxApplicability.all
      }
      implicit def pathBindableTaxApplicability(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.harmonization.v0.models.TaxApplicability] = ApibuilderPathBindable(taxApplicabilityConverter)
      implicit def queryStringBindableTaxApplicability(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.harmonization.v0.models.TaxApplicability] = ApibuilderQueryStringBindable(taxApplicabilityConverter)

      val taxVerificationResultConverter: ApibuilderTypeConverter[io.flow.harmonization.v0.models.TaxVerificationResult] = new ApibuilderTypeConverter[io.flow.harmonization.v0.models.TaxVerificationResult] {
        override def convert(value: String): io.flow.harmonization.v0.models.TaxVerificationResult = io.flow.harmonization.v0.models.TaxVerificationResult(value)
        override def convert(value: io.flow.harmonization.v0.models.TaxVerificationResult): String = value.toString
        override def example: io.flow.harmonization.v0.models.TaxVerificationResult = io.flow.harmonization.v0.models.TaxVerificationResult.Valid
        override def validValues: Seq[io.flow.harmonization.v0.models.TaxVerificationResult] = io.flow.harmonization.v0.models.TaxVerificationResult.all
      }
      implicit def pathBindableTaxVerificationResult(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.harmonization.v0.models.TaxVerificationResult] = ApibuilderPathBindable(taxVerificationResultConverter)
      implicit def queryStringBindableTaxVerificationResult(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.harmonization.v0.models.TaxVerificationResult] = ApibuilderQueryStringBindable(taxVerificationResultConverter)
    }

    trait ApibuilderTypeConverter[T] {

      def convert(value: String): T

      def convert(value: T): String

      def example: T

      def validValues: Seq[T] = Nil

      def errorMessage(key: String, value: String, ex: java.lang.Exception): String = {
        val base = s"Invalid value '$value' for parameter '$key'. "
        validValues.toList match {
          case Nil => base + "Ex: " + convert(example)
          case values => base + ". Valid values are: " + values.mkString("'", "', '", "'")
        }
      }
    }

    object ApibuilderTypes {
      val dateTimeIso8601: ApibuilderTypeConverter[_root_.org.joda.time.DateTime] = new ApibuilderTypeConverter[_root_.org.joda.time.DateTime] {
        override def convert(value: String): _root_.org.joda.time.DateTime = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(value)
        override def convert(value: _root_.org.joda.time.DateTime): String = _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(value)
        override def example: _root_.org.joda.time.DateTime = _root_.org.joda.time.DateTime.now
      }

      val dateIso8601: ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] = new ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] {
        override def convert(value: String): _root_.org.joda.time.LocalDate = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(value)
        override def convert(value: _root_.org.joda.time.LocalDate): String = _root_.org.joda.time.format.ISODateTimeFormat.date.print(value)
        override def example: _root_.org.joda.time.LocalDate = _root_.org.joda.time.LocalDate.now
      }
    }

    final case class ApibuilderQueryStringBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends QueryStringBindable[T] {

      override def bind(key: String, params: Map[String, Seq[String]]): _root_.scala.Option[_root_.scala.Either[String, T]] = {
        params.getOrElse(key, Nil).headOption.map { v =>
          try {
            Right(
              converters.convert(v)
            )
          } catch {
            case ex: java.lang.Exception => Left(
              converters.errorMessage(key, v, ex)
            )
          }
        }
      }

      override def unbind(key: String, value: T): String = {
        s"$key=${converters.convert(value)}"
      }
    }

    final case class ApibuilderPathBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends PathBindable[T] {

      override def bind(key: String, value: String): _root_.scala.Either[String, T] = {
        try {
          Right(
            converters.convert(value)
          )
        } catch {
          case ex: java.lang.Exception => Left(
            converters.errorMessage(key, value, ex)
          )
        }
      }

      override def unbind(key: String, value: T): String = {
        converters.convert(value)
      }
    }

  }

}
