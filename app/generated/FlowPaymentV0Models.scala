/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.10.75
 * apibuilder 0.15.33 app.apibuilder.io/flow/payment/latest/play_2_x_json
 */
package io.flow.payment.v0.models {

  sealed trait AdyenNativeData extends _root_.scala.Product with _root_.scala.Serializable {
    def adyenNativeDataDiscriminator: AdyenNativeDataDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type AdyenNativeData
   */
  sealed trait AdyenNativeDataDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object AdyenNativeDataDiscriminator {

    case object AdyenIdentifyShopperData extends AdyenNativeDataDiscriminator { override def toString = "adyen_identify_shopper_data" }
    case object AdyenChallengeShopperData extends AdyenNativeDataDiscriminator { override def toString = "adyen_challenge_shopper_data" }

    final case class UNDEFINED(override val toString: String) extends AdyenNativeDataDiscriminator

    val all: scala.List[AdyenNativeDataDiscriminator] = scala.List(AdyenIdentifyShopperData, AdyenChallengeShopperData)

    private[this] val byName: Map[String, AdyenNativeDataDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AdyenNativeDataDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AdyenNativeDataDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait Authorization extends _root_.scala.Product with _root_.scala.Serializable {
    def authorizationDiscriminator: AuthorizationDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type Authorization
   */
  sealed trait AuthorizationDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object AuthorizationDiscriminator {

    case object CardAuthorization extends AuthorizationDiscriminator { override def toString = "card_authorization" }
    case object OnlineAuthorization extends AuthorizationDiscriminator { override def toString = "online_authorization" }

    final case class UNDEFINED(override val toString: String) extends AuthorizationDiscriminator

    val all: scala.List[AuthorizationDiscriminator] = scala.List(CardAuthorization, OnlineAuthorization)

    private[this] val byName: Map[String, AuthorizationDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Flow provides several different options for creating an authorization
   */
  sealed trait AuthorizationForm extends _root_.scala.Product with _root_.scala.Serializable {
    def authorizationFormDiscriminator: AuthorizationFormDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type AuthorizationForm
   */
  sealed trait AuthorizationFormDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object AuthorizationFormDiscriminator {

    /**
     * Creates a new authorization by copying an existing one.
     */
    case object AuthorizationCopyForm extends AuthorizationFormDiscriminator { override def toString = "authorization_copy_form" }
    /**
     * Enables card payments
     */
    case object DirectAuthorizationForm extends AuthorizationFormDiscriminator { override def toString = "direct_authorization_form" }
    /**
     * Enables card payments with Flow as Merchant of Record
     */
    case object MerchantOfRecordAuthorizationForm extends AuthorizationFormDiscriminator { override def toString = "merchant_of_record_authorization_form" }
    /**
     * Enables authorization via PayPal
     */
    case object PaypalAuthorizationForm extends AuthorizationFormDiscriminator { override def toString = "paypal_authorization_form" }
    /**
     * Enables authorizations via redirect-based alternative payment methods, such as
     * AliPay.
     */
    case object RedirectAuthorizationForm extends AuthorizationFormDiscriminator { override def toString = "redirect_authorization_form" }
    /**
     * Enables authorizations via inline widget alternative payment methods, such as
     * Klarna.
     */
    case object InlineAuthorizationForm extends AuthorizationFormDiscriminator { override def toString = "inline_authorization_form" }
    /**
     * Enables authorizations via ACH (Automated Clearing House) bank transfer.
     */
    case object AchAuthorizationForm extends AuthorizationFormDiscriminator { override def toString = "ach_authorization_form" }
    /**
     * Enables authorizations via card payment source.
     */
    case object CardPaymentSourceAuthorizationForm extends AuthorizationFormDiscriminator { override def toString = "card_payment_source_authorization_form" }
    /**
     * Enables authorization via an online payment (e.g. CryptoPay)
     */
    case object OnlinePaymentAuthorizationForm extends AuthorizationFormDiscriminator { override def toString = "online_payment_authorization_form" }

    final case class UNDEFINED(override val toString: String) extends AuthorizationFormDiscriminator

    val all: scala.List[AuthorizationFormDiscriminator] = scala.List(AuthorizationCopyForm, DirectAuthorizationForm, MerchantOfRecordAuthorizationForm, PaypalAuthorizationForm, RedirectAuthorizationForm, InlineAuthorizationForm, AchAuthorizationForm, CardPaymentSourceAuthorizationForm, OnlinePaymentAuthorizationForm)

    private[this] val byName: Map[String, AuthorizationFormDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationFormDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationFormDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait AuthorizationPayloadParameters extends _root_.scala.Product with _root_.scala.Serializable {
    def authorizationPayloadParametersDiscriminator: AuthorizationPayloadParametersDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type
   * AuthorizationPayloadParameters
   */
  sealed trait AuthorizationPayloadParametersDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object AuthorizationPayloadParametersDiscriminator {

    case object GooglePayAuthorizationPayload extends AuthorizationPayloadParametersDiscriminator { override def toString = "google_pay_authorization_payload" }
    case object ApplePayMerchantValidationPayload extends AuthorizationPayloadParametersDiscriminator { override def toString = "apple_pay_merchant_validation_payload" }

    final case class UNDEFINED(override val toString: String) extends AuthorizationPayloadParametersDiscriminator

    val all: scala.List[AuthorizationPayloadParametersDiscriminator] = scala.List(GooglePayAuthorizationPayload, ApplePayMerchantValidationPayload)

    private[this] val byName: Map[String, AuthorizationPayloadParametersDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationPayloadParametersDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationPayloadParametersDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait AuthorizationResultAction extends _root_.scala.Product with _root_.scala.Serializable {
    def authorizationResultActionDiscriminator: AuthorizationResultActionDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type AuthorizationResultAction
   */
  sealed trait AuthorizationResultActionDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object AuthorizationResultActionDiscriminator {

    case object AuthorizationResultActionGet extends AuthorizationResultActionDiscriminator { override def toString = "authorization_result_action_get" }
    case object AuthorizationResultActionPost extends AuthorizationResultActionDiscriminator { override def toString = "authorization_result_action_post" }
    case object AuthorizationResultActionWait extends AuthorizationResultActionDiscriminator { override def toString = "authorization_result_action_wait" }
    case object AuthorizationResultActionNative extends AuthorizationResultActionDiscriminator { override def toString = "authorization_result_action_native" }

    final case class UNDEFINED(override val toString: String) extends AuthorizationResultActionDiscriminator

    val all: scala.List[AuthorizationResultActionDiscriminator] = scala.List(AuthorizationResultActionGet, AuthorizationResultActionPost, AuthorizationResultActionWait, AuthorizationResultActionNative)

    private[this] val byName: Map[String, AuthorizationResultActionDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationResultActionDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationResultActionDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait AuthorizationResultActionDetails extends _root_.scala.Product with _root_.scala.Serializable {
    def authorizationResultActionDetailsDiscriminator: AuthorizationResultActionDetailsDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type
   * AuthorizationResultActionDetails
   */
  sealed trait AuthorizationResultActionDetailsDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object AuthorizationResultActionDetailsDiscriminator {

    case object AdyenNativeActionDetails extends AuthorizationResultActionDetailsDiscriminator { override def toString = "adyen_native_action_details" }
    case object StripeAuthorizationResultActionDetails extends AuthorizationResultActionDetailsDiscriminator { override def toString = "stripe_authorization_result_action_details" }
    case object ThreedsIdentifyActionDetails extends AuthorizationResultActionDetailsDiscriminator { override def toString = "threeds_identify_action_details" }
    case object ThreedsChallengeActionDetails extends AuthorizationResultActionDetailsDiscriminator { override def toString = "threeds_challenge_action_details" }

    final case class UNDEFINED(override val toString: String) extends AuthorizationResultActionDetailsDiscriminator

    val all: scala.List[AuthorizationResultActionDetailsDiscriminator] = scala.List(AdyenNativeActionDetails, StripeAuthorizationResultActionDetails, ThreedsIdentifyActionDetails, ThreedsChallengeActionDetails)

    private[this] val byName: Map[String, AuthorizationResultActionDetailsDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationResultActionDetailsDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationResultActionDetailsDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Configurations to support payment authentication done in the browser experience
   * e.g. card authentication with 3DS by an issuer ACS.
   */
  sealed trait BrowserActionConfiguration extends _root_.scala.Product with _root_.scala.Serializable {
    def browserActionConfigurationDiscriminator: BrowserActionConfigurationDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type BrowserActionConfiguration
   */
  sealed trait BrowserActionConfigurationDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object BrowserActionConfigurationDiscriminator {

    case object CardBrowserActionConfiguration extends BrowserActionConfigurationDiscriminator { override def toString = "card_browser_action_configuration" }

    final case class UNDEFINED(override val toString: String) extends BrowserActionConfigurationDiscriminator

    val all: scala.List[BrowserActionConfigurationDiscriminator] = scala.List(CardBrowserActionConfiguration)

    private[this] val byName: Map[String, BrowserActionConfigurationDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): BrowserActionConfigurationDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[BrowserActionConfigurationDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait ConfirmationDetails extends _root_.scala.Product with _root_.scala.Serializable {
    def confirmationDetailsDiscriminator: ConfirmationDetailsDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type ConfirmationDetails
   */
  sealed trait ConfirmationDetailsDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ConfirmationDetailsDiscriminator {

    case object DirectDebit extends ConfirmationDetailsDiscriminator { override def toString = "direct_debit" }

    final case class UNDEFINED(override val toString: String) extends ConfirmationDetailsDiscriminator

    val all: scala.List[ConfirmationDetailsDiscriminator] = scala.List(DirectDebit)

    private[this] val byName: Map[String, ConfirmationDetailsDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ConfirmationDetailsDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ConfirmationDetailsDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait ExpandableCard extends _root_.scala.Product with _root_.scala.Serializable {
    def expandableCardDiscriminator: ExpandableCardDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type ExpandableCard
   */
  sealed trait ExpandableCardDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ExpandableCardDiscriminator {

    case object Card extends ExpandableCardDiscriminator { override def toString = "card" }
    case object CardReference extends ExpandableCardDiscriminator { override def toString = "card_reference" }
    case object CardSummary extends ExpandableCardDiscriminator { override def toString = "card_summary" }

    final case class UNDEFINED(override val toString: String) extends ExpandableCardDiscriminator

    val all: scala.List[ExpandableCardDiscriminator] = scala.List(Card, CardReference, CardSummary)

    private[this] val byName: Map[String, ExpandableCardDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExpandableCardDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExpandableCardDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Information about which payment processor performed the transaction and how it
   * can be tracked in their system
   */
  sealed trait ExpandablePaymentProcessor extends _root_.scala.Product with _root_.scala.Serializable {
    def expandablePaymentProcessorDiscriminator: ExpandablePaymentProcessorDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type ExpandablePaymentProcessor
   */
  sealed trait ExpandablePaymentProcessorDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ExpandablePaymentProcessorDiscriminator {

    case object PaymentProcessor extends ExpandablePaymentProcessorDiscriminator { override def toString = "payment_processor" }
    case object PaymentProcessorReference extends ExpandablePaymentProcessorDiscriminator { override def toString = "payment_processor_reference" }

    final case class UNDEFINED(override val toString: String) extends ExpandablePaymentProcessorDiscriminator

    val all: scala.List[ExpandablePaymentProcessorDiscriminator] = scala.List(PaymentProcessor, PaymentProcessorReference)

    private[this] val byName: Map[String, ExpandablePaymentProcessorDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExpandablePaymentProcessorDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExpandablePaymentProcessorDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait GatewayAuthenticationData extends _root_.scala.Product with _root_.scala.Serializable {
    def gatewayAuthenticationDataDiscriminator: GatewayAuthenticationDataDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type GatewayAuthenticationData
   */
  sealed trait GatewayAuthenticationDataDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object GatewayAuthenticationDataDiscriminator {

    case object StripeAuthenticationData extends GatewayAuthenticationDataDiscriminator { override def toString = "stripe_authentication_data" }

    final case class UNDEFINED(override val toString: String) extends GatewayAuthenticationDataDiscriminator

    val all: scala.List[GatewayAuthenticationDataDiscriminator] = scala.List(StripeAuthenticationData)

    private[this] val byName: Map[String, GatewayAuthenticationDataDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): GatewayAuthenticationDataDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[GatewayAuthenticationDataDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait GatewayAuthenticationDataForm extends _root_.scala.Product with _root_.scala.Serializable {
    def gatewayAuthenticationDataFormDiscriminator: GatewayAuthenticationDataFormDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type
   * GatewayAuthenticationDataForm
   */
  sealed trait GatewayAuthenticationDataFormDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object GatewayAuthenticationDataFormDiscriminator {

    case object StripeAuthenticationDataForm extends GatewayAuthenticationDataFormDiscriminator { override def toString = "stripe_authentication_data_form" }

    final case class UNDEFINED(override val toString: String) extends GatewayAuthenticationDataFormDiscriminator

    val all: scala.List[GatewayAuthenticationDataFormDiscriminator] = scala.List(StripeAuthenticationDataForm)

    private[this] val byName: Map[String, GatewayAuthenticationDataFormDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): GatewayAuthenticationDataFormDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[GatewayAuthenticationDataFormDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Configurations to support inline payment authentication experiences. Mobile to
   * be supported at a future date.
   */
  sealed trait InlineActionConfiguration extends _root_.scala.Product with _root_.scala.Serializable {
    def inlineActionConfigurationDiscriminator: InlineActionConfigurationDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type InlineActionConfiguration
   */
  sealed trait InlineActionConfigurationDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object InlineActionConfigurationDiscriminator {

    case object BrowserInlineActionConfiguration extends InlineActionConfigurationDiscriminator { override def toString = "browser_inline_action_configuration" }

    final case class UNDEFINED(override val toString: String) extends InlineActionConfigurationDiscriminator

    val all: scala.List[InlineActionConfigurationDiscriminator] = scala.List(BrowserInlineActionConfiguration)

    private[this] val byName: Map[String, InlineActionConfigurationDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): InlineActionConfigurationDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[InlineActionConfigurationDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait OnlineAuthorizationDetails extends _root_.scala.Product with _root_.scala.Serializable {
    def onlineAuthorizationDetailsDiscriminator: OnlineAuthorizationDetailsDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type OnlineAuthorizationDetails
   */
  sealed trait OnlineAuthorizationDetailsDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object OnlineAuthorizationDetailsDiscriminator {

    case object CryptopayAuthorizationDetails extends OnlineAuthorizationDetailsDiscriminator { override def toString = "cryptopay_authorization_details" }
    case object PaypalAuthorizationDetails extends OnlineAuthorizationDetailsDiscriminator { override def toString = "paypal_authorization_details" }
    case object RedirectAuthorizationDetails extends OnlineAuthorizationDetailsDiscriminator { override def toString = "redirect_authorization_details" }
    case object InlineAuthorizationDetails extends OnlineAuthorizationDetailsDiscriminator { override def toString = "inline_authorization_details" }

    final case class UNDEFINED(override val toString: String) extends OnlineAuthorizationDetailsDiscriminator

    val all: scala.List[OnlineAuthorizationDetailsDiscriminator] = scala.List(CryptopayAuthorizationDetails, PaypalAuthorizationDetails, RedirectAuthorizationDetails, InlineAuthorizationDetails)

    private[this] val byName: Map[String, OnlineAuthorizationDetailsDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OnlineAuthorizationDetailsDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OnlineAuthorizationDetailsDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Represents data for a specific online payment method
   */
  @deprecated("Remove after paypal_authorization_details goes live.")
  sealed trait Payment extends _root_.scala.Product with _root_.scala.Serializable {
    def paymentDiscriminator: PaymentDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type Payment
   */
  sealed trait PaymentDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  @deprecated("Remove after paypal_authorization_details goes live.")
  object PaymentDiscriminator {

    case object PaymentPaypal extends PaymentDiscriminator { override def toString = "payment_paypal" }
    case object PaymentCryptopay extends PaymentDiscriminator { override def toString = "payment_cryptopay" }

    final case class UNDEFINED(override val toString: String) extends PaymentDiscriminator

    val all: scala.List[PaymentDiscriminator] = scala.List(PaymentPaypal, PaymentCryptopay)

    private[this] val byName: Map[String, PaymentDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PaymentDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PaymentDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Represents the data needed to initiate an online payment
   */
  sealed trait PaymentForm extends _root_.scala.Product with _root_.scala.Serializable {
    def paymentFormDiscriminator: PaymentFormDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type PaymentForm
   */
  sealed trait PaymentFormDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object PaymentFormDiscriminator {

    case object MerchantOfRecordPaymentForm extends PaymentFormDiscriminator { override def toString = "merchant_of_record_payment_form" }

    final case class UNDEFINED(override val toString: String) extends PaymentFormDiscriminator

    val all: scala.List[PaymentFormDiscriminator] = scala.List(MerchantOfRecordPaymentForm)

    private[this] val byName: Map[String, PaymentFormDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PaymentFormDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PaymentFormDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Represents a source of payment that can be saved and used in the future.
   */
  sealed trait PaymentSource extends _root_.scala.Product with _root_.scala.Serializable {
    def paymentSourceDiscriminator: PaymentSourceDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type PaymentSource
   */
  sealed trait PaymentSourceDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object PaymentSourceDiscriminator {

    case object CardPaymentSource extends PaymentSourceDiscriminator { override def toString = "card_payment_source" }

    final case class UNDEFINED(override val toString: String) extends PaymentSourceDiscriminator

    val all: scala.List[PaymentSourceDiscriminator] = scala.List(CardPaymentSource)

    private[this] val byName: Map[String, PaymentSourceDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PaymentSourceDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PaymentSourceDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait PaymentSourceForm extends _root_.scala.Product with _root_.scala.Serializable {
    def paymentSourceFormDiscriminator: PaymentSourceFormDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type PaymentSourceForm
   */
  sealed trait PaymentSourceFormDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object PaymentSourceFormDiscriminator {

    case object CardPaymentSourceForm extends PaymentSourceFormDiscriminator { override def toString = "card_payment_source_form" }

    final case class UNDEFINED(override val toString: String) extends PaymentSourceFormDiscriminator

    val all: scala.List[PaymentSourceFormDiscriminator] = scala.List(CardPaymentSourceForm)

    private[this] val byName: Map[String, PaymentSourceFormDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PaymentSourceFormDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PaymentSourceFormDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Different version sets of 3ds challenge actions.
   */
  sealed trait ThreedsChallengeAction extends _root_.scala.Product with _root_.scala.Serializable {
    def threedsChallengeActionDiscriminator: ThreedsChallengeActionDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type ThreedsChallengeAction
   */
  sealed trait ThreedsChallengeActionDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ThreedsChallengeActionDiscriminator {

    /**
     * Used for 2.1 and 2.2 versions of 3ds
     */
    case object ThreedsTwoChallengeRequest extends ThreedsChallengeActionDiscriminator { override def toString = "threeds_two_challenge_request" }

    final case class UNDEFINED(override val toString: String) extends ThreedsChallengeActionDiscriminator

    val all: scala.List[ThreedsChallengeActionDiscriminator] = scala.List(ThreedsTwoChallengeRequest)

    private[this] val byName: Map[String, ThreedsChallengeActionDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ThreedsChallengeActionDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ThreedsChallengeActionDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Different version sets of 3ds identify actions.
   */
  sealed trait ThreedsIdentifyAction extends _root_.scala.Product with _root_.scala.Serializable {
    def threedsIdentifyActionDiscriminator: ThreedsIdentifyActionDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type ThreedsIdentifyAction
   */
  sealed trait ThreedsIdentifyActionDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ThreedsIdentifyActionDiscriminator {

    /**
     * Used for 2.1 and 2.2 versions of 3ds
     */
    case object ThreedsTwoMethod extends ThreedsIdentifyActionDiscriminator { override def toString = "threeds_two_method" }

    final case class UNDEFINED(override val toString: String) extends ThreedsIdentifyActionDiscriminator

    val all: scala.List[ThreedsIdentifyActionDiscriminator] = scala.List(ThreedsTwoMethod)

    private[this] val byName: Map[String, ThreedsIdentifyActionDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ThreedsIdentifyActionDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ThreedsIdentifyActionDiscriminator] = byName.get(value.toLowerCase)

  }
  /**
   * Used for initiating an ACH (Automated Clearing House) bank transfer.
   *
   * @param accountOwnerName The bank account holder name.
   * @param accountNumber The US bank account number from which the payment will be debited. The bank
   *        account number must be between 4 and 17 digits.
   * @param routingNumber The ABA routing transit number.
   * @param billingAddress Billing address
   * @param orderNumber Client order number for which to authorize payment.
   * @param amount The amount to authorize. If an order number is provided, it cannot exceed the
   *        order total.
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   * @param ip The IP address of the consumer
   */

  final case class AchAuthorizationForm(
    accountOwnerName: String,
    accountNumber: String,
    routingNumber: String,
    billingAddress: io.flow.common.v0.models.BillingAddress,
    orderNumber: _root_.scala.Option[String] = None,
    amount: BigDecimal,
    currency: String,
    key: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    ip: _root_.scala.Option[String] = None
  ) extends AuthorizationForm {
    override val authorizationFormDiscriminator: AuthorizationFormDiscriminator = AuthorizationFormDiscriminator.AchAuthorizationForm
  }

  /**
   * Data required to assist in challenging a customer natively.
   */

  final case class AdyenChallengeShopperData(
    challengeToken: String
  ) extends AdyenNativeData {
    override val adyenNativeDataDiscriminator: AdyenNativeDataDiscriminator = AdyenNativeDataDiscriminator.AdyenChallengeShopperData
  }

  /**
   * Data required to assist in identifying a customer natively.
   */

  final case class AdyenIdentifyShopperData(
    fingerprintToken: String
  ) extends AdyenNativeData {
    override val adyenNativeDataDiscriminator: AdyenNativeDataDiscriminator = AdyenNativeDataDiscriminator.AdyenIdentifyShopperData
  }

  /**
   * Provides details for how to acquire additional information from the customer
   * natively in the browser for Adyen (e.g. 3DS2)
   *
   * @param originKey An origin key is required for each domain where you are using our JavaScript
   *        libraries and from where you are initiating payments.
   * @param data The associated authorization result action native data, if any.
   */

  final case class AdyenNativeActionDetails(
    originKey: _root_.scala.Option[String] = None,
    data: _root_.scala.Option[io.flow.payment.v0.models.AdyenNativeData] = None
  ) extends AuthorizationResultActionDetails {
    override val authorizationResultActionDetailsDiscriminator: AuthorizationResultActionDetailsDiscriminator = AuthorizationResultActionDetailsDiscriminator.AdyenNativeActionDetails
  }

  /**
   * @param validationUrl Apple's server URL to validate the merchant and obtain a merchant session
   *        object, which will be sent back to frontend.
   * @param displayName The display name will appear in e.g. Touch Bar. A string of 64 or fewer UTF-8
   *        characters containing the canonical name for your store, suitable for display.
   *        Do not localize the name. Default value will be provided from database
   */

  final case class ApplePayMerchantValidationPayload(
    validationUrl: String,
    displayName: _root_.scala.Option[String] = None
  ) extends AuthorizationPayloadParameters {
    override val authorizationPayloadParametersDiscriminator: AuthorizationPayloadParametersDiscriminator = AuthorizationPayloadParametersDiscriminator.ApplePayMerchantValidationPayload
  }

  /**
   * Creates a new authorization based on the underlying information in an existing
   * authorization. A common use case here is to create a new auth when the existing
   * one has expired.
   *
   * @param sourceAuthorizationKey The key of the source authorization that we are copying
   * @param amount The amount to authorize
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   */

  final case class AuthorizationCopyForm(
    sourceAuthorizationKey: String,
    amount: BigDecimal,
    currency: String,
    attributes: _root_.scala.Option[Map[String, String]] = None
  ) extends AuthorizationForm {
    override val authorizationFormDiscriminator: AuthorizationFormDiscriminator = AuthorizationFormDiscriminator.AuthorizationCopyForm
  }

  /**
   * Details for why an authorization was not created
   *
   * @param code Specific reason for the error
   * @param avs Specific AVS information if applicable
   * @param cvv Specific CVV information if applicable
   */

  final case class AuthorizationError(
    code: io.flow.payment.v0.models.AuthorizationDeclineCode,
    messages: Seq[String],
    avs: _root_.scala.Option[io.flow.payment.v0.models.Avs] = None,
    cvv: _root_.scala.Option[io.flow.payment.v0.models.Cvv] = None
  )

  final case class AuthorizationOrderReference(
    number: String
  )

  /**
   * Used to complete an inline authorization like Google Pay or Apple Pay.
   */

  final case class AuthorizationPayload(
    parameters: io.flow.payment.v0.models.AuthorizationPayloadParameters
  )

  final case class AuthorizationReference(
    id: String,
    key: String,
    order: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationOrderReference] = None
  )

  /**
   * Contains the result of the authorization. If an immediate response is not
   * available, the state will be 'pending' - this usually indicates fraud review
   * requires additional time / verification (or a potential network issue with the
   * issuing bank).
   *
   * @param declineCode If status is declined, will contain the details behind the decline
   */

  final case class AuthorizationResult(
    status: io.flow.payment.v0.models.AuthorizationStatus,
    action: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationResultAction] = None,
    declineCode: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationDeclineCode] = None,
    avs: _root_.scala.Option[io.flow.payment.v0.models.Avs] = None,
    cvv: _root_.scala.Option[io.flow.payment.v0.models.Cvv] = None,
    threeDSecure: _root_.scala.Option[io.flow.payment.v0.models.ThreeDSecure] = None,
    description: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationResultDescription] = None
  )

  /**
   * Provides details for how to acquire additional information from the customer
   * using GET (e.g. redirecting to the issuer for online payment method or 3D
   * Secure).
   *
   * @param details The associated authorization result action details, if any.
   */

  final case class AuthorizationResultActionGet(
    `type`: io.flow.payment.v0.models.AuthorizationResultActionType,
    url: _root_.scala.Option[String] = None,
    details: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationResultActionDetails] = None
  ) extends AuthorizationResultAction {
    override val authorizationResultActionDiscriminator: AuthorizationResultActionDiscriminator = AuthorizationResultActionDiscriminator.AuthorizationResultActionGet
  }

  /**
   * Provides details for how to acquire additional information from the customer
   * natively in the browser (e.g. for 3D Secure 2).
   *
   * @param details The associated authorization result action details, if any.
   */

  final case class AuthorizationResultActionNative(
    `type`: io.flow.payment.v0.models.AuthorizationResultActionType,
    authorization: io.flow.payment.v0.models.AuthorizationReference,
    details: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationResultActionDetails] = None
  ) extends AuthorizationResultAction {
    override val authorizationResultActionDiscriminator: AuthorizationResultActionDiscriminator = AuthorizationResultActionDiscriminator.AuthorizationResultActionNative
  }

  /**
   * Provides details for how to acquire additional information from the customer
   * using POST (e.g. redirecting to the issuer for online payment method or 3D
   * Secure).
   *
   * @param url The URL to use for the POST request.
   * @param parameters Contains parameters that are required to be included as part of the request.
   */

  final case class AuthorizationResultActionPost(
    `type`: io.flow.payment.v0.models.AuthorizationResultActionType,
    url: String,
    parameters: _root_.play.api.libs.json.JsObject
  ) extends AuthorizationResultAction {
    override val authorizationResultActionDiscriminator: AuthorizationResultActionDiscriminator = AuthorizationResultActionDiscriminator.AuthorizationResultActionPost
  }

  /**
   * Indicates that a response is not ready and that the consumer should poll (or
   * wait) for a response.
   */

  final case class AuthorizationResultActionWait(
    `type`: io.flow.payment.v0.models.AuthorizationResultActionType
  ) extends AuthorizationResultAction {
    override val authorizationResultActionDiscriminator: AuthorizationResultActionDiscriminator = AuthorizationResultActionDiscriminator.AuthorizationResultActionWait
  }

  /**
   * @param display The default display text, e.g. 'VISA ending in 4700' or 'Payment with PayPal'.
   */

  final case class AuthorizationResultDescription(
    display: String
  )

  final case class AuthorizationVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    authorization: io.flow.payment.v0.models.Authorization
  )

  /**
   * Represents the address verification results
   *
   * @param name If available, indicates whether the cardholder's name matches.
   * @param address If available, indicates whether the cardholder's address matches.
   * @param postal If available, indicates whether the cardholder's postal code matches.
   */

  final case class Avs(
    code: io.flow.payment.v0.models.AvsCode,
    name: _root_.scala.Option[Boolean] = None,
    address: _root_.scala.Option[Boolean] = None,
    postal: _root_.scala.Option[Boolean] = None,
    description: _root_.scala.Option[String] = None
  )

  /**
   * Shopper browser info used as part of card authentication. All of these fields
   * are required if you are using 3DS2.
   *
   * @param origin The URL of the page where you are loading the 3d Secure 2 Component from. The
   *        origin should not include subdirectories and a trailing slash. You can also get
   *        this by calling window.location.origin.
   * @param language The navigator.language value of the shopper's browser (as defined in IETF BCP
   *        47).
   * @param javaEnabled Boolean value indicating if the shopper's browser is able to execute Java.
   * @param colorDepth The color depth of the shopper's browser in bits per pixel. This should be
   *        obtained by using the browser's screen.colorDepth property. Accepted values: 1,
   *        4, 8, 15, 16, 24, 32 or 48 bit color depth.
   * @param screenHeight The total height of the shopper's device screen in pixels.
   * @param screenWidth The total width of the shopper's device screen in pixels.
   * @param timeZoneOffset Time difference between UTC time and the shopper's browser local time, in
   *        minutes.
   * @param userAgent 'user-agent' header value. Will be taken from request headers if not provided.
   * @param accept 'accept' header value. Will be taken from request headers if not provided.
   */

  final case class BrowserInfo(
    origin: _root_.scala.Option[String] = None,
    language: _root_.scala.Option[String] = None,
    javaEnabled: _root_.scala.Option[Boolean] = None,
    colorDepth: _root_.scala.Option[Int] = None,
    screenHeight: _root_.scala.Option[Int] = None,
    screenWidth: _root_.scala.Option[Int] = None,
    timeZoneOffset: _root_.scala.Option[Int] = None,
    userAgent: _root_.scala.Option[String] = None,
    accept: _root_.scala.Option[String] = None
  )

  /**
   * Information to be passed to the payment processor about how to handle browser
   * inline authorization activities.
   *
   * @param inlineNotificationUrls Payment methods performed inside of a window or iframe may redirect to these
   *        urls (inside their frame). By handling redirections to these urls, the results
   *        of the inline authentication can be communicated back to the main browser
   *        window. If an inline authentication cannot be performed and a redirect action
   *        will occur, the redirect_urls will be used instead.
   */

  final case class BrowserInlineActionConfiguration(
    inlineNotificationUrls: io.flow.payment.v0.models.PostPaymentRedirectUrls,
    actionConfiguration: _root_.scala.Option[io.flow.payment.v0.models.BrowserActionConfiguration] = None
  ) extends InlineActionConfiguration {
    override val inlineActionConfigurationDiscriminator: InlineActionConfigurationDiscriminator = InlineActionConfigurationDiscriminator.BrowserInlineActionConfiguration
  }

  /**
   * Capture actually transfers funds. You can capture as many times as you'd like up
   * until the total amount of the authorization has been captured or the
   * authorization otherwise becomes unavailable (e.g. expires).
   *
   * @param amount The amount to capture in the currency of the associated authorization. If not
   *        specified, defaults to the full amount of the authorization (minus any prior
   *        captures).
   * @param currency Required if amount is specified. The ISO 4217-3 code for the currency. Case
   *        insensitive. See https://api.flow.io/reference/currencies
   * @param requested The requested amount/currency of the capture when created. We record this value
   *        as it will be converted to the currency of the authorization automatically if it
   *        does not match.
   * @param attributes A set of key/value pairs that you can attach to a capture object
   * @param status Indicates the status of the capture.
   * @param base The amount/currency of the capture in base currency. Added in Summer 2018 and
   *        always present since then.
   */

  final case class Capture(
    id: String,
    key: String,
    authorization: io.flow.payment.v0.models.AuthorizationReference,
    amount: BigDecimal,
    currency: String,
    requested: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    createdAt: _root_.org.joda.time.DateTime,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    status: io.flow.payment.v0.models.CaptureStatus = io.flow.payment.v0.models.CaptureStatus.Succeeded,
    base: _root_.scala.Option[io.flow.common.v0.models.Money] = None
  )

  /**
   * @param code To maintain compatibility with generic_error
   * @param messages To maintain compatibility with generic_error
   * @param declineCode Contains details related to the reason for which a capture failed.
   */

  final case class CaptureError(
    code: io.flow.error.v0.models.GenericErrorCode = io.flow.error.v0.models.GenericErrorCode.GenericError,
    messages: Seq[String],
    declineCode: io.flow.payment.v0.models.CaptureDeclineCode
  )

  /**
   * Capture actually transfers funds. You can capture as many times as you'd like up
   * until the total amount of the authorization has been captured or the
   * authorization otherwise becomes unavailable (e.g. expires).
   *
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param amount The amount to capture in the currency of the associated authorization. If not
   *        specified, defaults to the full amount of the authorization (minus any prior
   *        captures).
   * @param currency Required if amount is specified. The ISO 4217-3 code for the currency. Case
   *        insensitive. See https://api.flow.io/reference/currencies
   * @param attributes A set of key/value pairs that you can attach to a capture object
   */

  final case class CaptureForm(
    authorizationId: String,
    key: _root_.scala.Option[String] = None,
    amount: _root_.scala.Option[BigDecimal] = None,
    currency: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  final case class CaptureIdentifier(
    id: String,
    capture: io.flow.payment.v0.models.CaptureReference,
    name: String,
    identifier: String,
    primary: Boolean
  )

  final case class CaptureReference(
    id: String,
    key: String
  )

  final case class CaptureVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    capture: io.flow.payment.v0.models.Capture
  )

  /**
   * Card represents the metadata about a secure, tokenized card. The card 'token' is
   * a unique, cryptographically secure token by which this card can be identified in
   * the future. The card token itself will either be a permanent card token (denoted
   * by a prefix of F96) or a one time nonce (denoted by a prefix of F17). Nonces
   * represent cards that were encrypted from public channels (like the user's
   * browser via JavaScript) and can be used once only. If you have a nonce you can
   * exchange it for a permanent card token via the operation POST
   * /:organization/cards/nonces
   *
   * @param token Unique, cryptographically secure token by which this card can be identified in
   *        the future. This value should be kept secure in your system's as payment
   *        authorizations are created against this token.
   * @param iin The issuer identification number (IIN) (formerly known as the Bank
   *        Identification Number) which are the leading digits of the card number.
   * @param issuer Added in october 2018
   * @param last4 Cleartext last 4 numbers of the card
   * @param name Cardholder name
   * @param address Cardholder billing address
   */

  final case class Card(
    id: String,
    token: String,
    `type`: io.flow.payment.v0.models.CardType,
    expiration: io.flow.payment.v0.models.Expiration,
    iin: String,
    issuer: _root_.scala.Option[io.flow.payment.v0.models.IssuerSummary] = None,
    last4: String,
    name: String,
    address: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None
  ) extends ExpandableCard {
    override val expandableCardDiscriminator: ExpandableCardDiscriminator = ExpandableCardDiscriminator.Card
  }

  /**
   * An authorization is used to check and reserve funds w/ a given payment method.
   * No funds are actually transferred; once you have you an authorization, you can
   * capture up to the amount of the authorization.
   *
   * @param card If this authorization was made for a card payment method, this field will
   *        contain the details of the card used on the transaction
   * @param amount The amount to authorize
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param requested The amount/currency of the order when created.
   * @param customer The customer who is actually receiving the goods. Providing name and email at a
   *        minimum will significantly increase the acceptance rate and are recommended.
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   * @param destination Destination address, if relevant
   * @param billingAddress Destination address, if relevant
   * @param order If this authorization was made for a specific order number, that order will be
   *        referenced here
   * @param ip The IP address of the consumer
   * @param expiresAt The time at which this authorization expires, if any.
   * @param base The amount/currency of the authorization in base currency. Added in Summer 2018
   *        and always present since then.
   * @param processor Details about which payment processor was used for this authorization
   */

  final case class CardAuthorization(
    id: String,
    key: String,
    merchantOfRecord: io.flow.common.v0.models.MerchantOfRecord = io.flow.common.v0.models.MerchantOfRecord.Flow,
    method: _root_.scala.Option[io.flow.reference.v0.models.PaymentMethod] = None,
    card: io.flow.payment.v0.models.ExpandableCard,
    amount: BigDecimal,
    currency: String,
    requested: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    customer: io.flow.common.v0.models.OrderCustomer,
    attributes: Map[String, String],
    destination: _root_.scala.Option[io.flow.common.v0.models.Address] = None,
    billingAddress: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None,
    order: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationOrderReference] = None,
    ip: _root_.scala.Option[String] = None,
    result: io.flow.payment.v0.models.AuthorizationResult,
    createdAt: _root_.org.joda.time.DateTime,
    expiresAt: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    base: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    processor: _root_.scala.Option[io.flow.payment.v0.models.ExpandablePaymentProcessor] = None
  ) extends Authorization {
    override val authorizationDiscriminator: AuthorizationDiscriminator = AuthorizationDiscriminator.CardAuthorization
  }

  /**
   * Instructions to the card issuer to render challenges to the user
   */

  final case class CardBrowserActionConfiguration(
    viewport: io.flow.payment.v0.models.ThreedsTwoChallengeViewport = io.flow.payment.v0.models.ThreedsTwoChallengeViewport.XxxSmall
  ) extends BrowserActionConfiguration {
    override val browserActionConfigurationDiscriminator: BrowserActionConfigurationDiscriminator = BrowserActionConfigurationDiscriminator.CardBrowserActionConfiguration
  }

  /**
   * Details for why a card was not created
   *
   * @param code Specific reason for the error
   * @param avs Specific AVS information if applicable
   * @param cvv Specific CVV information if applicable
   */

  final case class CardError(
    code: io.flow.payment.v0.models.CardErrorCode,
    messages: Seq[String],
    avs: _root_.scala.Option[io.flow.payment.v0.models.Avs] = None,
    cvv: _root_.scala.Option[io.flow.payment.v0.models.Cvv] = None
  )

  /**
   * @param number Cleartext card number. You must provide either this field or 'cipher', but not
   *        both. May contain integers only or integers with dashes. If dashes are provided,
   *        we will remove them, storing only the raw number.
   * @param cipher Card number encrypted using your assigned public key. You must provide either
   *        this field or 'number', but not both. Card number itself may contain integers
   *        only or integers with dashes. If dashes are provided, we will remove them,
   *        storing only the raw number.
   * @param expirationMonth The month of expiration expressed as a number. 1 = January, 12 = December
   * @param expirationYear The 4 digit expiration year
   * @param name Cardholder name.
   * @param cvv The card verification number for the card that is used to verify the card
   *        details at creation time, making cvv optional for future payment authorizations.
   * @param address Cardholder billing address
   * @param ip The IP address of the consumer
   * @param challengeText When providing a cipher, you can optionally provide a challenge text and
   *        challenge cipher that will allow us to verify that client side encryption worked
   *        properly, returning better error messages in some cases. The Flow JavaScript API
   *        uses the challenge to verify that the asymmetric encryption is working properly
   *        in the client.
   * @param challengeCipher When providing a cipher, you can optionally provide a challenge text and
   *        challenge cipher that will allow us to verify that client side encryption worked
   *        properly, returning better error messages in some cases. The Flow JavaScript API
   *        uses the challenge to verify that the asymmetric encryption is working properly
   *        in the client.
   * @param tokenType Determines whether or not you want to create a permanent, tokenized card or a
   *        one time use token. By default, authenticated API requests create permanent
   *        tokens. Unauthenticated requests will create one-time tokens - and you will get
   *        an error if you try to create a permanent token via an unauthorized request.
   * @param requestedCurrency The ISO 4217-3 code for the currency at the time of card add. Used to verify
   *        that a card can process in a given currency, but is not used in the final
   *        authorization decision. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param metadata Metadata associated with the card.
   */

  final case class CardForm(
    number: _root_.scala.Option[String] = None,
    cipher: _root_.scala.Option[String] = None,
    expirationMonth: Int,
    expirationYear: Int,
    name: String,
    cvv: String,
    address: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None,
    ip: _root_.scala.Option[String] = None,
    challengeText: _root_.scala.Option[String] = None,
    challengeCipher: _root_.scala.Option[String] = None,
    tokenType: _root_.scala.Option[io.flow.payment.v0.models.TokenType] = None,
    requestedCurrency: _root_.scala.Option[String] = None,
    metadata: _root_.scala.Option[io.flow.payment.v0.models.CardMetadata] = None
  )

  final case class CardMetadata(
    merchantOfRecord: _root_.scala.Option[io.flow.common.v0.models.OrderMerchantOfRecord] = None
  )

  /**
   * The card nonce form presents a one time token to exchange server side for a
   * permanent, secure tokenized card
   *
   * @param token The one time card nonce to exchange for a permanent card token. This value will
   *        start with F17
   */

  final case class CardNonceForm(
    token: String
  )

  /**
   * Represents a saved credit card payment method.
   *
   * @param actions Indicates whether any additional actions are required to execute the payment.
   * @param summary Contains the card summary for display purposes, e.g. to show the last 4 digits
   *        and card brand when confirming a credit card.
   */

  final case class CardPaymentSource(
    id: String,
    actions: _root_.scala.Option[Seq[io.flow.payment.v0.models.PaymentSourceConfirmationAction]] = None,
    summary: io.flow.payment.v0.models.CardPaymentSourceSummary
  ) extends PaymentSource {
    override val paymentSourceDiscriminator: PaymentSourceDiscriminator = PaymentSourceDiscriminator.CardPaymentSource
  }

  /**
   * Creates an authorization for a transaction from a card payment source.
   *
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param cardPaymentSourceId The card payment source id.
   * @param orderNumber Client order number for which to authorize payment. We will automatically verify
   *        that this order exists and will authorize the total amount of the order in the
   *        currency of the order.
   * @param amount The amount to authorize
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param browserInfo Shopper browser info. If you are using 3DS2, this field is required.
   * @param inlineActionConfiguration This provides the information about how further additional actions might be
   *        handled so that they can be communicated in turn to the processor or issuer.
   */

  final case class CardPaymentSourceAuthorizationForm(
    key: _root_.scala.Option[String] = None,
    cardPaymentSourceId: String,
    orderNumber: String,
    amount: BigDecimal,
    currency: String,
    browserInfo: _root_.scala.Option[io.flow.payment.v0.models.BrowserInfo] = None,
    inlineActionConfiguration: _root_.scala.Option[io.flow.payment.v0.models.InlineActionConfiguration] = None
  ) extends AuthorizationForm {
    override val authorizationFormDiscriminator: AuthorizationFormDiscriminator = AuthorizationFormDiscriminator.CardPaymentSourceAuthorizationForm
  }

  /**
   * Contains a summary of a card, which is useful for displaying to a customer.
   *
   * @param customerNumber The number that uniquely identifies a customer.
   * @param cardId The card id associated with the source.
   */

  final case class CardPaymentSourceForm(
    customerNumber: String,
    cardId: String
  ) extends PaymentSourceForm {
    override val paymentSourceFormDiscriminator: PaymentSourceFormDiscriminator = PaymentSourceFormDiscriminator.CardPaymentSourceForm
  }

  /**
   * Contains a summary of a card, which is useful for displaying to a customer.
   *
   * @param customerNumber The number that uniquely identifies a customer.
   * @param card Card details associated with the payment source.
   */

  final case class CardPaymentSourceSummary(
    customerNumber: String,
    card: io.flow.payment.v0.models.CardSummary
  )

  final case class CardReference(
    id: String,
    token: String
  ) extends ExpandableCard {
    override val expandableCardDiscriminator: ExpandableCardDiscriminator = ExpandableCardDiscriminator.CardReference
  }

  /**
   * Card Summary is the card without the token
   *
   * @param iin The issuer identification number (IIN) (formerly known as the Bank
   *        Identification Number) which are the leading digits of the card number.
   * @param issuer Added in october 2018
   * @param last4 Cleartext last 4 numbers of the card
   * @param name Cardholder name
   * @param address Cardholder billing address
   */

  final case class CardSummary(
    id: String,
    `type`: io.flow.payment.v0.models.CardType,
    expiration: io.flow.payment.v0.models.Expiration,
    iin: String,
    issuer: _root_.scala.Option[io.flow.payment.v0.models.IssuerSummary] = None,
    last4: String,
    name: String,
    address: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None
  ) extends ExpandableCard {
    override val expandableCardDiscriminator: ExpandableCardDiscriminator = ExpandableCardDiscriminator.CardSummary
  }

  /**
   * @param token The token referring to a previously tokenized card.
   */

  final case class CardTokenForm(
    token: String
  )

  final case class CardVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    card: io.flow.payment.v0.models.Card
  )

  /**
   * Represents online payment
   *
   * @param paymentId The payment ID in CryptoPay.
   */

  final case class CryptopayAuthorizationDetails(
    paymentId: String
  ) extends OnlineAuthorizationDetails {
    override val onlineAuthorizationDetailsDiscriminator: OnlineAuthorizationDetailsDiscriminator = OnlineAuthorizationDetailsDiscriminator.CryptopayAuthorizationDetails
  }

  /**
   * Represents the card verification results
   */

  final case class Cvv(
    code: io.flow.payment.v0.models.CvvCode,
    description: _root_.scala.Option[String] = None
  )

  /**
   * Creates an authorization for a transaction in which you remain the merchant of
   * record. An authorization is used to check and reserve funds w/ a given payment
   * method. No funds are actually transferred; once you have you an authorization,
   * you can capture up to the amount of the authorization.
   *
   * @param token The token of the payment method to use when authorizing this transaction
   * @param amount The amount to authorize
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param customer The customer who is actually making the purchase. While optional, providing name
   *        and email at a minimum will significantly increase the acceptance rate.
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param cvv The card verification number. Note this number is never stored and thus is
   *        presented on each auth. Presenting the CVV may increase acceptance rates
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   * @param destination Destination address, if relevant
   * @param billingAddress Destination address, if relevant
   * @param ip The IP address of the consumer
   * @param options Optional behaviors to enable for this authorization
   * @param redirectUrls When using 3D Secure, this field specifies the success and optional failure URLs
   *        to which the user will be redirected after completing (or failing to complete)
   *        payment.
   * @param browserInfo Shopper browser info. If you are using 3DS2, this field is required.
   * @param inlineActionConfiguration This provides the information about how further additional actions might be
   *        handled so that they can be communicated in turn to the processor or issuer.
   */

  final case class DirectAuthorizationForm(
    token: String,
    amount: BigDecimal,
    currency: String,
    customer: _root_.scala.Option[io.flow.common.v0.models.OrderCustomer] = None,
    key: _root_.scala.Option[String] = None,
    cvv: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    destination: _root_.scala.Option[io.flow.common.v0.models.Address] = None,
    billingAddress: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None,
    ip: _root_.scala.Option[String] = None,
    options: _root_.scala.Option[Seq[io.flow.payment.v0.models.AuthorizationOption]] = None,
    redirectUrls: _root_.scala.Option[io.flow.payment.v0.models.PostPaymentRedirectUrls] = None,
    browserInfo: _root_.scala.Option[io.flow.payment.v0.models.BrowserInfo] = None,
    inlineActionConfiguration: _root_.scala.Option[io.flow.payment.v0.models.InlineActionConfiguration] = None
  ) extends AuthorizationForm {
    override val authorizationFormDiscriminator: AuthorizationFormDiscriminator = AuthorizationFormDiscriminator.DirectAuthorizationForm
  }

  /**
   * Represents an online direct debit payment.
   *
   * @param routingNumber Routing information for the customers bank
   * @param last4 The last 4 digits of the customers account number in cleartext
   */

  final case class DirectDebit(
    routingNumber: String,
    last4: String
  ) extends ConfirmationDetails {
    override val confirmationDetailsDiscriminator: ConfirmationDetailsDiscriminator = ConfirmationDetailsDiscriminator.DirectDebit
  }

  /**
   * The month and year at which a card expires
   *
   * @param month The month of expiration expressed as a number. 1 = January, 12 = December
   * @param year The 4 digit expiration year
   */

  final case class Expiration(
    month: Int,
    year: Int
  )

  /**
   * @param payload See io.flow.google.pay.v0.models.payment_data
   */

  final case class GooglePayAuthorizationPayload(
    payload: _root_.play.api.libs.json.JsObject
  ) extends AuthorizationPayloadParameters {
    override val authorizationPayloadParametersDiscriminator: AuthorizationPayloadParametersDiscriminator = AuthorizationPayloadParametersDiscriminator.GooglePayAuthorizationPayload
  }

  /**
   * @param primary A payment transaction can optionally have a single additional primary identifier
   *        - this identifier will be made available in billing to assist in reconciliation.
   *        If not specified, the first identifer created will automatically be marked the
   *        default
   * @param name A name to identify the source of this identifier
   */

  final case class IdentifierForm(
    primary: _root_.scala.Option[Boolean] = None,
    name: String
  )

  /**
   * Represents an online payment that requires the client token from underlying
   * payment processor before entering their payment information.
   *
   * @param id The id of the record containing expanded authorization details for this
   *        authorization.
   * @param clientToken The client token provided by underlying payment processor.
   */

  final case class InlineAuthorizationDetails(
    id: String,
    clientToken: _root_.scala.Option[String] = None,
    parameters: _root_.scala.Option[_root_.play.api.libs.json.JsObject] = None
  ) extends OnlineAuthorizationDetails {
    override val onlineAuthorizationDetailsDiscriminator: OnlineAuthorizationDetailsDiscriminator = OnlineAuthorizationDetailsDiscriminator.InlineAuthorizationDetails
  }

  /**
   * Executes a widget-based payment based on the provided payment method.
   *
   * @param method The name (or brand code) of the redirect-based payment method for which to
   *        create an authorization, e.g. 'unionpay'.
   * @param issuer The id of the issuing bank, if required by the selected payment method. For
   *        payment methods such as iDEAL, the customer must select an issuer before being
   *        redirected to provide payment details.
   * @param orderNumber Client order number for which to authorize payment.
   * @param amount The amount to authorize.
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param billingAddress Billing address
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   * @param ip The IP address of the consumer
   * @param payload If required, contains the payload used to complete the authorization (e.g. the
   *        token from Google Pay)
   */

  final case class InlineAuthorizationForm(
    method: String,
    issuer: _root_.scala.Option[io.flow.payment.v0.models.IssuerReference] = None,
    orderNumber: String,
    amount: BigDecimal,
    currency: String,
    billingAddress: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None,
    key: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    ip: _root_.scala.Option[String] = None,
    payload: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationPayload] = None
  ) extends AuthorizationForm {
    override val authorizationFormDiscriminator: AuthorizationFormDiscriminator = AuthorizationFormDiscriminator.InlineAuthorizationForm
  }

  final case class IssuerReference(
    id: String
  )

  /**
   * @param name The name of the organization that issued this card
   * @param country The country of the issuing bank. The ISO 3166-3 country code. Case insensitive.
   *        See https://api.flow.io/reference/countries
   */

  final case class IssuerSummary(
    iin: String,
    name: _root_.scala.Option[String] = None,
    country: _root_.scala.Option[String] = None
  )

  /**
   * @param name The name of the organization that issued this card
   * @param country The country of the issuing bank. The ISO 3166-3 country code. Case insensitive.
   *        See https://api.flow.io/reference/countries
   */

  @deprecated("Use issuer_summary")
  final case class IssuerV1(
    iin: String,
    cardBrand: String,
    cardType: _root_.scala.Option[String] = None,
    name: _root_.scala.Option[String] = None,
    country: _root_.scala.Option[String] = None
  )

  /**
   * Creates an authorization for a transaction for which Flow is the merchant of
   * record. In this case, you must provide your order number for a valid Flow order.
   * An authorization is used to check and reserve funds w/ a given payment method.
   * No funds are actually transferred; once you have you an authorization, you can
   * capture up to the amount of the authorization
   *
   * @param token The token of the payment method to use when authorizing this transaction
   * @param orderNumber Client order number for which to authorize payment. We will automatically verify
   *        that this order exists and will authorize the total amount of the order in the
   *        currency of the order.
   * @param amount The amount to authorize - if specified, will be used to confirm that the amount
   *        exactly matches the order total
   * @param currency Required if amount is specified. The ISO 4217-3 code for the currency. Case
   *        insensitive. See https://api.flow.io/reference/currencies
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param cvv The card verification number. Note this number is never stored and thus is
   *        presented on each auth. Presenting the CVV may increase acceptance rates
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   * @param ip The IP address of the consumer
   * @param options Optional behaviors to enable for this authorization
   * @param redirectUrls When using 3D Secure, this field specifies the success and optional failure URLs
   *        to which the user will be redirected after completing (or failing to complete)
   *        payment.
   * @param browserInfo Shopper browser info. If you are using 3DS2, this field is required.
   * @param inlineActionConfiguration This provides the information about how further additional actions might be
   *        handled so that they can be communicated in turn to the processor or issuer.
   */

  final case class MerchantOfRecordAuthorizationForm(
    token: String,
    orderNumber: String,
    amount: _root_.scala.Option[BigDecimal] = None,
    currency: _root_.scala.Option[String] = None,
    key: _root_.scala.Option[String] = None,
    cvv: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    ip: _root_.scala.Option[String] = None,
    options: _root_.scala.Option[Seq[io.flow.payment.v0.models.AuthorizationOption]] = None,
    redirectUrls: _root_.scala.Option[io.flow.payment.v0.models.PostPaymentRedirectUrls] = None,
    browserInfo: _root_.scala.Option[io.flow.payment.v0.models.BrowserInfo] = None,
    inlineActionConfiguration: _root_.scala.Option[io.flow.payment.v0.models.InlineActionConfiguration] = None
  ) extends AuthorizationForm {
    override val authorizationFormDiscriminator: AuthorizationFormDiscriminator = AuthorizationFormDiscriminator.MerchantOfRecordAuthorizationForm
  }

  /**
   * Creates an online payment
   *
   * @param orderNumber Client order number for which to authorize payment. We will automatically verify
   *        that this order exists and will authorize the total amount of the order in the
   *        currency of the order.
   * @param amount The amount to authorize - will be used to confirm that the amount exactly
   *        matches the order total
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   */

  final case class MerchantOfRecordPaymentForm(
    method: String,
    orderNumber: String,
    amount: BigDecimal,
    currency: String
  ) extends PaymentForm {
    override val paymentFormDiscriminator: PaymentFormDiscriminator = PaymentFormDiscriminator.MerchantOfRecordPaymentForm
  }

  /**
   * @param details The associated online authorization details, if any.
   * @param payment The associated online payment
   * @param amount The amount to authorize
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param requested The amount/currency of the order when created.
   * @param customer The customer who is actually receiving the goods. Providing name and email at a
   *        minimum will significantly increase the acceptance rate and are recommended.
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   * @param destination Destination address, if relevant
   * @param billingAddress Billing address, if relevant
   * @param order If this authorization was made for a specific order number, that order will be
   *        referenced here
   * @param ip The IP address of the consumer
   * @param expiresAt The time at which this authorization expires, if any.
   * @param base The amount/currency of the authorization in base currency. Added in Summer 2018
   *        and always present since then.
   * @param processor Details about which payment processor was used for this authorization
   */

  final case class OnlineAuthorization(
    id: String,
    key: String,
    method: _root_.scala.Option[io.flow.reference.v0.models.PaymentMethod] = None,
    merchantOfRecord: io.flow.common.v0.models.MerchantOfRecord = io.flow.common.v0.models.MerchantOfRecord.Flow,
    details: _root_.scala.Option[io.flow.payment.v0.models.OnlineAuthorizationDetails] = None,
    @deprecated("Remove after `method` and `details` fields are added to the authorization model.") payment: _root_.scala.Option[_root_.play.api.libs.json.JsObject] = None,
    amount: BigDecimal,
    currency: String,
    requested: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    customer: io.flow.common.v0.models.OrderCustomer,
    attributes: Map[String, String],
    destination: _root_.scala.Option[io.flow.common.v0.models.Address] = None,
    billingAddress: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None,
    order: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationOrderReference] = None,
    ip: _root_.scala.Option[String] = None,
    result: io.flow.payment.v0.models.AuthorizationResult,
    createdAt: _root_.org.joda.time.DateTime,
    expiresAt: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    base: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    processor: _root_.scala.Option[io.flow.payment.v0.models.ExpandablePaymentProcessor] = None
  ) extends Authorization {
    override val authorizationDiscriminator: AuthorizationDiscriminator = AuthorizationDiscriminator.OnlineAuthorization
  }

  /**
   * @param paymentId The payment id of the online authorization
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   */

  final case class OnlinePaymentAuthorizationForm(
    paymentId: String,
    key: _root_.scala.Option[String] = None
  ) extends AuthorizationForm {
    override val authorizationFormDiscriminator: AuthorizationFormDiscriminator = AuthorizationFormDiscriminator.OnlinePaymentAuthorizationForm
  }

  /**
   * Represents an online payment processed through CryptoPay.
   *
   * @param order If this authorization was made for a specific order number, that order will be
   *        referenced here.
   * @param amount The amount to authorize
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param cryptopay Specific data from CryptoPay.
   */

  final case class PaymentCryptopay(
    id: String,
    order: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationOrderReference] = None,
    amount: BigDecimal,
    currency: String,
    cryptopay: io.flow.payment.v0.models.OnlineAuthorizationDetails
  ) extends Payment {
    override val paymentDiscriminator: PaymentDiscriminator = PaymentDiscriminator.PaymentCryptopay
  }

  /**
   * Details for why a payment failed
   */

  final case class PaymentError(
    code: String = "payment_error",
    messages: Seq[String],
    codes: Seq[io.flow.payment.v0.models.PaymentErrorCode]
  )

  /**
   * Represents an online payment processed through PayPal.
   *
   * @param order If this authorization was made for a specific order number, that order will be
   *        referenced here.
   * @param amount The amount to authorize
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param paypal Specific data from PayPal.
   */

  @deprecated("Remove after paypal_authorization_details goes live.")
  final case class PaymentPaypal(
    id: String,
    order: _root_.scala.Option[io.flow.payment.v0.models.AuthorizationOrderReference] = None,
    amount: BigDecimal,
    currency: String,
    paypal: io.flow.payment.v0.models.OnlineAuthorizationDetails
  ) extends Payment {
    override val paymentDiscriminator: PaymentDiscriminator = PaymentDiscriminator.PaymentPaypal
  }

  /**
   * Information about which payment processor performed the transaction and how it
   * can be tracked in their system
   *
   * @param processor The name of the payment processor used for the transaction
   * @param operationIdentifier The identifier assigned by the payment processor to this operation
   * @param account Information about the payment processor account that was used for the operation
   */

  final case class PaymentProcessor(
    processor: String,
    operationIdentifier: _root_.scala.Option[io.flow.payment.v0.models.PaymentProcessorIdentifier] = None,
    account: _root_.scala.Option[io.flow.payment.v0.models.PaymentProcessorAccount] = None
  ) extends ExpandablePaymentProcessor {
    override val expandablePaymentProcessorDiscriminator: ExpandablePaymentProcessorDiscriminator = ExpandablePaymentProcessorDiscriminator.PaymentProcessor
  }

  /**
   * Information about an account with a payment processor
   *
   * @param organization The organization of the account in Flow
   * @param key The key of the account in Flow
   * @param identifier The identifier assigned by the payment processor to the account
   * @param parentAccount Information about the parent account that owns this account
   */

  final case class PaymentProcessorAccount(
    organization: String,
    key: String,
    identifier: io.flow.payment.v0.models.PaymentProcessorIdentifier,
    parentAccount: _root_.scala.Option[io.flow.payment.v0.models.PaymentProcessorAccountReference] = None
  )

  /**
   * @param organization The organization of the account in Flow
   * @param key The key of the account in Flow
   */

  final case class PaymentProcessorAccountReference(
    organization: String,
    key: String
  )

  /**
   * @param id The identifier of an operation or account in a payment processor's system
   * @param label How the identifier is described in the payment processor's system
   */

  final case class PaymentProcessorIdentifier(
    id: String,
    label: String
  )

  /**
   * @param processor The description of the payment processor used for the transaction
   */

  final case class PaymentProcessorReference(
    processor: String
  ) extends ExpandablePaymentProcessor {
    override val expandablePaymentProcessorDiscriminator: ExpandablePaymentProcessorDiscriminator = ExpandablePaymentProcessorDiscriminator.PaymentProcessorReference
  }

  final case class PaymentReference(
    id: String
  )

  /**
   * Represents confirmation details & any additional confirmation actions required
   * to execute the payment.
   *
   * @param `type` Indicates the type of action to take before the source can be used.
   */

  final case class PaymentSourceConfirmationAction(
    `type`: io.flow.payment.v0.models.PaymentSourceConfirmationActionType
  )

  final case class PaymentVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    payment: io.flow.payment.v0.models.Payment
  )

  /**
   * Represents online payment
   *
   * @param paymentId The payment ID in PayPal.
   * @param paymentMethod The payment method used by the payer within PayPal.
   * @param paymentState The state of the payment, authorization, or order transaction.
   * @param payerEmail The payer's email address.
   * @param payerStatus The status of payer's PayPal account.
   */

  final case class PaypalAuthorizationDetails(
    paymentId: String,
    paymentMethod: _root_.scala.Option[String] = None,
    paymentState: _root_.scala.Option[String] = None,
    payerEmail: _root_.scala.Option[String] = None,
    payerStatus: _root_.scala.Option[String] = None
  ) extends OnlineAuthorizationDetails {
    override val onlineAuthorizationDetailsDiscriminator: OnlineAuthorizationDetailsDiscriminator = OnlineAuthorizationDetailsDiscriminator.PaypalAuthorizationDetails
  }

  /**
   * Executes the PayPal payment
   *
   * @param paypalPaymentId The PayPal payment id
   * @param paypalPayerId The PayPal id of the person who is paying
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   * @param ip The IP address of the consumer
   */

  final case class PaypalAuthorizationForm(
    paypalPaymentId: String,
    paypalPayerId: String,
    key: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    ip: _root_.scala.Option[String] = None
  ) extends AuthorizationForm {
    override val authorizationFormDiscriminator: AuthorizationFormDiscriminator = AuthorizationFormDiscriminator.PaypalAuthorizationForm
  }

  /**
   * The URLs to which the customer will be redirected based on the authorization
   * status.
   */

  final case class PostPaymentRedirectUrls(
    success: String,
    failure: _root_.scala.Option[String] = None
  )

  /**
   * A public key is used to encrypt cards client side prior to submitting to the
   * Flow vault.
   *
   * @param id RSA Public Key, base 64 encoded
   */

  final case class PublicKey(
    id: String
  )

  /**
   * Represents an online payment that requires the user to redirect to another site
   * before entering their payment information.
   *
   * @param id The id of the record containing expanded authorization details for this
   *        authorization.
   * @param paymentRedirectUrl The URL to which the customer should be redirected to complete payment.
   * @param confirmationDetails Confirmation details received from the redirect response
   */

  final case class RedirectAuthorizationDetails(
    id: String,
    paymentRedirectUrl: String,
    confirmationDetails: _root_.scala.Option[io.flow.payment.v0.models.ConfirmationDetails] = None
  ) extends OnlineAuthorizationDetails {
    override val onlineAuthorizationDetailsDiscriminator: OnlineAuthorizationDetailsDiscriminator = OnlineAuthorizationDetailsDiscriminator.RedirectAuthorizationDetails
  }

  /**
   * Executes a redirect-based payment based on the provided payment method.
   *
   * @param method The name (or brand code) of the redirect-based payment method for which to
   *        create an authorization, e.g. 'unionpay'.
   * @param issuer The id of the issuing bank, if required by the selected payment method. For
   *        payment methods such as iDEAL, the customer must select an issuer before being
   *        redirected to provide payment details.
   * @param orderNumber Client order number for which to authorize payment.
   * @param amount The amount to authorize.
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param redirectUrls The success and optional failure URLs to which the user will be redirected after
   *        completing (or failing to complete) payment.
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param attributes A set of key/value pairs that you can attach to an authorization object
   * @param ip The IP address of the consumer
   */

  final case class RedirectAuthorizationForm(
    method: String,
    issuer: _root_.scala.Option[io.flow.payment.v0.models.IssuerReference] = None,
    orderNumber: String,
    amount: BigDecimal,
    currency: String,
    redirectUrls: io.flow.payment.v0.models.PostPaymentRedirectUrls,
    key: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    ip: _root_.scala.Option[String] = None
  ) extends AuthorizationForm {
    override val authorizationFormDiscriminator: AuthorizationFormDiscriminator = AuthorizationFormDiscriminator.RedirectAuthorizationForm
  }

  /**
   * Refunds can be created against either a specific capture or an authorization (in
   * which case we will select 1 or more specific captures against which to execute
   * the refund).
   *
   * @param amount The amount to refund in the currency of the associated capture
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param requested The amount/currency of the request to refund.
   * @param captures The specific captures and the amounts refunded against each to match the total
   *        refund amount.
   * @param attributes A set of key/value pairs that you can attach to a refund object
   * @param status Indicates the status of the refund.
   * @param base The amount/currency of the refund in base currency. Added in Summer 2018 and
   *        always present since then.
   */

  final case class Refund(
    id: String,
    key: String,
    authorization: io.flow.payment.v0.models.AuthorizationReference,
    amount: BigDecimal,
    currency: String,
    requested: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    captures: Seq[io.flow.payment.v0.models.RefundCaptureSummary],
    createdAt: _root_.org.joda.time.DateTime,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    status: io.flow.payment.v0.models.RefundStatus = io.flow.payment.v0.models.RefundStatus.Succeeded,
    base: _root_.scala.Option[io.flow.common.v0.models.Money] = None
  )

  /**
   * Refund captures provide the detailed information on the amount refunded against
   * a specific capture
   *
   * @param amount The amount refunded against this capture, in the currency of the refund
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param status Indicates the status of the refund capture.
   */

  final case class RefundCapture(
    id: String,
    refund: io.flow.payment.v0.models.Refund,
    capture: io.flow.payment.v0.models.Capture,
    amount: BigDecimal,
    currency: String,
    base: io.flow.common.v0.models.Money,
    status: io.flow.payment.v0.models.RefundStatus = io.flow.payment.v0.models.RefundStatus.Succeeded
  )

  /**
   * Refund captures provide the detailed information on the amount refunded against
   * a specific capture
   *
   * @param amount The amount refunded against this capture, in the currency of the refund
   */

  final case class RefundCaptureSummary(
    capture: io.flow.payment.v0.models.Capture,
    amount: BigDecimal
  )

  /**
   * @param code To maintain compatibility with generic_error
   * @param messages To maintain compatibility with generic_error
   * @param declineCode Contains details related to the reason for which a refund failed.
   */

  final case class RefundError(
    code: io.flow.error.v0.models.GenericErrorCode = io.flow.error.v0.models.GenericErrorCode.GenericError,
    messages: Seq[String],
    declineCode: io.flow.payment.v0.models.RefundDeclineCode
  )

  /**
   * Refund actually transfers funds. You can refund as many times as you'd like up
   * until the total amount of captured funds has been refunded. Note when creating a
   * refund you can specify either an order authorization id, a capture id, or an
   * order number (or all of them as long as they match).
   *
   * @param authorizationId The Id of the authorization against which to issue the refund. If specified, we
   *        will look at all captures for this authorization, selecting 1 or more captures
   *        against which to issue the refund of the requested amount.
   * @param captureId The Id of the capture against which to issue the refund. If specified, we will
   *        only consider this capture.
   * @param orderNumber The order number if specified during authorization. If specified, we will lookup
   *        all authorizations made against this order number, and then selecting 1 or more
   *        authorizations against which to issue the refund of the requested amount.
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param amount The amount to refund, in the currency of the associated capture. Defaults to the
   *        value of the capture minus any prior refunds.
   * @param currency The ISO 4217-3 code for the currency. Required if amount is specified. Case
   *        insensitive. Note you will get an error if the currency does not match the
   *        related authorization's currency. See https://api.flow.io/reference/currencies
   * @param rmaKey The RMA key, if available. If specified, this will update the RMA status as
   *        refunded.
   * @param attributes A set of key/value pairs that you can attach to a refund object
   */

  final case class RefundForm(
    authorizationId: _root_.scala.Option[String] = None,
    captureId: _root_.scala.Option[String] = None,
    orderNumber: _root_.scala.Option[String] = None,
    key: _root_.scala.Option[String] = None,
    amount: _root_.scala.Option[BigDecimal] = None,
    currency: _root_.scala.Option[String] = None,
    rmaKey: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  final case class RefundIdentifier(
    id: String,
    refund: io.flow.payment.v0.models.RefundReference,
    name: String,
    identifier: String,
    primary: Boolean
  )

  /**
   * For merchant of record authorizations, we provide a summary of refund
   * information primarily to support customer service workflow.
   *
   * @param orderNumber Client order number
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param captured The total amount of funds captured for this order. If there were multiple
   *        captures, this number will include the sum of the amounts captured.
   * @param refunded The total amount of refunds issued for this order. If there were multiple
   *        refunds, this number will include the sum of the amounts refunded.
   * @param amounts Suggested amounts to refund based on the most common use cases
   */

  final case class RefundOrderSummary(
    orderNumber: String,
    currency: String,
    captured: BigDecimal,
    refunded: BigDecimal,
    amounts: io.flow.payment.v0.models.RefundOrderSummaryAmounts
  )

  /**
   * Detailed examples of amount to refund following common e-commerce use cases.
   *
   * @param balance The total amount of funds available to refund (sum of all captures minus all
   *        prior refunds).
   * @param balanceExcludingShipping The balance minus shipping costs. If there was either no shipping cost or the
   *        remaining balance is less than the shipping cost, this field will not be
   *        provided.
   * @param shipping The total amount of shipping on the order, if there was a shipping fee. We
   *        highlight this value separately to simplify use cases where a full refund minus
   *        shipping is used.
   */

  final case class RefundOrderSummaryAmounts(
    balance: BigDecimal,
    balanceExcludingShipping: _root_.scala.Option[BigDecimal] = None,
    shipping: _root_.scala.Option[BigDecimal] = None
  )

  final case class RefundReference(
    id: String,
    key: String
  )

  final case class RefundVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    refund: io.flow.payment.v0.models.Refund
  )

  /**
   * A reversal is used to clear an authorization (full or partial).
   *
   * @param authorization The authorization that this reversal undoes
   * @param amount The amount reversed
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param requested The requested amount/currency of the capture when created. We record this value
   *        as it will be converted to the currency of the authorization automatically if it
   *        does not match.
   * @param attributes A set of key/value pairs that you can attach to a reversal object
   * @param base The amount/currency of the reversal in base currency. Added in Summer 2018 and
   *        always present since then.
   */

  final case class Reversal(
    id: String,
    key: String,
    authorization: io.flow.payment.v0.models.AuthorizationReference,
    status: io.flow.payment.v0.models.ReversalStatus,
    amount: BigDecimal,
    currency: String,
    requested: io.flow.common.v0.models.Money,
    createdAt: _root_.org.joda.time.DateTime,
    attributes: Map[String, String],
    base: _root_.scala.Option[io.flow.common.v0.models.Money] = None
  )

  /**
   * Details for why a reversal could not be created
   */

  final case class ReversalError(
    code: String = "reversal_error",
    messages: Seq[String],
    codes: Seq[io.flow.payment.v0.models.ReversalErrorCode]
  )

  /**
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency. If not provided, we will assign.
   * @param authorizationId The ID of the authorization to reverse.
   * @param amount The amount to reverse. If not specified, reverse the full or remaining amount.
   * @param currency The ISO 4217-3 code for the currency to reverse. Required if amount is provided.
   *        Case insensitive. See https://api.flow.io/reference/currencies
   * @param attributes A set of key/value pairs that you can attach to a reversal object
   */

  final case class ReversalForm(
    key: _root_.scala.Option[String] = None,
    authorizationId: String,
    amount: _root_.scala.Option[BigDecimal] = None,
    currency: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * @param authorizationId The ID of the authorization to reverse.
   * @param amount The amount to reverse. If not specified, reverse the full or remaining amount.
   * @param currency The ISO 4217-3 code for the currency to reverse. Required if amount is provided.
   *        Case insensitive. See https://api.flow.io/reference/currencies
   * @param attributes A set of key/value pairs that you can attach to a reversal object
   */

  final case class ReversalPutForm(
    authorizationId: String,
    amount: _root_.scala.Option[BigDecimal] = None,
    currency: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  final case class ReversalVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    reversal: io.flow.payment.v0.models.Reversal
  )

  /**
   * Stripe authentication data.
   *
   * @param secretKeyReference Reference to Stripe API secret key.
   */

  final case class StripeAuthenticationData(
    secretKeyReference: String
  ) extends GatewayAuthenticationData {
    override val gatewayAuthenticationDataDiscriminator: GatewayAuthenticationDataDiscriminator = GatewayAuthenticationDataDiscriminator.StripeAuthenticationData
  }

  /**
   * Used to specify Stripe API secret key.
   *
   * @param accountId Stripe account id.
   * @param secretKey Stripe API secret key.
   * @param key Used to identify an account within an organization, specifically when specifying
   *        account selection rules. Defaults to account id if not specified.
   */

  final case class StripeAuthenticationDataForm(
    accountId: String,
    secretKey: String,
    key: _root_.scala.Option[String] = None
  ) extends GatewayAuthenticationDataForm {
    override val gatewayAuthenticationDataFormDiscriminator: GatewayAuthenticationDataFormDiscriminator = GatewayAuthenticationDataFormDiscriminator.StripeAuthenticationDataForm
  }

  /**
   * Provides details for Stripe authorizations (e.g. client secret to be used for 3D
   * Secure).
   *
   * @param clientSecret The client secret of this PaymentIntent. Used for client-side retrieval using a
   *        publishable key.
   * @param paymentMethodId ID of the payment method used in this PaymentIntent.
   * @param publishableKey The publishable key used to initialize Stripe-related objects on the client.
   */

  final case class StripeAuthorizationResultActionDetails(
    clientSecret: _root_.scala.Option[String] = None,
    paymentMethodId: _root_.scala.Option[String] = None,
    publishableKey: _root_.scala.Option[String] = None
  ) extends AuthorizationResultActionDetails {
    override val authorizationResultActionDetailsDiscriminator: AuthorizationResultActionDetailsDiscriminator = AuthorizationResultActionDetailsDiscriminator.StripeAuthorizationResultActionDetails
  }

  /**
   * Represents the results from 3D Secure, if applied to an authorization
   */

  final case class ThreeDSecure(
    code: io.flow.payment.v0.models.ThreeDSecureCode,
    description: _root_.scala.Option[String] = None
  )

  /**
   * Information necessary to perform a 3ds Challenge action inline to the user
   * experience.
   *
   * @param expiresAt If the authorization status or result action has not updated by this time, the
   *        UI should consider the authorization expired.
   */

  final case class ThreedsChallengeActionDetails(
    threedsChallengeAction: io.flow.payment.v0.models.ThreedsChallengeAction,
    expiresAt: _root_.org.joda.time.DateTime
  ) extends AuthorizationResultActionDetails {
    override val authorizationResultActionDetailsDiscriminator: AuthorizationResultActionDetailsDiscriminator = AuthorizationResultActionDetailsDiscriminator.ThreedsChallengeActionDetails
  }

  /**
   * Information necessary to perform a 3ds Identify action inline to the user
   * experience.
   *
   * @param expiresAt If the authorization status or result action has not updated by this time, the
   *        UI should consider the authorization expired.
   */

  final case class ThreedsIdentifyActionDetails(
    threedsIdentifyAction: io.flow.payment.v0.models.ThreedsIdentifyAction,
    expiresAt: _root_.org.joda.time.DateTime
  ) extends AuthorizationResultActionDetails {
    override val authorizationResultActionDetailsDiscriminator: AuthorizationResultActionDetailsDiscriminator = AuthorizationResultActionDetailsDiscriminator.ThreedsIdentifyActionDetails
  }

  /**
   * Data that must be passed to the 3DS Client to help the issuer ACS render a
   * challenge for the user.
   *
   * @param acsUrl The URL of the issuer ACS. The following parameters should be posted to that url
   *        to initiate the challenge.
   * @param challengeRequest base64 url encoded data used by the issuer's ACS to initiate a challenge (CReq).
   *        Contains an encoded json with transactions ids, 3ds version information, and
   *        rendering options.
   * @param sessionData Additional data from the ACS to help it maintain continuity of the user's
   *        session during the challenge.
   */

  final case class ThreedsTwoChallengeRequest(
    acsUrl: String,
    challengeRequest: String,
    sessionData: _root_.scala.Option[String] = None
  ) extends ThreedsChallengeAction {
    override val threedsChallengeActionDiscriminator: ThreedsChallengeActionDiscriminator = ThreedsChallengeActionDiscriminator.ThreedsTwoChallengeRequest
  }

  /**
   * Data that must be rendered by the 3DS Client in order to help the issuer ACS
   * silently identify the user. This format doesn't decompose the ACS identify
   * method.
   *
   * @param method Stringified HTML tags (3DS Method). They usually instantiate a hidden iframe for
   *        the ACS and post an encoded json containing the transaction id and end
   *        notification url.
   */

  final case class ThreedsTwoMethod(
    method: String
  ) extends ThreedsIdentifyAction {
    override val threedsIdentifyActionDiscriminator: ThreedsIdentifyActionDiscriminator = ThreedsIdentifyActionDiscriminator.ThreedsTwoMethod
  }

  /**
   * Virtual credit cards are created for a specific limit and currency. Currently
   * only USD denominated cards can be issued. Once created the virtual card can be
   * used in the same way as a physical credit card using the card number, cvv and
   * expiration details.
   *
   * @param id Globally unique identifier generated by Flow for this virtual card.
   * @param key Your unique identifier for this transaction, which if provided is used to
   *        implement idempotency.
   * @param number The actual card number. This will be populated on the first request but not
   *        returned for subsequent requests for the same card. The card number is not
   *        persisted to maintain PCI compliance.
   * @param cvv The short card verification value. This will be populated on the first request
   *        but not returned for subsequent requests for the same card. The cvv is not
   *        persisted to maintain PCI compliance.
   * @param limit The virtual card limit amount in USD.
   * @param `type` The virtual card brand type.
   * @param expiration The expiry date as would be displayed on the card. Note that internally the card
   *        may be valid for a shorter period of time.
   * @param iin The issuer identification number (IIN) (formerly known as the Bank
   *        Identification Number) which are the leading digits of the card number.
   * @param last4 Cleartext last 4 numbers of the card
   * @param name Cardholder name
   * @param attributes A set of key/value pairs that you can attach to a virtual card object
   */

  final case class VirtualCard(
    id: String,
    key: String,
    number: _root_.scala.Option[String] = None,
    cvv: _root_.scala.Option[String] = None,
    limit: io.flow.common.v0.models.Price,
    `type`: io.flow.payment.v0.models.CardType,
    expiration: io.flow.payment.v0.models.Expiration,
    iin: String,
    last4: String,
    name: String,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * Payment has been captured for the virtual credit card
   *
   * @param issuer The virtual credit card issuing bank details.
   * @param virtualCard Flows reference identifier for the virtual credit card.
   * @param authorization Flows payment authorization details.
   * @param amount The amount of the virtual card capture in the specified currency.
   * @param currency The ISO 4217-3 code for the currency. See
   *        https://api.flow.io/reference/currencies
   */

  final case class VirtualCardCapture(
    id: String,
    issuer: io.flow.payment.v0.models.IssuerV1,
    virtualCard: io.flow.payment.v0.models.VirtualCardReference,
    authorization: io.flow.payment.v0.models.AuthorizationReference,
    amount: BigDecimal,
    currency: String,
    createdAt: _root_.org.joda.time.DateTime
  )

  final case class VirtualCardCaptureVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    virtualCardCapture: io.flow.payment.v0.models.VirtualCardCapture
  )

  /**
   * @param limit The requested limit of the card
   * @param attributes A set of key/value pairs that you can attach to a virtual card object
   */

  final case class VirtualCardForm(
    limit: io.flow.common.v0.models.Money,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * Flows reference identifier for the virtual credit card.
   */

  final case class VirtualCardReference(
    id: String
  )

  /**
   * A refund has been issued for the virtual credit card
   *
   * @param issuer The virtual credit card issuing bank details.
   * @param virtualCard Flows reference identifier for the virtual credit card.
   * @param authorization Flows payment authorization details.
   * @param amount The amount of the virtual card refund in the specified currency
   * @param currency The ISO 4217-3 code for the currency. See
   *        https://api.flow.io/reference/currencies
   */

  final case class VirtualCardRefund(
    id: String,
    issuer: io.flow.payment.v0.models.IssuerV1,
    virtualCard: io.flow.payment.v0.models.VirtualCardReference,
    authorization: io.flow.payment.v0.models.AuthorizationReference,
    amount: BigDecimal,
    currency: String,
    createdAt: _root_.org.joda.time.DateTime
  )

  final case class VirtualCardRefundVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    virtualCardRefund: io.flow.payment.v0.models.VirtualCardRefund
  )

  final case class VirtualCardVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    virtualCard: io.flow.payment.v0.models.VirtualCard
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union AdyenNativeData, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class AdyenNativeDataUndefinedType(
    description: String
  ) extends AdyenNativeData {
    override val adyenNativeDataDiscriminator: AdyenNativeDataDiscriminator = AdyenNativeDataDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union Authorization, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class AuthorizationUndefinedType(
    description: String
  ) extends Authorization {
    override val authorizationDiscriminator: AuthorizationDiscriminator = AuthorizationDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union AuthorizationForm, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class AuthorizationFormUndefinedType(
    description: String
  ) extends AuthorizationForm {
    override val authorizationFormDiscriminator: AuthorizationFormDiscriminator = AuthorizationFormDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union AuthorizationPayloadParameters, it will need to be handled in the
   * client code. This implementation will deserialize these future types as an
   * instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class AuthorizationPayloadParametersUndefinedType(
    description: String
  ) extends AuthorizationPayloadParameters {
    override val authorizationPayloadParametersDiscriminator: AuthorizationPayloadParametersDiscriminator = AuthorizationPayloadParametersDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union AuthorizationResultAction, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class AuthorizationResultActionUndefinedType(
    description: String
  ) extends AuthorizationResultAction {
    override val authorizationResultActionDiscriminator: AuthorizationResultActionDiscriminator = AuthorizationResultActionDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union AuthorizationResultActionDetails, it will need to be handled in the
   * client code. This implementation will deserialize these future types as an
   * instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class AuthorizationResultActionDetailsUndefinedType(
    description: String
  ) extends AuthorizationResultActionDetails {
    override val authorizationResultActionDetailsDiscriminator: AuthorizationResultActionDetailsDiscriminator = AuthorizationResultActionDetailsDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union BrowserActionConfiguration, it will need to be handled in the
   * client code. This implementation will deserialize these future types as an
   * instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class BrowserActionConfigurationUndefinedType(
    description: String
  ) extends BrowserActionConfiguration {
    override val browserActionConfigurationDiscriminator: BrowserActionConfigurationDiscriminator = BrowserActionConfigurationDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ConfirmationDetails, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class ConfirmationDetailsUndefinedType(
    description: String
  ) extends ConfirmationDetails {
    override val confirmationDetailsDiscriminator: ConfirmationDetailsDiscriminator = ConfirmationDetailsDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableCard, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class ExpandableCardUndefinedType(
    description: String
  ) extends ExpandableCard {
    override val expandableCardDiscriminator: ExpandableCardDiscriminator = ExpandableCardDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandablePaymentProcessor, it will need to be handled in the
   * client code. This implementation will deserialize these future types as an
   * instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class ExpandablePaymentProcessorUndefinedType(
    description: String
  ) extends ExpandablePaymentProcessor {
    override val expandablePaymentProcessorDiscriminator: ExpandablePaymentProcessorDiscriminator = ExpandablePaymentProcessorDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union GatewayAuthenticationData, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class GatewayAuthenticationDataUndefinedType(
    description: String
  ) extends GatewayAuthenticationData {
    override val gatewayAuthenticationDataDiscriminator: GatewayAuthenticationDataDiscriminator = GatewayAuthenticationDataDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union GatewayAuthenticationDataForm, it will need to be handled in the
   * client code. This implementation will deserialize these future types as an
   * instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class GatewayAuthenticationDataFormUndefinedType(
    description: String
  ) extends GatewayAuthenticationDataForm {
    override val gatewayAuthenticationDataFormDiscriminator: GatewayAuthenticationDataFormDiscriminator = GatewayAuthenticationDataFormDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union InlineActionConfiguration, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class InlineActionConfigurationUndefinedType(
    description: String
  ) extends InlineActionConfiguration {
    override val inlineActionConfigurationDiscriminator: InlineActionConfigurationDiscriminator = InlineActionConfigurationDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union OnlineAuthorizationDetails, it will need to be handled in the
   * client code. This implementation will deserialize these future types as an
   * instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class OnlineAuthorizationDetailsUndefinedType(
    description: String
  ) extends OnlineAuthorizationDetails {
    override val onlineAuthorizationDetailsDiscriminator: OnlineAuthorizationDetailsDiscriminator = OnlineAuthorizationDetailsDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union Payment, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class PaymentUndefinedType(
    description: String
  ) extends Payment {
    override val paymentDiscriminator: PaymentDiscriminator = PaymentDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union PaymentForm, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class PaymentFormUndefinedType(
    description: String
  ) extends PaymentForm {
    override val paymentFormDiscriminator: PaymentFormDiscriminator = PaymentFormDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union PaymentSource, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class PaymentSourceUndefinedType(
    description: String
  ) extends PaymentSource {
    override val paymentSourceDiscriminator: PaymentSourceDiscriminator = PaymentSourceDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union PaymentSourceForm, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class PaymentSourceFormUndefinedType(
    description: String
  ) extends PaymentSourceForm {
    override val paymentSourceFormDiscriminator: PaymentSourceFormDiscriminator = PaymentSourceFormDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ThreedsChallengeAction, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class ThreedsChallengeActionUndefinedType(
    description: String
  ) extends ThreedsChallengeAction {
    override val threedsChallengeActionDiscriminator: ThreedsChallengeActionDiscriminator = ThreedsChallengeActionDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ThreedsIdentifyAction, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class ThreedsIdentifyActionUndefinedType(
    description: String
  ) extends ThreedsIdentifyAction {
    override val threedsIdentifyActionDiscriminator: ThreedsIdentifyActionDiscriminator = ThreedsIdentifyActionDiscriminator.UNDEFINED(description)
  }
  /**
   * Contains details related to the reason for which an authorization was declined.
   */
  sealed trait AuthorizationDeclineCode extends _root_.scala.Product with _root_.scala.Serializable

  object AuthorizationDeclineCode {

    /**
     * Payment method has expired
     */
    case object Expired extends AuthorizationDeclineCode {
      override def toString = "expired"
    }
    /**
     * Invalid card holder name
     */
    case object InvalidName extends AuthorizationDeclineCode {
      override def toString = "invalid_name"
    }
    /**
     * Invalid payment number
     */
    case object InvalidNumber extends AuthorizationDeclineCode {
      override def toString = "invalid_number"
    }
    /**
     * Invalid expiration date
     */
    case object InvalidExpiration extends AuthorizationDeclineCode {
      override def toString = "invalid_expiration"
    }
    /**
     * Invalid billing address
     */
    case object InvalidAddress extends AuthorizationDeclineCode {
      override def toString = "invalid_address"
    }
    /**
     * Cannot create a permanent card via an unauthorized request
     */
    case object InvalidTokenType extends AuthorizationDeclineCode {
      override def toString = "invalid_token_type"
    }
    /**
     * The provided card token is invalid or it does not exist.
     */
    case object InvalidToken extends AuthorizationDeclineCode {
      override def toString = "invalid_token"
    }
    /**
     * The provided payment method is not known by the issuing bank (the account does
     * not exist)
     */
    case object NoAccount extends AuthorizationDeclineCode {
      override def toString = "no_account"
    }
    /**
     * Declined due to avs mismatch)
     */
    case object Avs extends AuthorizationDeclineCode {
      override def toString = "avs"
    }
    /**
     * Declined due to cvv mismatch)
     */
    case object Cvv extends AuthorizationDeclineCode {
      override def toString = "cvv"
    }
    /**
     * Declined due to suspected fraud
     */
    case object Fraud extends AuthorizationDeclineCode {
      override def toString = "fraud"
    }
    /**
     * Declined due to suspected duplicate transaction
     */
    case object Duplicate extends AuthorizationDeclineCode {
      override def toString = "duplicate"
    }
    /**
     * Declined as payment method is not supported
     */
    case object NotSupported extends AuthorizationDeclineCode {
      override def toString = "not_supported"
    }
    /**
     * Declined due to another reason (details not known)
     */
    case object Unknown extends AuthorizationDeclineCode {
      override def toString = "unknown"
    }
    /**
     * Indicates an online payment error
     */
    case object OnlinePaymentError extends AuthorizationDeclineCode {
      override def toString = "online_payment_error"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends AuthorizationDeclineCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AuthorizationDeclineCode] = scala.List(Expired, InvalidName, InvalidNumber, InvalidExpiration, InvalidAddress, InvalidTokenType, InvalidToken, NoAccount, Avs, Cvv, Fraud, Duplicate, NotSupported, Unknown, OnlinePaymentError)

    private[this]
    val byName: Map[String, AuthorizationDeclineCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationDeclineCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationDeclineCode] = byName.get(value.toLowerCase)

  }

  /**
   * Specifies optional behaviors that can be applied during an authorization
   */
  sealed trait AuthorizationOption extends _root_.scala.Product with _root_.scala.Serializable

  object AuthorizationOption {

    /**
     * If set, and the authorization is created using a one time nonce, we
     * automatically tokenize and store the card. In these cases you will want to store
     * the new card token in the authorization response (card object)
     */
    case object StoreCard extends AuthorizationOption {
      override def toString = "store_card"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends AuthorizationOption

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AuthorizationOption] = scala.List(StoreCard)

    private[this]
    val byName: Map[String, AuthorizationOption] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationOption = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationOption] = byName.get(value.toLowerCase)

  }

  /**
   * Specifies an action necessary to continue processing the authorization, such as
   * redirecting to a payment issuer to complete user verification.
   */
  sealed trait AuthorizationResultActionType extends _root_.scala.Product with _root_.scala.Serializable

  object AuthorizationResultActionType {

    /**
     * Indicates an authorization action should be presented to the user natively in
     * the browser.
     */
    case object Native extends AuthorizationResultActionType {
      override def toString = "native"
    }
    /**
     * Indicates that the user should be redirected to the provided URL.
     */
    case object Redirect extends AuthorizationResultActionType {
      override def toString = "redirect"
    }
    /**
     * Indicates that more time is needed before the authorization result is known. In
     * the case of 3D Secure, this means the authorization status should be polled
     * until it is no longer pending.
     */
    case object Wait extends AuthorizationResultActionType {
      override def toString = "wait"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends AuthorizationResultActionType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AuthorizationResultActionType] = scala.List(Native, Redirect, Wait)

    private[this]
    val byName: Map[String, AuthorizationResultActionType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationResultActionType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationResultActionType] = byName.get(value.toLowerCase)

  }

  sealed trait AuthorizationStatus extends _root_.scala.Product with _root_.scala.Serializable

  object AuthorizationStatus {

    /**
     * If an immediate response is not available, the state will be 'pending'. For
     * example, online payment methods like AliPay or PayPal will have a status of
     * 'pending' until the user completes the payment. Pending authorizations expire if
     * the user does not complete the payment in a timely fashion.
     */
    case object Pending extends AuthorizationStatus {
      override def toString = "pending"
    }
    /**
     * Authorization has expired.
     */
    case object Expired extends AuthorizationStatus {
      override def toString = "expired"
    }
    /**
     * Authorization was successful
     */
    case object Authorized extends AuthorizationStatus {
      override def toString = "authorized"
    }
    /**
     * If an immediate response is not available, the state will be 'review' - this
     * usually indicates fraud review requires additional time / verification (or a
     * potential network issue with the issuing bank)
     */
    case object Review extends AuthorizationStatus {
      override def toString = "review"
    }
    /**
     * Indicates the authorization has been declined by the issuing bank. See the
     * authorization decline code for more details as to the reason for decline.
     */
    case object Declined extends AuthorizationStatus {
      override def toString = "declined"
    }
    /**
     * Indicates the authorization has been fully reversed. You can fully reverse an
     * authorization up until the moment you capture funds; once you have captured
     * funds you must create refunds.
     */
    case object Reversed extends AuthorizationStatus {
      override def toString = "reversed"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends AuthorizationStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AuthorizationStatus] = scala.List(Pending, Expired, Authorized, Review, Declined, Reversed)

    private[this]
    val byName: Map[String, AuthorizationStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationStatus] = byName.get(value.toLowerCase)

  }

  sealed trait AvsCode extends _root_.scala.Product with _root_.scala.Serializable

  object AvsCode {

    /**
     * Full match
     */
    case object Match extends AvsCode { override def toString = "match" }
    /**
     * Partial match; see details in 'avs' model to understand which components matched
     */
    case object Partial extends AvsCode {
      override def toString = "partial"
    }
    /**
     * Issuer does not support address verification
     */
    case object Unsupported extends AvsCode {
      override def toString = "unsupported"
    }
    /**
     * Address does not match expected card values
     */
    case object NoMatch extends AvsCode {
      override def toString = "no_match"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends AvsCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AvsCode] = scala.List(Match, Partial, Unsupported, NoMatch)

    private[this]
    val byName: Map[String, AvsCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AvsCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AvsCode] = byName.get(value.toLowerCase)

  }

  /**
   * Contains details related to the reason for which a capture failed.
   */
  sealed trait CaptureDeclineCode extends _root_.scala.Product with _root_.scala.Serializable

  object CaptureDeclineCode {

    /**
     * Payment authorization has expired
     */
    case object Expired extends CaptureDeclineCode {
      override def toString = "expired"
    }
    /**
     * The amount to capture exceeded the amount authorized and not yet captured
     */
    case object InsufficientFunds extends CaptureDeclineCode {
      override def toString = "insufficient_funds"
    }
    /**
     * Failed due to another reason (details not known)
     */
    case object Unknown extends CaptureDeclineCode {
      override def toString = "unknown"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CaptureDeclineCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CaptureDeclineCode] = scala.List(Expired, InsufficientFunds, Unknown)

    private[this]
    val byName: Map[String, CaptureDeclineCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CaptureDeclineCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CaptureDeclineCode] = byName.get(value.toLowerCase)

  }

  sealed trait CaptureStatus extends _root_.scala.Product with _root_.scala.Serializable

  object CaptureStatus {

    /**
     * The capture has been initiated and requires time to complete.
     */
    case object Pending extends CaptureStatus {
      override def toString = "pending"
    }
    /**
     * The capture has been processed successfully.
     */
    case object Succeeded extends CaptureStatus {
      override def toString = "succeeded"
    }
    /**
     * The capture failed to process.
     */
    case object Failed extends CaptureStatus { override def toString = "failed" }
    /**
     * The capture was canceled.
     */
    case object Canceled extends CaptureStatus { override def toString = "canceled" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CaptureStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CaptureStatus] = scala.List(Pending, Succeeded, Failed, Canceled)

    private[this]
    val byName: Map[String, CaptureStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CaptureStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CaptureStatus] = byName.get(value.toLowerCase)

  }

  sealed trait CardErrorCode extends _root_.scala.Product with _root_.scala.Serializable

  object CardErrorCode {

    /**
     * Invalid billing address
     */
    case object InvalidAddress extends CardErrorCode {
      override def toString = "invalid_address"
    }
    /**
     * Invalid requested currency
     */
    case object InvalidCurrency extends CardErrorCode {
      override def toString = "invalid_currency"
    }
    /**
     * Invalid cardholder name
     */
    case object InvalidName extends CardErrorCode {
      override def toString = "invalid_name"
    }
    /**
     * Invalid payment number
     */
    case object InvalidNumber extends CardErrorCode {
      override def toString = "invalid_number"
    }
    /**
     * Invalid expiration date
     */
    case object InvalidExpiration extends CardErrorCode {
      override def toString = "invalid_expiration"
    }
    /**
     * Cannot create a permanent card via an unauthorized request
     */
    case object InvalidTokenType extends CardErrorCode {
      override def toString = "invalid_token_type"
    }
    /**
     * Declined due to avs mismatch
     */
    case object Avs extends CardErrorCode { override def toString = "avs" }
    /**
     * Declined due to cvv mismatch
     */
    case object Cvv extends CardErrorCode { override def toString = "cvv" }
    /**
     * Declined due to suspected fraud
     */
    case object Fraud extends CardErrorCode { override def toString = "fraud" }
    /**
     * Declined due to another reason (details not known)
     */
    case object Unknown extends CardErrorCode {
      override def toString = "unknown"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CardErrorCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CardErrorCode] = scala.List(InvalidAddress, InvalidCurrency, InvalidName, InvalidNumber, InvalidExpiration, InvalidTokenType, Avs, Cvv, Fraud, Unknown)

    private[this]
    val byName: Map[String, CardErrorCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CardErrorCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CardErrorCode] = byName.get(value.toLowerCase)

  }

  sealed trait CardType extends _root_.scala.Product with _root_.scala.Serializable

  object CardType {

    case object AmericanExpress extends CardType { override def toString = "american_express" }
    case object CartesBancaires extends CardType { override def toString = "cartes_bancaires" }
    case object ChinaUnionPay extends CardType { override def toString = "china_union_pay" }
    case object Dankort extends CardType { override def toString = "dankort" }
    case object DinersClub extends CardType { override def toString = "diners_club" }
    case object Discover extends CardType { override def toString = "discover" }
    case object Jcb extends CardType { override def toString = "jcb" }
    case object Maestro extends CardType { override def toString = "maestro" }
    case object Mastercard extends CardType { override def toString = "mastercard" }
    case object Visa extends CardType { override def toString = "visa" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CardType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CardType] = scala.List(AmericanExpress, CartesBancaires, ChinaUnionPay, Dankort, DinersClub, Discover, Jcb, Maestro, Mastercard, Visa)

    private[this]
    val byName: Map[String, CardType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CardType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CardType] = byName.get(value.toLowerCase)

  }

  sealed trait CvvCode extends _root_.scala.Product with _root_.scala.Serializable

  object CvvCode {

    /**
     * CVV matches
     */
    case object Match extends CvvCode { override def toString = "match" }
    /**
     * CVV did not match; Transaction is possibly fraudulent
     */
    case object Suspicious extends CvvCode {
      override def toString = "suspicious"
    }
    /**
     * CVV did not match; Issuer does not support card verification numbers
     */
    case object Unsupported extends CvvCode {
      override def toString = "unsupported"
    }
    /**
     * CVV did not match; Specific reason not available
     */
    case object NoMatch extends CvvCode {
      override def toString = "no_match"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CvvCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CvvCode] = scala.List(Match, Suspicious, Unsupported, NoMatch)

    private[this]
    val byName: Map[String, CvvCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CvvCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CvvCode] = byName.get(value.toLowerCase)

  }

  sealed trait PaymentErrorCode extends _root_.scala.Product with _root_.scala.Serializable

  object PaymentErrorCode {

    case object Duplicate extends PaymentErrorCode { override def toString = "duplicate" }
    /**
     * Amount is not valid (e.g. for merchant of record payments, the amount specified
     * must match the order). This typically is handled by refreshing the order amount
     * and reconfirming with the user as something has changed.
     */
    case object InvalidAmount extends PaymentErrorCode {
      override def toString = "invalid_amount"
    }
    /**
     * Currency is either not known or invalid (e.g. for merchant of record payments,
     * the currency specified must match the order).
     */
    case object InvalidCurrency extends PaymentErrorCode {
      override def toString = "invalid_currency"
    }
    /**
     * Invalid payment method
     */
    case object InvalidMethod extends PaymentErrorCode {
      override def toString = "invalid_method"
    }
    /**
     * The specified order number was not found
     */
    case object InvalidOrder extends PaymentErrorCode {
      override def toString = "invalid_order"
    }
    /**
     * Customer information is invalid (e.g. email specified but not a valid email)
     */
    case object InvalidCustomer extends PaymentErrorCode {
      override def toString = "invalid_customer"
    }
    /**
     * Destination/shipping address is not valid
     */
    case object InvalidDestination extends PaymentErrorCode {
      override def toString = "invalid_destination"
    }
    /**
     * Failed due to another reason (details not known)
     */
    case object Unknown extends PaymentErrorCode {
      override def toString = "unknown"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends PaymentErrorCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[PaymentErrorCode] = scala.List(Duplicate, InvalidAmount, InvalidCurrency, InvalidMethod, InvalidOrder, InvalidCustomer, InvalidDestination, Unknown)

    private[this]
    val byName: Map[String, PaymentErrorCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PaymentErrorCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PaymentErrorCode] = byName.get(value.toLowerCase)

  }

  sealed trait PaymentSourceConfirmationActionType extends _root_.scala.Product with _root_.scala.Serializable

  object PaymentSourceConfirmationActionType {

    case object Cvv extends PaymentSourceConfirmationActionType { override def toString = "cvv" }
    case object BillingAddress extends PaymentSourceConfirmationActionType { override def toString = "billing_address" }
    case object Number extends PaymentSourceConfirmationActionType { override def toString = "number" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends PaymentSourceConfirmationActionType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[PaymentSourceConfirmationActionType] = scala.List(Cvv, BillingAddress, Number)

    private[this]
    val byName: Map[String, PaymentSourceConfirmationActionType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PaymentSourceConfirmationActionType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PaymentSourceConfirmationActionType] = byName.get(value.toLowerCase)

  }

  /**
   * Contains details related to the reason for which a refund failed.
   */
  sealed trait RefundDeclineCode extends _root_.scala.Product with _root_.scala.Serializable

  object RefundDeclineCode {

    /**
     * All associated payment captures have expired; refunds can no longer be issued
     */
    case object Expired extends RefundDeclineCode {
      override def toString = "expired"
    }
    /**
     * The requested refund amount exceeded the amount of remaining unrefunded funds
     */
    case object InsufficientFunds extends RefundDeclineCode {
      override def toString = "insufficient_funds"
    }
    /**
     * Failed due to another reason (details not known)
     */
    case object Unknown extends RefundDeclineCode {
      override def toString = "unknown"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends RefundDeclineCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[RefundDeclineCode] = scala.List(Expired, InsufficientFunds, Unknown)

    private[this]
    val byName: Map[String, RefundDeclineCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): RefundDeclineCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[RefundDeclineCode] = byName.get(value.toLowerCase)

  }

  sealed trait RefundStatus extends _root_.scala.Product with _root_.scala.Serializable

  object RefundStatus {

    /**
     * The refund has been initiated and requires time to complete.
     */
    case object Pending extends RefundStatus {
      override def toString = "pending"
    }
    /**
     * The refund has been processed successfully.
     */
    case object Succeeded extends RefundStatus {
      override def toString = "succeeded"
    }
    /**
     * The refund failed to process.
     */
    case object Failed extends RefundStatus { override def toString = "failed" }
    /**
     * The refund was canceled.
     */
    case object Canceled extends RefundStatus { override def toString = "canceled" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends RefundStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[RefundStatus] = scala.List(Pending, Succeeded, Failed, Canceled)

    private[this]
    val byName: Map[String, RefundStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): RefundStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[RefundStatus] = byName.get(value.toLowerCase)

  }

  sealed trait ReversalErrorCode extends _root_.scala.Product with _root_.scala.Serializable

  object ReversalErrorCode {

    /**
     * Amount specified exceeds the remaining authorization balance.
     */
    case object AmountExceedsBalance extends ReversalErrorCode {
      override def toString = "amount_exceeds_balance"
    }
    /**
     * The authorization was initially declined; there is nothing to reverse.
     */
    case object AuthorizationDeclined extends ReversalErrorCode {
      override def toString = "authorization_declined"
    }
    /**
     * The authorization has expired and can no longer be reversed.
     */
    case object AuthorizationExpired extends ReversalErrorCode {
      override def toString = "authorization_expired"
    }
    /**
     * The authorization was not found.
     */
    case object InvalidAuthorization extends ReversalErrorCode {
      override def toString = "invalid_authorization"
    }
    /**
     * Invalid key
     */
    case object InvalidKey extends ReversalErrorCode { override def toString = "invalid_key" }
    /**
     * Amount is not valid - usually because amount was <= 0
     */
    case object InvalidAmount extends ReversalErrorCode {
      override def toString = "invalid_amount"
    }
    /**
     * Currency is either not known or invalid
     */
    case object InvalidCurrency extends ReversalErrorCode {
      override def toString = "invalid_currency"
    }
    /**
     * The authorization has already been fully captured and/or reversed - there are no
     * additional funds to reverse.
     */
    case object NoRemainingBalance extends ReversalErrorCode {
      override def toString = "no_remaining_balance"
    }
    /**
     * Indicates a request for a partial reversal when the underlying processor does
     * not support it
     */
    case object PartialReversalNotSupported extends ReversalErrorCode {
      override def toString = "partial_reversal_not_supported"
    }
    /**
     * Unknown or other
     */
    case object Unknown extends ReversalErrorCode { override def toString = "unknown" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ReversalErrorCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ReversalErrorCode] = scala.List(AmountExceedsBalance, AuthorizationDeclined, AuthorizationExpired, InvalidAuthorization, InvalidKey, InvalidAmount, InvalidCurrency, NoRemainingBalance, PartialReversalNotSupported, Unknown)

    private[this]
    val byName: Map[String, ReversalErrorCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ReversalErrorCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ReversalErrorCode] = byName.get(value.toLowerCase)

  }

  sealed trait ReversalStatus extends _root_.scala.Product with _root_.scala.Serializable

  object ReversalStatus {

    /**
     * Reversal is pending processing.
     */
    case object Pending extends ReversalStatus {
      override def toString = "pending"
    }
    /**
     * Reversal has been processed successfully.
     */
    case object Processed extends ReversalStatus {
      override def toString = "processed"
    }
    /**
     * Reversal failed to process.
     */
    case object Failed extends ReversalStatus { override def toString = "failed" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ReversalStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ReversalStatus] = scala.List(Pending, Processed, Failed)

    private[this]
    val byName: Map[String, ReversalStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ReversalStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ReversalStatus] = byName.get(value.toLowerCase)

  }

  sealed trait ThreeDSecureCode extends _root_.scala.Product with _root_.scala.Serializable

  object ThreeDSecureCode {

    case object Verified extends ThreeDSecureCode { override def toString = "verified" }
    case object NotVerified extends ThreeDSecureCode { override def toString = "not_verified" }
    case object Failed extends ThreeDSecureCode { override def toString = "failed" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ThreeDSecureCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ThreeDSecureCode] = scala.List(Verified, NotVerified, Failed)

    private[this]
    val byName: Map[String, ThreeDSecureCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ThreeDSecureCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ThreeDSecureCode] = byName.get(value.toLowerCase)

  }

  /**
   * This can represent the browser's viewport or could represent a desired smaller
   * size for an overlay. Based on EMVCO 2.2 specifications.
   */
  sealed trait ThreedsTwoChallengeViewport extends _root_.scala.Product with _root_.scala.Serializable

  object ThreedsTwoChallengeViewport {

    /**
     * 250x400
     */
    case object XxxSmall extends ThreedsTwoChallengeViewport { override def toString = "xxx_small" }
    /**
     * 390x400
     */
    case object XxSmall extends ThreedsTwoChallengeViewport { override def toString = "xx_small" }
    /**
     * 500x600
     */
    case object XSmall extends ThreedsTwoChallengeViewport { override def toString = "x_small" }
    /**
     * 600x400
     */
    case object Small extends ThreedsTwoChallengeViewport { override def toString = "small" }
    /**
     * Full Screen. Not recommended for mobile devices at this time.
     */
    case object Fullscreen extends ThreedsTwoChallengeViewport {
      override def toString = "fullscreen"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ThreedsTwoChallengeViewport

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ThreedsTwoChallengeViewport] = scala.List(XxxSmall, XxSmall, XSmall, Small, Fullscreen)

    private[this]
    val byName: Map[String, ThreedsTwoChallengeViewport] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ThreedsTwoChallengeViewport = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ThreedsTwoChallengeViewport] = byName.get(value.toLowerCase)

  }

  sealed trait TokenType extends _root_.scala.Product with _root_.scala.Serializable

  object TokenType {

    /**
     * Create a permanent token for the card (stored up until normal purge interval)
     */
    case object Permanent extends TokenType {
      override def toString = "permanent"
    }
    /**
     * Create a one time token for the card. This token can be used to either
     * authorized payment or later exchange for a permanent token. Once used, this
     * token cannot be used for future activity.
     */
    case object OneTime extends TokenType {
      override def toString = "one_time"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends TokenType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[TokenType] = scala.List(Permanent, OneTime)

    private[this]
    val byName: Map[String, TokenType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TokenType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TokenType] = byName.get(value.toLowerCase)

  }

}

package io.flow.payment.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.common.v0.models.json._
    import io.flow.error.v0.models.json._
    import io.flow.payment.v0.models.json._
    import io.flow.permission.v0.models.json._
    import io.flow.reference.v0.models.json._

    private[v0] implicit val jsonReadsUUID: play.api.libs.json.Reads[_root_.java.util.UUID] = __.read[String].map { str =>
      _root_.java.util.UUID.fromString(str)
    }

    private[v0] implicit val jsonWritesUUID: play.api.libs.json.Writes[_root_.java.util.UUID] = (x: _root_.java.util.UUID) => play.api.libs.json.JsString(x.toString)

    private[v0] implicit val jsonReadsJodaDateTime: play.api.libs.json.Reads[_root_.org.joda.time.DateTime] = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime: play.api.libs.json.Writes[_root_.org.joda.time.DateTime] = (x: _root_.org.joda.time.DateTime) => {
      play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x))
    }

    private[v0] implicit val jsonReadsJodaLocalDate: play.api.libs.json.Reads[_root_.org.joda.time.LocalDate] = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(str)
    }

    private[v0] implicit val jsonWritesJodaLocalDate: play.api.libs.json.Writes[_root_.org.joda.time.LocalDate] = (x: _root_.org.joda.time.LocalDate) => {
      play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.date.print(x))
    }

    implicit val jsonReadsPaymentAuthorizationDeclineCode: play.api.libs.json.Reads[io.flow.payment.v0.models.AuthorizationDeclineCode] = new play.api.libs.json.Reads[io.flow.payment.v0.models.AuthorizationDeclineCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.AuthorizationDeclineCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationDeclineCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationDeclineCode(v))
              case err: play.api.libs.json.JsError =>
                (js \ "authorization_decline_code").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationDeclineCode(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentAuthorizationDeclineCode(obj: io.flow.payment.v0.models.AuthorizationDeclineCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAuthorizationDeclineCode(obj: io.flow.payment.v0.models.AuthorizationDeclineCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentAuthorizationDeclineCode: play.api.libs.json.Writes[AuthorizationDeclineCode] = {
      (obj: io.flow.payment.v0.models.AuthorizationDeclineCode) => {
        jsonWritesPaymentAuthorizationDeclineCode(obj)
      }
    }

    implicit val jsonReadsPaymentAuthorizationOption: play.api.libs.json.Reads[io.flow.payment.v0.models.AuthorizationOption] = new play.api.libs.json.Reads[io.flow.payment.v0.models.AuthorizationOption] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.AuthorizationOption] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationOption(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationOption(v))
              case err: play.api.libs.json.JsError =>
                (js \ "authorization_option").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationOption(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentAuthorizationOption(obj: io.flow.payment.v0.models.AuthorizationOption) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAuthorizationOption(obj: io.flow.payment.v0.models.AuthorizationOption) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentAuthorizationOption: play.api.libs.json.Writes[AuthorizationOption] = {
      (obj: io.flow.payment.v0.models.AuthorizationOption) => {
        jsonWritesPaymentAuthorizationOption(obj)
      }
    }

    implicit val jsonReadsPaymentAuthorizationResultActionType: play.api.libs.json.Reads[io.flow.payment.v0.models.AuthorizationResultActionType] = new play.api.libs.json.Reads[io.flow.payment.v0.models.AuthorizationResultActionType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.AuthorizationResultActionType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationResultActionType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationResultActionType(v))
              case err: play.api.libs.json.JsError =>
                (js \ "authorization_result_action_type").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationResultActionType(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentAuthorizationResultActionType(obj: io.flow.payment.v0.models.AuthorizationResultActionType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAuthorizationResultActionType(obj: io.flow.payment.v0.models.AuthorizationResultActionType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentAuthorizationResultActionType: play.api.libs.json.Writes[AuthorizationResultActionType] = {
      (obj: io.flow.payment.v0.models.AuthorizationResultActionType) => {
        jsonWritesPaymentAuthorizationResultActionType(obj)
      }
    }

    implicit val jsonReadsPaymentAuthorizationStatus: play.api.libs.json.Reads[io.flow.payment.v0.models.AuthorizationStatus] = new play.api.libs.json.Reads[io.flow.payment.v0.models.AuthorizationStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.AuthorizationStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationStatus(v))
              case err: play.api.libs.json.JsError =>
                (js \ "authorization_status").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationStatus(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentAuthorizationStatus(obj: io.flow.payment.v0.models.AuthorizationStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAuthorizationStatus(obj: io.flow.payment.v0.models.AuthorizationStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentAuthorizationStatus: play.api.libs.json.Writes[AuthorizationStatus] = {
      (obj: io.flow.payment.v0.models.AuthorizationStatus) => {
        jsonWritesPaymentAuthorizationStatus(obj)
      }
    }

    implicit val jsonReadsPaymentAvsCode: play.api.libs.json.Reads[io.flow.payment.v0.models.AvsCode] = new play.api.libs.json.Reads[io.flow.payment.v0.models.AvsCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.AvsCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AvsCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AvsCode(v))
              case err: play.api.libs.json.JsError =>
                (js \ "avs_code").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AvsCode(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentAvsCode(obj: io.flow.payment.v0.models.AvsCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAvsCode(obj: io.flow.payment.v0.models.AvsCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentAvsCode: play.api.libs.json.Writes[AvsCode] = {
      (obj: io.flow.payment.v0.models.AvsCode) => {
        jsonWritesPaymentAvsCode(obj)
      }
    }

    implicit val jsonReadsPaymentCaptureDeclineCode: play.api.libs.json.Reads[io.flow.payment.v0.models.CaptureDeclineCode] = new play.api.libs.json.Reads[io.flow.payment.v0.models.CaptureDeclineCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.CaptureDeclineCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CaptureDeclineCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CaptureDeclineCode(v))
              case err: play.api.libs.json.JsError =>
                (js \ "capture_decline_code").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CaptureDeclineCode(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentCaptureDeclineCode(obj: io.flow.payment.v0.models.CaptureDeclineCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCaptureDeclineCode(obj: io.flow.payment.v0.models.CaptureDeclineCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentCaptureDeclineCode: play.api.libs.json.Writes[CaptureDeclineCode] = {
      (obj: io.flow.payment.v0.models.CaptureDeclineCode) => {
        jsonWritesPaymentCaptureDeclineCode(obj)
      }
    }

    implicit val jsonReadsPaymentCaptureStatus: play.api.libs.json.Reads[io.flow.payment.v0.models.CaptureStatus] = new play.api.libs.json.Reads[io.flow.payment.v0.models.CaptureStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.CaptureStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CaptureStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CaptureStatus(v))
              case err: play.api.libs.json.JsError =>
                (js \ "capture_status").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CaptureStatus(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentCaptureStatus(obj: io.flow.payment.v0.models.CaptureStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCaptureStatus(obj: io.flow.payment.v0.models.CaptureStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentCaptureStatus: play.api.libs.json.Writes[CaptureStatus] = {
      (obj: io.flow.payment.v0.models.CaptureStatus) => {
        jsonWritesPaymentCaptureStatus(obj)
      }
    }

    implicit val jsonReadsPaymentCardErrorCode: play.api.libs.json.Reads[io.flow.payment.v0.models.CardErrorCode] = new play.api.libs.json.Reads[io.flow.payment.v0.models.CardErrorCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.CardErrorCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CardErrorCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CardErrorCode(v))
              case err: play.api.libs.json.JsError =>
                (js \ "card_error_code").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CardErrorCode(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentCardErrorCode(obj: io.flow.payment.v0.models.CardErrorCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCardErrorCode(obj: io.flow.payment.v0.models.CardErrorCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentCardErrorCode: play.api.libs.json.Writes[CardErrorCode] = {
      (obj: io.flow.payment.v0.models.CardErrorCode) => {
        jsonWritesPaymentCardErrorCode(obj)
      }
    }

    implicit val jsonReadsPaymentCardType: play.api.libs.json.Reads[io.flow.payment.v0.models.CardType] = new play.api.libs.json.Reads[io.flow.payment.v0.models.CardType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.CardType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CardType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CardType(v))
              case err: play.api.libs.json.JsError =>
                (js \ "card_type").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CardType(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentCardType(obj: io.flow.payment.v0.models.CardType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCardType(obj: io.flow.payment.v0.models.CardType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentCardType: play.api.libs.json.Writes[CardType] = {
      (obj: io.flow.payment.v0.models.CardType) => {
        jsonWritesPaymentCardType(obj)
      }
    }

    implicit val jsonReadsPaymentCvvCode: play.api.libs.json.Reads[io.flow.payment.v0.models.CvvCode] = new play.api.libs.json.Reads[io.flow.payment.v0.models.CvvCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.CvvCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CvvCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CvvCode(v))
              case err: play.api.libs.json.JsError =>
                (js \ "cvv_code").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.CvvCode(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentCvvCode(obj: io.flow.payment.v0.models.CvvCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCvvCode(obj: io.flow.payment.v0.models.CvvCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentCvvCode: play.api.libs.json.Writes[CvvCode] = {
      (obj: io.flow.payment.v0.models.CvvCode) => {
        jsonWritesPaymentCvvCode(obj)
      }
    }

    implicit val jsonReadsPaymentPaymentErrorCode: play.api.libs.json.Reads[io.flow.payment.v0.models.PaymentErrorCode] = new play.api.libs.json.Reads[io.flow.payment.v0.models.PaymentErrorCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.PaymentErrorCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.PaymentErrorCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.PaymentErrorCode(v))
              case err: play.api.libs.json.JsError =>
                (js \ "payment_error_code").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.PaymentErrorCode(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentPaymentErrorCode(obj: io.flow.payment.v0.models.PaymentErrorCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPaymentErrorCode(obj: io.flow.payment.v0.models.PaymentErrorCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentPaymentErrorCode: play.api.libs.json.Writes[PaymentErrorCode] = {
      (obj: io.flow.payment.v0.models.PaymentErrorCode) => {
        jsonWritesPaymentPaymentErrorCode(obj)
      }
    }

    implicit val jsonReadsPaymentPaymentSourceConfirmationActionType: play.api.libs.json.Reads[io.flow.payment.v0.models.PaymentSourceConfirmationActionType] = new play.api.libs.json.Reads[io.flow.payment.v0.models.PaymentSourceConfirmationActionType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.PaymentSourceConfirmationActionType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.PaymentSourceConfirmationActionType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.PaymentSourceConfirmationActionType(v))
              case err: play.api.libs.json.JsError =>
                (js \ "payment_source_confirmation_action_type").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.PaymentSourceConfirmationActionType(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentPaymentSourceConfirmationActionType(obj: io.flow.payment.v0.models.PaymentSourceConfirmationActionType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPaymentSourceConfirmationActionType(obj: io.flow.payment.v0.models.PaymentSourceConfirmationActionType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentPaymentSourceConfirmationActionType: play.api.libs.json.Writes[PaymentSourceConfirmationActionType] = {
      (obj: io.flow.payment.v0.models.PaymentSourceConfirmationActionType) => {
        jsonWritesPaymentPaymentSourceConfirmationActionType(obj)
      }
    }

    implicit val jsonReadsPaymentRefundDeclineCode: play.api.libs.json.Reads[io.flow.payment.v0.models.RefundDeclineCode] = new play.api.libs.json.Reads[io.flow.payment.v0.models.RefundDeclineCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.RefundDeclineCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.RefundDeclineCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.RefundDeclineCode(v))
              case err: play.api.libs.json.JsError =>
                (js \ "refund_decline_code").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.RefundDeclineCode(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentRefundDeclineCode(obj: io.flow.payment.v0.models.RefundDeclineCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectRefundDeclineCode(obj: io.flow.payment.v0.models.RefundDeclineCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentRefundDeclineCode: play.api.libs.json.Writes[RefundDeclineCode] = {
      (obj: io.flow.payment.v0.models.RefundDeclineCode) => {
        jsonWritesPaymentRefundDeclineCode(obj)
      }
    }

    implicit val jsonReadsPaymentRefundStatus: play.api.libs.json.Reads[io.flow.payment.v0.models.RefundStatus] = new play.api.libs.json.Reads[io.flow.payment.v0.models.RefundStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.RefundStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.RefundStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.RefundStatus(v))
              case err: play.api.libs.json.JsError =>
                (js \ "refund_status").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.RefundStatus(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentRefundStatus(obj: io.flow.payment.v0.models.RefundStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectRefundStatus(obj: io.flow.payment.v0.models.RefundStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentRefundStatus: play.api.libs.json.Writes[RefundStatus] = {
      (obj: io.flow.payment.v0.models.RefundStatus) => {
        jsonWritesPaymentRefundStatus(obj)
      }
    }

    implicit val jsonReadsPaymentReversalErrorCode: play.api.libs.json.Reads[io.flow.payment.v0.models.ReversalErrorCode] = new play.api.libs.json.Reads[io.flow.payment.v0.models.ReversalErrorCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.ReversalErrorCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ReversalErrorCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ReversalErrorCode(v))
              case err: play.api.libs.json.JsError =>
                (js \ "reversal_error_code").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ReversalErrorCode(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentReversalErrorCode(obj: io.flow.payment.v0.models.ReversalErrorCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectReversalErrorCode(obj: io.flow.payment.v0.models.ReversalErrorCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentReversalErrorCode: play.api.libs.json.Writes[ReversalErrorCode] = {
      (obj: io.flow.payment.v0.models.ReversalErrorCode) => {
        jsonWritesPaymentReversalErrorCode(obj)
      }
    }

    implicit val jsonReadsPaymentReversalStatus: play.api.libs.json.Reads[io.flow.payment.v0.models.ReversalStatus] = new play.api.libs.json.Reads[io.flow.payment.v0.models.ReversalStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.ReversalStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ReversalStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ReversalStatus(v))
              case err: play.api.libs.json.JsError =>
                (js \ "reversal_status").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ReversalStatus(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentReversalStatus(obj: io.flow.payment.v0.models.ReversalStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectReversalStatus(obj: io.flow.payment.v0.models.ReversalStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentReversalStatus: play.api.libs.json.Writes[ReversalStatus] = {
      (obj: io.flow.payment.v0.models.ReversalStatus) => {
        jsonWritesPaymentReversalStatus(obj)
      }
    }

    implicit val jsonReadsPaymentThreeDSecureCode: play.api.libs.json.Reads[io.flow.payment.v0.models.ThreeDSecureCode] = new play.api.libs.json.Reads[io.flow.payment.v0.models.ThreeDSecureCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.ThreeDSecureCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ThreeDSecureCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ThreeDSecureCode(v))
              case err: play.api.libs.json.JsError =>
                (js \ "three_d_secure_code").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ThreeDSecureCode(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentThreeDSecureCode(obj: io.flow.payment.v0.models.ThreeDSecureCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectThreeDSecureCode(obj: io.flow.payment.v0.models.ThreeDSecureCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentThreeDSecureCode: play.api.libs.json.Writes[ThreeDSecureCode] = {
      (obj: io.flow.payment.v0.models.ThreeDSecureCode) => {
        jsonWritesPaymentThreeDSecureCode(obj)
      }
    }

    implicit val jsonReadsPaymentThreedsTwoChallengeViewport: play.api.libs.json.Reads[io.flow.payment.v0.models.ThreedsTwoChallengeViewport] = new play.api.libs.json.Reads[io.flow.payment.v0.models.ThreedsTwoChallengeViewport] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.ThreedsTwoChallengeViewport] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ThreedsTwoChallengeViewport(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ThreedsTwoChallengeViewport(v))
              case err: play.api.libs.json.JsError =>
                (js \ "threeds_two_challenge_viewport").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ThreedsTwoChallengeViewport(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentThreedsTwoChallengeViewport(obj: io.flow.payment.v0.models.ThreedsTwoChallengeViewport) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectThreedsTwoChallengeViewport(obj: io.flow.payment.v0.models.ThreedsTwoChallengeViewport) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentThreedsTwoChallengeViewport: play.api.libs.json.Writes[ThreedsTwoChallengeViewport] = {
      (obj: io.flow.payment.v0.models.ThreedsTwoChallengeViewport) => {
        jsonWritesPaymentThreedsTwoChallengeViewport(obj)
      }
    }

    implicit val jsonReadsPaymentTokenType: play.api.libs.json.Reads[io.flow.payment.v0.models.TokenType] = new play.api.libs.json.Reads[io.flow.payment.v0.models.TokenType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.payment.v0.models.TokenType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.TokenType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.TokenType(v))
              case err: play.api.libs.json.JsError =>
                (js \ "token_type").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.TokenType(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesPaymentTokenType(obj: io.flow.payment.v0.models.TokenType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTokenType(obj: io.flow.payment.v0.models.TokenType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesPaymentTokenType: play.api.libs.json.Writes[TokenType] = {
      (obj: io.flow.payment.v0.models.TokenType) => {
        jsonWritesPaymentTokenType(obj)
      }
    }

    implicit def jsonReadsPaymentAchAuthorizationForm: play.api.libs.json.Reads[AchAuthorizationForm] = {
      for {
        accountOwnerName <- (__ \ "account_owner_name").read[String]
        accountNumber <- (__ \ "account_number").read[String]
        routingNumber <- (__ \ "routing_number").read[String]
        billingAddress <- (__ \ "billing_address").read[io.flow.common.v0.models.BillingAddress]
        orderNumber <- (__ \ "order_number").readNullable[String]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        key <- (__ \ "key").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        ip <- (__ \ "ip").readNullable[String]
      } yield AchAuthorizationForm(accountOwnerName, accountNumber, routingNumber, billingAddress, orderNumber, amount, currency, key, attributes, ip)
    }

    def jsObjectAchAuthorizationForm(obj: io.flow.payment.v0.models.AchAuthorizationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "account_owner_name" -> play.api.libs.json.JsString(obj.accountOwnerName),
        "account_number" -> play.api.libs.json.JsString(obj.accountNumber),
        "routing_number" -> play.api.libs.json.JsString(obj.routingNumber),
        "billing_address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(obj.billingAddress),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.orderNumber match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order_number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "ach_authorization_form")
    }

    implicit def jsonWritesPaymentAchAuthorizationForm: play.api.libs.json.Writes[AchAuthorizationForm] = {
      (obj: io.flow.payment.v0.models.AchAuthorizationForm) => {
        jsObjectAchAuthorizationForm(obj)
      }
    }

    implicit def jsonReadsPaymentAdyenChallengeShopperData: play.api.libs.json.Reads[AdyenChallengeShopperData] = {
      (__ \ "challenge_token").read[String].map { x => new AdyenChallengeShopperData(challengeToken = x) }
    }

    def jsObjectAdyenChallengeShopperData(obj: io.flow.payment.v0.models.AdyenChallengeShopperData): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "challenge_token" -> play.api.libs.json.JsString(obj.challengeToken)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "adyen_challenge_shopper_data")
    }

    implicit def jsonWritesPaymentAdyenChallengeShopperData: play.api.libs.json.Writes[AdyenChallengeShopperData] = {
      (obj: io.flow.payment.v0.models.AdyenChallengeShopperData) => {
        jsObjectAdyenChallengeShopperData(obj)
      }
    }

    implicit def jsonReadsPaymentAdyenIdentifyShopperData: play.api.libs.json.Reads[AdyenIdentifyShopperData] = {
      (__ \ "fingerprint_token").read[String].map { x => new AdyenIdentifyShopperData(fingerprintToken = x) }
    }

    def jsObjectAdyenIdentifyShopperData(obj: io.flow.payment.v0.models.AdyenIdentifyShopperData): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "fingerprint_token" -> play.api.libs.json.JsString(obj.fingerprintToken)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "adyen_identify_shopper_data")
    }

    implicit def jsonWritesPaymentAdyenIdentifyShopperData: play.api.libs.json.Writes[AdyenIdentifyShopperData] = {
      (obj: io.flow.payment.v0.models.AdyenIdentifyShopperData) => {
        jsObjectAdyenIdentifyShopperData(obj)
      }
    }

    implicit def jsonReadsPaymentAdyenNativeActionDetails: play.api.libs.json.Reads[AdyenNativeActionDetails] = {
      for {
        originKey <- (__ \ "origin_key").readNullable[String]
        data <- (__ \ "data").readNullable[io.flow.payment.v0.models.AdyenNativeData]
      } yield AdyenNativeActionDetails(originKey, data)
    }

    def jsObjectAdyenNativeActionDetails(obj: io.flow.payment.v0.models.AdyenNativeActionDetails): play.api.libs.json.JsObject = {
      (obj.originKey match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("origin_key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.data match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("data" -> jsObjectAdyenNativeData(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "adyen_native_action_details")
    }

    implicit def jsonWritesPaymentAdyenNativeActionDetails: play.api.libs.json.Writes[AdyenNativeActionDetails] = {
      (obj: io.flow.payment.v0.models.AdyenNativeActionDetails) => {
        jsObjectAdyenNativeActionDetails(obj)
      }
    }

    implicit def jsonReadsPaymentApplePayMerchantValidationPayload: play.api.libs.json.Reads[ApplePayMerchantValidationPayload] = {
      for {
        validationUrl <- (__ \ "validation_url").read[String]
        displayName <- (__ \ "display_name").readNullable[String]
      } yield ApplePayMerchantValidationPayload(validationUrl, displayName)
    }

    def jsObjectApplePayMerchantValidationPayload(obj: io.flow.payment.v0.models.ApplePayMerchantValidationPayload): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "validation_url" -> play.api.libs.json.JsString(obj.validationUrl)
      ) ++ (obj.displayName match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("display_name" -> play.api.libs.json.JsString(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "apple_pay_merchant_validation_payload")
    }

    implicit def jsonWritesPaymentApplePayMerchantValidationPayload: play.api.libs.json.Writes[ApplePayMerchantValidationPayload] = {
      (obj: io.flow.payment.v0.models.ApplePayMerchantValidationPayload) => {
        jsObjectApplePayMerchantValidationPayload(obj)
      }
    }

    implicit def jsonReadsPaymentAuthorizationCopyForm: play.api.libs.json.Reads[AuthorizationCopyForm] = {
      for {
        sourceAuthorizationKey <- (__ \ "source_authorization_key").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield AuthorizationCopyForm(sourceAuthorizationKey, amount, currency, attributes)
    }

    def jsObjectAuthorizationCopyForm(obj: io.flow.payment.v0.models.AuthorizationCopyForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "source_authorization_key" -> play.api.libs.json.JsString(obj.sourceAuthorizationKey),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "authorization_copy_form")
    }

    implicit def jsonWritesPaymentAuthorizationCopyForm: play.api.libs.json.Writes[AuthorizationCopyForm] = {
      (obj: io.flow.payment.v0.models.AuthorizationCopyForm) => {
        jsObjectAuthorizationCopyForm(obj)
      }
    }

    implicit def jsonReadsPaymentAuthorizationError: play.api.libs.json.Reads[AuthorizationError] = {
      for {
        code <- (__ \ "code").read[io.flow.payment.v0.models.AuthorizationDeclineCode]
        messages <- (__ \ "messages").read[Seq[String]]
        avs <- (__ \ "avs").readNullable[io.flow.payment.v0.models.Avs]
        cvv <- (__ \ "cvv").readNullable[io.flow.payment.v0.models.Cvv]
      } yield AuthorizationError(code, messages, avs, cvv)
    }

    def jsObjectAuthorizationError(obj: io.flow.payment.v0.models.AuthorizationError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages)
      ) ++ (obj.avs match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("avs" -> jsObjectAvs(x))
      }) ++
      (obj.cvv match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cvv" -> jsObjectCvv(x))
      })
    }

    implicit def jsonWritesPaymentAuthorizationError: play.api.libs.json.Writes[AuthorizationError] = {
      (obj: io.flow.payment.v0.models.AuthorizationError) => {
        jsObjectAuthorizationError(obj)
      }
    }

    implicit def jsonReadsPaymentAuthorizationOrderReference: play.api.libs.json.Reads[AuthorizationOrderReference] = {
      (__ \ "number").read[String].map { x => new AuthorizationOrderReference(number = x) }
    }

    def jsObjectAuthorizationOrderReference(obj: io.flow.payment.v0.models.AuthorizationOrderReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonWritesPaymentAuthorizationOrderReference: play.api.libs.json.Writes[AuthorizationOrderReference] = {
      (obj: io.flow.payment.v0.models.AuthorizationOrderReference) => {
        jsObjectAuthorizationOrderReference(obj)
      }
    }

    implicit def jsonReadsPaymentAuthorizationPayload: play.api.libs.json.Reads[AuthorizationPayload] = {
      (__ \ "parameters").read[io.flow.payment.v0.models.AuthorizationPayloadParameters].map { x => new AuthorizationPayload(parameters = x) }
    }

    def jsObjectAuthorizationPayload(obj: io.flow.payment.v0.models.AuthorizationPayload): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "parameters" -> jsObjectAuthorizationPayloadParameters(obj.parameters)
      )
    }

    implicit def jsonWritesPaymentAuthorizationPayload: play.api.libs.json.Writes[AuthorizationPayload] = {
      (obj: io.flow.payment.v0.models.AuthorizationPayload) => {
        jsObjectAuthorizationPayload(obj)
      }
    }

    implicit def jsonReadsPaymentAuthorizationReference: play.api.libs.json.Reads[AuthorizationReference] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        order <- (__ \ "order").readNullable[io.flow.payment.v0.models.AuthorizationOrderReference]
      } yield AuthorizationReference(id, key, order)
    }

    def jsObjectAuthorizationReference(obj: io.flow.payment.v0.models.AuthorizationReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key)
      ) ++ (obj.order match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order" -> jsObjectAuthorizationOrderReference(x))
      })
    }

    implicit def jsonWritesPaymentAuthorizationReference: play.api.libs.json.Writes[AuthorizationReference] = {
      (obj: io.flow.payment.v0.models.AuthorizationReference) => {
        jsObjectAuthorizationReference(obj)
      }
    }

    implicit def jsonReadsPaymentAuthorizationResult: play.api.libs.json.Reads[AuthorizationResult] = {
      for {
        status <- (__ \ "status").read[io.flow.payment.v0.models.AuthorizationStatus]
        action <- (__ \ "action").readNullable[io.flow.payment.v0.models.AuthorizationResultAction]
        declineCode <- (__ \ "decline_code").readNullable[io.flow.payment.v0.models.AuthorizationDeclineCode]
        avs <- (__ \ "avs").readNullable[io.flow.payment.v0.models.Avs]
        cvv <- (__ \ "cvv").readNullable[io.flow.payment.v0.models.Cvv]
        threeDSecure <- (__ \ "three_d_secure").readNullable[io.flow.payment.v0.models.ThreeDSecure]
        description <- (__ \ "description").readNullable[io.flow.payment.v0.models.AuthorizationResultDescription]
      } yield AuthorizationResult(status, action, declineCode, avs, cvv, threeDSecure, description)
    }

    def jsObjectAuthorizationResult(obj: io.flow.payment.v0.models.AuthorizationResult): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.action match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("action" -> jsObjectAuthorizationResultAction(x))
      }) ++
      (obj.declineCode match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("decline_code" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.avs match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("avs" -> jsObjectAvs(x))
      }) ++
      (obj.cvv match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cvv" -> jsObjectCvv(x))
      }) ++
      (obj.threeDSecure match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("three_d_secure" -> jsObjectThreeDSecure(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> jsObjectAuthorizationResultDescription(x))
      })
    }

    implicit def jsonWritesPaymentAuthorizationResult: play.api.libs.json.Writes[AuthorizationResult] = {
      (obj: io.flow.payment.v0.models.AuthorizationResult) => {
        jsObjectAuthorizationResult(obj)
      }
    }

    implicit def jsonReadsPaymentAuthorizationResultActionGet: play.api.libs.json.Reads[AuthorizationResultActionGet] = {
      for {
        `type` <- (__ \ "type").read[io.flow.payment.v0.models.AuthorizationResultActionType]
        url <- (__ \ "url").readNullable[String]
        details <- (__ \ "details").readNullable[io.flow.payment.v0.models.AuthorizationResultActionDetails]
      } yield AuthorizationResultActionGet(`type`, url, details)
    }

    def jsObjectAuthorizationResultActionGet(obj: io.flow.payment.v0.models.AuthorizationResultActionGet): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      ) ++ (obj.url match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("url" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.details match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("details" -> jsObjectAuthorizationResultActionDetails(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "authorization_result_action_get")
    }

    implicit def jsonWritesPaymentAuthorizationResultActionGet: play.api.libs.json.Writes[AuthorizationResultActionGet] = {
      (obj: io.flow.payment.v0.models.AuthorizationResultActionGet) => {
        jsObjectAuthorizationResultActionGet(obj)
      }
    }

    implicit def jsonReadsPaymentAuthorizationResultActionNative: play.api.libs.json.Reads[AuthorizationResultActionNative] = {
      for {
        `type` <- (__ \ "type").read[io.flow.payment.v0.models.AuthorizationResultActionType]
        authorization <- (__ \ "authorization").read[io.flow.payment.v0.models.AuthorizationReference]
        details <- (__ \ "details").readNullable[io.flow.payment.v0.models.AuthorizationResultActionDetails]
      } yield AuthorizationResultActionNative(`type`, authorization, details)
    }

    def jsObjectAuthorizationResultActionNative(obj: io.flow.payment.v0.models.AuthorizationResultActionNative): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "authorization" -> jsObjectAuthorizationReference(obj.authorization)
      ) ++ (obj.details match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("details" -> jsObjectAuthorizationResultActionDetails(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "authorization_result_action_native")
    }

    implicit def jsonWritesPaymentAuthorizationResultActionNative: play.api.libs.json.Writes[AuthorizationResultActionNative] = {
      (obj: io.flow.payment.v0.models.AuthorizationResultActionNative) => {
        jsObjectAuthorizationResultActionNative(obj)
      }
    }

    implicit def jsonReadsPaymentAuthorizationResultActionPost: play.api.libs.json.Reads[AuthorizationResultActionPost] = {
      for {
        `type` <- (__ \ "type").read[io.flow.payment.v0.models.AuthorizationResultActionType]
        url <- (__ \ "url").read[String]
        parameters <- (__ \ "parameters").read[_root_.play.api.libs.json.JsObject]
      } yield AuthorizationResultActionPost(`type`, url, parameters)
    }

    def jsObjectAuthorizationResultActionPost(obj: io.flow.payment.v0.models.AuthorizationResultActionPost): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "url" -> play.api.libs.json.JsString(obj.url),
        "parameters" -> obj.parameters
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "authorization_result_action_post")
    }

    implicit def jsonWritesPaymentAuthorizationResultActionPost: play.api.libs.json.Writes[AuthorizationResultActionPost] = {
      (obj: io.flow.payment.v0.models.AuthorizationResultActionPost) => {
        jsObjectAuthorizationResultActionPost(obj)
      }
    }

    implicit def jsonReadsPaymentAuthorizationResultActionWait: play.api.libs.json.Reads[AuthorizationResultActionWait] = {
      (__ \ "type").read[io.flow.payment.v0.models.AuthorizationResultActionType].map { x => new AuthorizationResultActionWait(`type` = x) }
    }

    def jsObjectAuthorizationResultActionWait(obj: io.flow.payment.v0.models.AuthorizationResultActionWait): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "authorization_result_action_wait")
    }

    implicit def jsonWritesPaymentAuthorizationResultActionWait: play.api.libs.json.Writes[AuthorizationResultActionWait] = {
      (obj: io.flow.payment.v0.models.AuthorizationResultActionWait) => {
        jsObjectAuthorizationResultActionWait(obj)
      }
    }

    implicit def jsonReadsPaymentAuthorizationResultDescription: play.api.libs.json.Reads[AuthorizationResultDescription] = {
      (__ \ "display").read[String].map { x => new AuthorizationResultDescription(display = x) }
    }

    def jsObjectAuthorizationResultDescription(obj: io.flow.payment.v0.models.AuthorizationResultDescription): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "display" -> play.api.libs.json.JsString(obj.display)
      )
    }

    implicit def jsonWritesPaymentAuthorizationResultDescription: play.api.libs.json.Writes[AuthorizationResultDescription] = {
      (obj: io.flow.payment.v0.models.AuthorizationResultDescription) => {
        jsObjectAuthorizationResultDescription(obj)
      }
    }

    implicit def jsonReadsPaymentAuthorizationVersion: play.api.libs.json.Reads[AuthorizationVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        authorization <- (__ \ "authorization").read[io.flow.payment.v0.models.Authorization]
      } yield AuthorizationVersion(id, timestamp, `type`, authorization)
    }

    def jsObjectAuthorizationVersion(obj: io.flow.payment.v0.models.AuthorizationVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "authorization" -> jsObjectAuthorization(obj.authorization)
      )
    }

    implicit def jsonWritesPaymentAuthorizationVersion: play.api.libs.json.Writes[AuthorizationVersion] = {
      (obj: io.flow.payment.v0.models.AuthorizationVersion) => {
        jsObjectAuthorizationVersion(obj)
      }
    }

    implicit def jsonReadsPaymentAvs: play.api.libs.json.Reads[Avs] = {
      for {
        code <- (__ \ "code").read[io.flow.payment.v0.models.AvsCode]
        name <- (__ \ "name").readNullable[Boolean]
        address <- (__ \ "address").readNullable[Boolean]
        postal <- (__ \ "postal").readNullable[Boolean]
        description <- (__ \ "description").readNullable[String]
      } yield Avs(code, name, address, postal, description)
    }

    def jsObjectAvs(obj: io.flow.payment.v0.models.Avs): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsBoolean(x))
      }) ++
      (obj.address match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("address" -> play.api.libs.json.JsBoolean(x))
      }) ++
      (obj.postal match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("postal" -> play.api.libs.json.JsBoolean(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesPaymentAvs: play.api.libs.json.Writes[Avs] = {
      (obj: io.flow.payment.v0.models.Avs) => {
        jsObjectAvs(obj)
      }
    }

    implicit def jsonReadsPaymentBrowserInfo: play.api.libs.json.Reads[BrowserInfo] = {
      for {
        origin <- (__ \ "origin").readNullable[String]
        language <- (__ \ "language").readNullable[String]
        javaEnabled <- (__ \ "java_enabled").readNullable[Boolean]
        colorDepth <- (__ \ "color_depth").readNullable[Int]
        screenHeight <- (__ \ "screen_height").readNullable[Int]
        screenWidth <- (__ \ "screen_width").readNullable[Int]
        timeZoneOffset <- (__ \ "time_zone_offset").readNullable[Int]
        userAgent <- (__ \ "user_agent").readNullable[String]
        accept <- (__ \ "accept").readNullable[String]
      } yield BrowserInfo(origin, language, javaEnabled, colorDepth, screenHeight, screenWidth, timeZoneOffset, userAgent, accept)
    }

    def jsObjectBrowserInfo(obj: io.flow.payment.v0.models.BrowserInfo): play.api.libs.json.JsObject = {
      (obj.origin match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("origin" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.language match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("language" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.javaEnabled match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("java_enabled" -> play.api.libs.json.JsBoolean(x))
      }) ++
      (obj.colorDepth match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("color_depth" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.screenHeight match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("screen_height" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.screenWidth match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("screen_width" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.timeZoneOffset match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("time_zone_offset" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.userAgent match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("user_agent" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.accept match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("accept" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesPaymentBrowserInfo: play.api.libs.json.Writes[BrowserInfo] = {
      (obj: io.flow.payment.v0.models.BrowserInfo) => {
        jsObjectBrowserInfo(obj)
      }
    }

    implicit def jsonReadsPaymentBrowserInlineActionConfiguration: play.api.libs.json.Reads[BrowserInlineActionConfiguration] = {
      for {
        inlineNotificationUrls <- (__ \ "inline_notification_urls").read[io.flow.payment.v0.models.PostPaymentRedirectUrls]
        actionConfiguration <- (__ \ "action_configuration").readNullable[io.flow.payment.v0.models.BrowserActionConfiguration]
      } yield BrowserInlineActionConfiguration(inlineNotificationUrls, actionConfiguration)
    }

    def jsObjectBrowserInlineActionConfiguration(obj: io.flow.payment.v0.models.BrowserInlineActionConfiguration): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "inline_notification_urls" -> jsObjectPostPaymentRedirectUrls(obj.inlineNotificationUrls)
      ) ++ (obj.actionConfiguration match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("action_configuration" -> jsObjectBrowserActionConfiguration(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "browser_inline_action_configuration")
    }

    implicit def jsonWritesPaymentBrowserInlineActionConfiguration: play.api.libs.json.Writes[BrowserInlineActionConfiguration] = {
      (obj: io.flow.payment.v0.models.BrowserInlineActionConfiguration) => {
        jsObjectBrowserInlineActionConfiguration(obj)
      }
    }

    implicit def jsonReadsPaymentCapture: play.api.libs.json.Reads[Capture] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        authorization <- (__ \ "authorization").read[io.flow.payment.v0.models.AuthorizationReference]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        requested <- (__ \ "requested").readNullable[io.flow.common.v0.models.Money]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        status <- (__ \ "status").readWithDefault[io.flow.payment.v0.models.CaptureStatus](io.flow.payment.v0.models.CaptureStatus.Succeeded)
        base <- (__ \ "base").readNullable[io.flow.common.v0.models.Money]
      } yield Capture(id, key, authorization, amount, currency, requested, createdAt, attributes, status, base)
    }

    def jsObjectCapture(obj: io.flow.payment.v0.models.Capture): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "authorization" -> jsObjectAuthorizationReference(obj.authorization),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt)),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.requested match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("requested" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.base match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("base" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      })
    }

    implicit def jsonWritesPaymentCapture: play.api.libs.json.Writes[Capture] = {
      (obj: io.flow.payment.v0.models.Capture) => {
        jsObjectCapture(obj)
      }
    }

    implicit def jsonReadsPaymentCaptureError: play.api.libs.json.Reads[CaptureError] = {
      for {
        code <- (__ \ "code").read[io.flow.error.v0.models.GenericErrorCode]
        messages <- (__ \ "messages").read[Seq[String]]
        declineCode <- (__ \ "decline_code").read[io.flow.payment.v0.models.CaptureDeclineCode]
      } yield CaptureError(code, messages, declineCode)
    }

    def jsObjectCaptureError(obj: io.flow.payment.v0.models.CaptureError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages),
        "decline_code" -> play.api.libs.json.JsString(obj.declineCode.toString)
      )
    }

    implicit def jsonWritesPaymentCaptureError: play.api.libs.json.Writes[CaptureError] = {
      (obj: io.flow.payment.v0.models.CaptureError) => {
        jsObjectCaptureError(obj)
      }
    }

    implicit def jsonReadsPaymentCaptureForm: play.api.libs.json.Reads[CaptureForm] = {
      for {
        authorizationId <- (__ \ "authorization_id").read[String]
        key <- (__ \ "key").readNullable[String]
        amount <- (__ \ "amount").readNullable[BigDecimal]
        currency <- (__ \ "currency").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield CaptureForm(authorizationId, key, amount, currency, attributes)
    }

    def jsObjectCaptureForm(obj: io.flow.payment.v0.models.CaptureForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "authorization_id" -> play.api.libs.json.JsString(obj.authorizationId)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.amount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("amount" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesPaymentCaptureForm: play.api.libs.json.Writes[CaptureForm] = {
      (obj: io.flow.payment.v0.models.CaptureForm) => {
        jsObjectCaptureForm(obj)
      }
    }

    implicit def jsonReadsPaymentCaptureIdentifier: play.api.libs.json.Reads[CaptureIdentifier] = {
      for {
        id <- (__ \ "id").read[String]
        capture <- (__ \ "capture").read[io.flow.payment.v0.models.CaptureReference]
        name <- (__ \ "name").read[String]
        identifier <- (__ \ "identifier").read[String]
        primary <- (__ \ "primary").read[Boolean]
      } yield CaptureIdentifier(id, capture, name, identifier, primary)
    }

    def jsObjectCaptureIdentifier(obj: io.flow.payment.v0.models.CaptureIdentifier): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "capture" -> jsObjectCaptureReference(obj.capture),
        "name" -> play.api.libs.json.JsString(obj.name),
        "identifier" -> play.api.libs.json.JsString(obj.identifier),
        "primary" -> play.api.libs.json.JsBoolean(obj.primary)
      )
    }

    implicit def jsonWritesPaymentCaptureIdentifier: play.api.libs.json.Writes[CaptureIdentifier] = {
      (obj: io.flow.payment.v0.models.CaptureIdentifier) => {
        jsObjectCaptureIdentifier(obj)
      }
    }

    implicit def jsonReadsPaymentCaptureReference: play.api.libs.json.Reads[CaptureReference] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
      } yield CaptureReference(id, key)
    }

    def jsObjectCaptureReference(obj: io.flow.payment.v0.models.CaptureReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonWritesPaymentCaptureReference: play.api.libs.json.Writes[CaptureReference] = {
      (obj: io.flow.payment.v0.models.CaptureReference) => {
        jsObjectCaptureReference(obj)
      }
    }

    implicit def jsonReadsPaymentCaptureVersion: play.api.libs.json.Reads[CaptureVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        capture <- (__ \ "capture").read[io.flow.payment.v0.models.Capture]
      } yield CaptureVersion(id, timestamp, `type`, capture)
    }

    def jsObjectCaptureVersion(obj: io.flow.payment.v0.models.CaptureVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "capture" -> jsObjectCapture(obj.capture)
      )
    }

    implicit def jsonWritesPaymentCaptureVersion: play.api.libs.json.Writes[CaptureVersion] = {
      (obj: io.flow.payment.v0.models.CaptureVersion) => {
        jsObjectCaptureVersion(obj)
      }
    }

    implicit def jsonReadsPaymentCard: play.api.libs.json.Reads[Card] = {
      for {
        id <- (__ \ "id").read[String]
        token <- (__ \ "token").read[String]
        `type` <- (__ \ "type").read[io.flow.payment.v0.models.CardType]
        expiration <- (__ \ "expiration").read[io.flow.payment.v0.models.Expiration]
        iin <- (__ \ "iin").read[String]
        issuer <- (__ \ "issuer").readNullable[io.flow.payment.v0.models.IssuerSummary]
        last4 <- (__ \ "last4").read[String]
        name <- (__ \ "name").read[String]
        address <- (__ \ "address").readNullable[io.flow.common.v0.models.BillingAddress]
      } yield Card(id, token, `type`, expiration, iin, issuer, last4, name, address)
    }

    def jsObjectCard(obj: io.flow.payment.v0.models.Card): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "token" -> play.api.libs.json.JsString(obj.token),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "expiration" -> jsObjectExpiration(obj.expiration),
        "iin" -> play.api.libs.json.JsString(obj.iin),
        "last4" -> play.api.libs.json.JsString(obj.last4),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.issuer match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("issuer" -> jsObjectIssuerSummary(x))
      }) ++
      (obj.address match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "card")
    }

    implicit def jsonWritesPaymentCard: play.api.libs.json.Writes[Card] = {
      (obj: io.flow.payment.v0.models.Card) => {
        jsObjectCard(obj)
      }
    }

    implicit def jsonReadsPaymentCardAuthorization: play.api.libs.json.Reads[CardAuthorization] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        merchantOfRecord <- (__ \ "merchant_of_record").readWithDefault[io.flow.common.v0.models.MerchantOfRecord](io.flow.common.v0.models.MerchantOfRecord.Flow)
        method <- (__ \ "method").readNullable[io.flow.reference.v0.models.PaymentMethod]
        card <- (__ \ "card").read[io.flow.payment.v0.models.ExpandableCard]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        requested <- (__ \ "requested").readNullable[io.flow.common.v0.models.Money]
        customer <- (__ \ "customer").read[io.flow.common.v0.models.OrderCustomer]
        attributes <- (__ \ "attributes").read[Map[String, String]]
        destination <- (__ \ "destination").readNullable[io.flow.common.v0.models.Address]
        billingAddress <- (__ \ "billing_address").readNullable[io.flow.common.v0.models.BillingAddress]
        order <- (__ \ "order").readNullable[io.flow.payment.v0.models.AuthorizationOrderReference]
        ip <- (__ \ "ip").readNullable[String]
        result <- (__ \ "result").read[io.flow.payment.v0.models.AuthorizationResult]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
        expiresAt <- (__ \ "expires_at").readNullable[_root_.org.joda.time.DateTime]
        base <- (__ \ "base").readNullable[io.flow.common.v0.models.Money]
        processor <- (__ \ "processor").readNullable[io.flow.payment.v0.models.ExpandablePaymentProcessor]
      } yield CardAuthorization(id, key, merchantOfRecord, method, card, amount, currency, requested, customer, attributes, destination, billingAddress, order, ip, result, createdAt, expiresAt, base, processor)
    }

    def jsObjectCardAuthorization(obj: io.flow.payment.v0.models.CardAuthorization): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "merchant_of_record" -> play.api.libs.json.JsString(obj.merchantOfRecord.toString),
        "card" -> jsObjectExpandableCard(obj.card),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "customer" -> io.flow.common.v0.models.json.jsObjectOrderCustomer(obj.customer),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes),
        "result" -> jsObjectAuthorizationResult(obj.result),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt))
      ) ++ (obj.method match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("method" -> io.flow.reference.v0.models.json.jsObjectPaymentMethod(x))
      }) ++
      (obj.requested match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("requested" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.destination match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination" -> io.flow.common.v0.models.json.jsObjectAddress(x))
      }) ++
      (obj.billingAddress match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("billing_address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      }) ++
      (obj.order match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order" -> jsObjectAuthorizationOrderReference(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.expiresAt match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("expires_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      }) ++
      (obj.base match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("base" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.processor match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("processor" -> jsObjectExpandablePaymentProcessor(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "card_authorization")
    }

    implicit def jsonWritesPaymentCardAuthorization: play.api.libs.json.Writes[CardAuthorization] = {
      (obj: io.flow.payment.v0.models.CardAuthorization) => {
        jsObjectCardAuthorization(obj)
      }
    }

    implicit def jsonReadsPaymentCardBrowserActionConfiguration: play.api.libs.json.Reads[CardBrowserActionConfiguration] = {
      (__ \ "viewport").read[io.flow.payment.v0.models.ThreedsTwoChallengeViewport].map { x => new CardBrowserActionConfiguration(viewport = x) }
    }

    def jsObjectCardBrowserActionConfiguration(obj: io.flow.payment.v0.models.CardBrowserActionConfiguration): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "viewport" -> play.api.libs.json.JsString(obj.viewport.toString)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "card_browser_action_configuration")
    }

    implicit def jsonWritesPaymentCardBrowserActionConfiguration: play.api.libs.json.Writes[CardBrowserActionConfiguration] = {
      (obj: io.flow.payment.v0.models.CardBrowserActionConfiguration) => {
        jsObjectCardBrowserActionConfiguration(obj)
      }
    }

    implicit def jsonReadsPaymentCardError: play.api.libs.json.Reads[CardError] = {
      for {
        code <- (__ \ "code").read[io.flow.payment.v0.models.CardErrorCode]
        messages <- (__ \ "messages").read[Seq[String]]
        avs <- (__ \ "avs").readNullable[io.flow.payment.v0.models.Avs]
        cvv <- (__ \ "cvv").readNullable[io.flow.payment.v0.models.Cvv]
      } yield CardError(code, messages, avs, cvv)
    }

    def jsObjectCardError(obj: io.flow.payment.v0.models.CardError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages)
      ) ++ (obj.avs match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("avs" -> jsObjectAvs(x))
      }) ++
      (obj.cvv match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cvv" -> jsObjectCvv(x))
      })
    }

    implicit def jsonWritesPaymentCardError: play.api.libs.json.Writes[CardError] = {
      (obj: io.flow.payment.v0.models.CardError) => {
        jsObjectCardError(obj)
      }
    }

    implicit def jsonReadsPaymentCardForm: play.api.libs.json.Reads[CardForm] = {
      for {
        number <- (__ \ "number").readNullable[String]
        cipher <- (__ \ "cipher").readNullable[String]
        expirationMonth <- (__ \ "expiration_month").read[Int]
        expirationYear <- (__ \ "expiration_year").read[Int]
        name <- (__ \ "name").read[String]
        cvv <- (__ \ "cvv").read[String]
        address <- (__ \ "address").readNullable[io.flow.common.v0.models.BillingAddress]
        ip <- (__ \ "ip").readNullable[String]
        challengeText <- (__ \ "challenge_text").readNullable[String]
        challengeCipher <- (__ \ "challenge_cipher").readNullable[String]
        tokenType <- (__ \ "token_type").readNullable[io.flow.payment.v0.models.TokenType]
        requestedCurrency <- (__ \ "requested_currency").readNullable[String]
        metadata <- (__ \ "metadata").readNullable[io.flow.payment.v0.models.CardMetadata]
      } yield CardForm(number, cipher, expirationMonth, expirationYear, name, cvv, address, ip, challengeText, challengeCipher, tokenType, requestedCurrency, metadata)
    }

    def jsObjectCardForm(obj: io.flow.payment.v0.models.CardForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "expiration_month" -> play.api.libs.json.JsNumber(obj.expirationMonth),
        "expiration_year" -> play.api.libs.json.JsNumber(obj.expirationYear),
        "name" -> play.api.libs.json.JsString(obj.name),
        "cvv" -> play.api.libs.json.JsString(obj.cvv)
      ) ++ (obj.number match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.cipher match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cipher" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.address match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.challengeText match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("challenge_text" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.challengeCipher match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("challenge_cipher" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.tokenType match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("token_type" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.requestedCurrency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("requested_currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.metadata match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("metadata" -> jsObjectCardMetadata(x))
      })
    }

    implicit def jsonWritesPaymentCardForm: play.api.libs.json.Writes[CardForm] = {
      (obj: io.flow.payment.v0.models.CardForm) => {
        jsObjectCardForm(obj)
      }
    }

    implicit def jsonReadsPaymentCardMetadata: play.api.libs.json.Reads[CardMetadata] = {
      (__ \ "merchant_of_record").readNullable[io.flow.common.v0.models.OrderMerchantOfRecord].map { x => new CardMetadata(merchantOfRecord = x) }
    }

    def jsObjectCardMetadata(obj: io.flow.payment.v0.models.CardMetadata): play.api.libs.json.JsObject = {
      (obj.merchantOfRecord match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("merchant_of_record" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesPaymentCardMetadata: play.api.libs.json.Writes[CardMetadata] = {
      (obj: io.flow.payment.v0.models.CardMetadata) => {
        jsObjectCardMetadata(obj)
      }
    }

    implicit def jsonReadsPaymentCardNonceForm: play.api.libs.json.Reads[CardNonceForm] = {
      (__ \ "token").read[String].map { x => new CardNonceForm(token = x) }
    }

    def jsObjectCardNonceForm(obj: io.flow.payment.v0.models.CardNonceForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "token" -> play.api.libs.json.JsString(obj.token)
      )
    }

    implicit def jsonWritesPaymentCardNonceForm: play.api.libs.json.Writes[CardNonceForm] = {
      (obj: io.flow.payment.v0.models.CardNonceForm) => {
        jsObjectCardNonceForm(obj)
      }
    }

    implicit def jsonReadsPaymentCardPaymentSource: play.api.libs.json.Reads[CardPaymentSource] = {
      for {
        id <- (__ \ "id").read[String]
        actions <- (__ \ "actions").readNullable[Seq[io.flow.payment.v0.models.PaymentSourceConfirmationAction]]
        summary <- (__ \ "summary").read[io.flow.payment.v0.models.CardPaymentSourceSummary]
      } yield CardPaymentSource(id, actions, summary)
    }

    def jsObjectCardPaymentSource(obj: io.flow.payment.v0.models.CardPaymentSource): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "summary" -> jsObjectCardPaymentSourceSummary(obj.summary)
      ) ++ (obj.actions match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("actions" -> play.api.libs.json.Json.toJson(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "card_payment_source")
    }

    implicit def jsonWritesPaymentCardPaymentSource: play.api.libs.json.Writes[CardPaymentSource] = {
      (obj: io.flow.payment.v0.models.CardPaymentSource) => {
        jsObjectCardPaymentSource(obj)
      }
    }

    implicit def jsonReadsPaymentCardPaymentSourceAuthorizationForm: play.api.libs.json.Reads[CardPaymentSourceAuthorizationForm] = {
      for {
        key <- (__ \ "key").readNullable[String]
        cardPaymentSourceId <- (__ \ "card_payment_source_id").read[String]
        orderNumber <- (__ \ "order_number").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        browserInfo <- (__ \ "browser_info").readNullable[io.flow.payment.v0.models.BrowserInfo]
        inlineActionConfiguration <- (__ \ "inline_action_configuration").readNullable[io.flow.payment.v0.models.InlineActionConfiguration]
      } yield CardPaymentSourceAuthorizationForm(key, cardPaymentSourceId, orderNumber, amount, currency, browserInfo, inlineActionConfiguration)
    }

    def jsObjectCardPaymentSourceAuthorizationForm(obj: io.flow.payment.v0.models.CardPaymentSourceAuthorizationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "card_payment_source_id" -> play.api.libs.json.JsString(obj.cardPaymentSourceId),
        "order_number" -> play.api.libs.json.JsString(obj.orderNumber),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.browserInfo match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("browser_info" -> jsObjectBrowserInfo(x))
      }) ++
      (obj.inlineActionConfiguration match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("inline_action_configuration" -> jsObjectInlineActionConfiguration(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "card_payment_source_authorization_form")
    }

    implicit def jsonWritesPaymentCardPaymentSourceAuthorizationForm: play.api.libs.json.Writes[CardPaymentSourceAuthorizationForm] = {
      (obj: io.flow.payment.v0.models.CardPaymentSourceAuthorizationForm) => {
        jsObjectCardPaymentSourceAuthorizationForm(obj)
      }
    }

    implicit def jsonReadsPaymentCardPaymentSourceForm: play.api.libs.json.Reads[CardPaymentSourceForm] = {
      for {
        customerNumber <- (__ \ "customer_number").read[String]
        cardId <- (__ \ "card_id").read[String]
      } yield CardPaymentSourceForm(customerNumber, cardId)
    }

    def jsObjectCardPaymentSourceForm(obj: io.flow.payment.v0.models.CardPaymentSourceForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "customer_number" -> play.api.libs.json.JsString(obj.customerNumber),
        "card_id" -> play.api.libs.json.JsString(obj.cardId)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "card_payment_source_form")
    }

    implicit def jsonWritesPaymentCardPaymentSourceForm: play.api.libs.json.Writes[CardPaymentSourceForm] = {
      (obj: io.flow.payment.v0.models.CardPaymentSourceForm) => {
        jsObjectCardPaymentSourceForm(obj)
      }
    }

    implicit def jsonReadsPaymentCardPaymentSourceSummary: play.api.libs.json.Reads[CardPaymentSourceSummary] = {
      for {
        customerNumber <- (__ \ "customer_number").read[String]
        card <- (__ \ "card").read[io.flow.payment.v0.models.CardSummary]
      } yield CardPaymentSourceSummary(customerNumber, card)
    }

    def jsObjectCardPaymentSourceSummary(obj: io.flow.payment.v0.models.CardPaymentSourceSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "customer_number" -> play.api.libs.json.JsString(obj.customerNumber),
        "card" -> jsObjectCardSummary(obj.card)
      )
    }

    implicit def jsonWritesPaymentCardPaymentSourceSummary: play.api.libs.json.Writes[CardPaymentSourceSummary] = {
      (obj: io.flow.payment.v0.models.CardPaymentSourceSummary) => {
        jsObjectCardPaymentSourceSummary(obj)
      }
    }

    implicit def jsonReadsPaymentCardReference: play.api.libs.json.Reads[CardReference] = {
      for {
        id <- (__ \ "id").read[String]
        token <- (__ \ "token").read[String]
      } yield CardReference(id, token)
    }

    def jsObjectCardReference(obj: io.flow.payment.v0.models.CardReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "token" -> play.api.libs.json.JsString(obj.token)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "card_reference")
    }

    implicit def jsonWritesPaymentCardReference: play.api.libs.json.Writes[CardReference] = {
      (obj: io.flow.payment.v0.models.CardReference) => {
        jsObjectCardReference(obj)
      }
    }

    implicit def jsonReadsPaymentCardSummary: play.api.libs.json.Reads[CardSummary] = {
      for {
        id <- (__ \ "id").read[String]
        `type` <- (__ \ "type").read[io.flow.payment.v0.models.CardType]
        expiration <- (__ \ "expiration").read[io.flow.payment.v0.models.Expiration]
        iin <- (__ \ "iin").read[String]
        issuer <- (__ \ "issuer").readNullable[io.flow.payment.v0.models.IssuerSummary]
        last4 <- (__ \ "last4").read[String]
        name <- (__ \ "name").read[String]
        address <- (__ \ "address").readNullable[io.flow.common.v0.models.BillingAddress]
      } yield CardSummary(id, `type`, expiration, iin, issuer, last4, name, address)
    }

    def jsObjectCardSummary(obj: io.flow.payment.v0.models.CardSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "expiration" -> jsObjectExpiration(obj.expiration),
        "iin" -> play.api.libs.json.JsString(obj.iin),
        "last4" -> play.api.libs.json.JsString(obj.last4),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.issuer match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("issuer" -> jsObjectIssuerSummary(x))
      }) ++
      (obj.address match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "card_summary")
    }

    implicit def jsonWritesPaymentCardSummary: play.api.libs.json.Writes[CardSummary] = {
      (obj: io.flow.payment.v0.models.CardSummary) => {
        jsObjectCardSummary(obj)
      }
    }

    implicit def jsonReadsPaymentCardTokenForm: play.api.libs.json.Reads[CardTokenForm] = {
      (__ \ "token").read[String].map { x => new CardTokenForm(token = x) }
    }

    def jsObjectCardTokenForm(obj: io.flow.payment.v0.models.CardTokenForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "token" -> play.api.libs.json.JsString(obj.token)
      )
    }

    implicit def jsonWritesPaymentCardTokenForm: play.api.libs.json.Writes[CardTokenForm] = {
      (obj: io.flow.payment.v0.models.CardTokenForm) => {
        jsObjectCardTokenForm(obj)
      }
    }

    implicit def jsonReadsPaymentCardVersion: play.api.libs.json.Reads[CardVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        card <- (__ \ "card").read[io.flow.payment.v0.models.Card]
      } yield CardVersion(id, timestamp, `type`, card)
    }

    def jsObjectCardVersion(obj: io.flow.payment.v0.models.CardVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "card" -> jsObjectCard(obj.card)
      )
    }

    implicit def jsonWritesPaymentCardVersion: play.api.libs.json.Writes[CardVersion] = {
      (obj: io.flow.payment.v0.models.CardVersion) => {
        jsObjectCardVersion(obj)
      }
    }

    implicit def jsonReadsPaymentCryptopayAuthorizationDetails: play.api.libs.json.Reads[CryptopayAuthorizationDetails] = {
      (__ \ "payment_id").read[String].map { x => new CryptopayAuthorizationDetails(paymentId = x) }
    }

    def jsObjectCryptopayAuthorizationDetails(obj: io.flow.payment.v0.models.CryptopayAuthorizationDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "payment_id" -> play.api.libs.json.JsString(obj.paymentId)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "cryptopay_authorization_details")
    }

    implicit def jsonWritesPaymentCryptopayAuthorizationDetails: play.api.libs.json.Writes[CryptopayAuthorizationDetails] = {
      (obj: io.flow.payment.v0.models.CryptopayAuthorizationDetails) => {
        jsObjectCryptopayAuthorizationDetails(obj)
      }
    }

    implicit def jsonReadsPaymentCvv: play.api.libs.json.Reads[Cvv] = {
      for {
        code <- (__ \ "code").read[io.flow.payment.v0.models.CvvCode]
        description <- (__ \ "description").readNullable[String]
      } yield Cvv(code, description)
    }

    def jsObjectCvv(obj: io.flow.payment.v0.models.Cvv): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesPaymentCvv: play.api.libs.json.Writes[Cvv] = {
      (obj: io.flow.payment.v0.models.Cvv) => {
        jsObjectCvv(obj)
      }
    }

    implicit def jsonReadsPaymentDirectAuthorizationForm: play.api.libs.json.Reads[DirectAuthorizationForm] = {
      for {
        token <- (__ \ "token").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        customer <- (__ \ "customer").readNullable[io.flow.common.v0.models.OrderCustomer]
        key <- (__ \ "key").readNullable[String]
        cvv <- (__ \ "cvv").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        destination <- (__ \ "destination").readNullable[io.flow.common.v0.models.Address]
        billingAddress <- (__ \ "billing_address").readNullable[io.flow.common.v0.models.BillingAddress]
        ip <- (__ \ "ip").readNullable[String]
        options <- (__ \ "options").readNullable[Seq[io.flow.payment.v0.models.AuthorizationOption]]
        redirectUrls <- (__ \ "redirect_urls").readNullable[io.flow.payment.v0.models.PostPaymentRedirectUrls]
        browserInfo <- (__ \ "browser_info").readNullable[io.flow.payment.v0.models.BrowserInfo]
        inlineActionConfiguration <- (__ \ "inline_action_configuration").readNullable[io.flow.payment.v0.models.InlineActionConfiguration]
      } yield DirectAuthorizationForm(token, amount, currency, customer, key, cvv, attributes, destination, billingAddress, ip, options, redirectUrls, browserInfo, inlineActionConfiguration)
    }

    def jsObjectDirectAuthorizationForm(obj: io.flow.payment.v0.models.DirectAuthorizationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "token" -> play.api.libs.json.JsString(obj.token),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.customer match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("customer" -> io.flow.common.v0.models.json.jsObjectOrderCustomer(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.cvv match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cvv" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.destination match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination" -> io.flow.common.v0.models.json.jsObjectAddress(x))
      }) ++
      (obj.billingAddress match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("billing_address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.options match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("options" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.redirectUrls match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("redirect_urls" -> jsObjectPostPaymentRedirectUrls(x))
      }) ++
      (obj.browserInfo match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("browser_info" -> jsObjectBrowserInfo(x))
      }) ++
      (obj.inlineActionConfiguration match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("inline_action_configuration" -> jsObjectInlineActionConfiguration(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "direct_authorization_form")
    }

    implicit def jsonWritesPaymentDirectAuthorizationForm: play.api.libs.json.Writes[DirectAuthorizationForm] = {
      (obj: io.flow.payment.v0.models.DirectAuthorizationForm) => {
        jsObjectDirectAuthorizationForm(obj)
      }
    }

    implicit def jsonReadsPaymentDirectDebit: play.api.libs.json.Reads[DirectDebit] = {
      for {
        routingNumber <- (__ \ "routing_number").read[String]
        last4 <- (__ \ "last4").read[String]
      } yield DirectDebit(routingNumber, last4)
    }

    def jsObjectDirectDebit(obj: io.flow.payment.v0.models.DirectDebit): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "routing_number" -> play.api.libs.json.JsString(obj.routingNumber),
        "last4" -> play.api.libs.json.JsString(obj.last4)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "direct_debit")
    }

    implicit def jsonWritesPaymentDirectDebit: play.api.libs.json.Writes[DirectDebit] = {
      (obj: io.flow.payment.v0.models.DirectDebit) => {
        jsObjectDirectDebit(obj)
      }
    }

    implicit def jsonReadsPaymentExpiration: play.api.libs.json.Reads[Expiration] = {
      for {
        month <- (__ \ "month").read[Int]
        year <- (__ \ "year").read[Int]
      } yield Expiration(month, year)
    }

    def jsObjectExpiration(obj: io.flow.payment.v0.models.Expiration): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "month" -> play.api.libs.json.JsNumber(obj.month),
        "year" -> play.api.libs.json.JsNumber(obj.year)
      )
    }

    implicit def jsonWritesPaymentExpiration: play.api.libs.json.Writes[Expiration] = {
      (obj: io.flow.payment.v0.models.Expiration) => {
        jsObjectExpiration(obj)
      }
    }

    implicit def jsonReadsPaymentGooglePayAuthorizationPayload: play.api.libs.json.Reads[GooglePayAuthorizationPayload] = {
      (__ \ "payload").read[_root_.play.api.libs.json.JsObject].map { x => new GooglePayAuthorizationPayload(payload = x) }
    }

    def jsObjectGooglePayAuthorizationPayload(obj: io.flow.payment.v0.models.GooglePayAuthorizationPayload): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "payload" -> obj.payload
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "google_pay_authorization_payload")
    }

    implicit def jsonWritesPaymentGooglePayAuthorizationPayload: play.api.libs.json.Writes[GooglePayAuthorizationPayload] = {
      (obj: io.flow.payment.v0.models.GooglePayAuthorizationPayload) => {
        jsObjectGooglePayAuthorizationPayload(obj)
      }
    }

    implicit def jsonReadsPaymentIdentifierForm: play.api.libs.json.Reads[IdentifierForm] = {
      for {
        primary <- (__ \ "primary").readNullable[Boolean]
        name <- (__ \ "name").read[String]
      } yield IdentifierForm(primary, name)
    }

    def jsObjectIdentifierForm(obj: io.flow.payment.v0.models.IdentifierForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.primary match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("primary" -> play.api.libs.json.JsBoolean(x))
      })
    }

    implicit def jsonWritesPaymentIdentifierForm: play.api.libs.json.Writes[IdentifierForm] = {
      (obj: io.flow.payment.v0.models.IdentifierForm) => {
        jsObjectIdentifierForm(obj)
      }
    }

    implicit def jsonReadsPaymentInlineAuthorizationDetails: play.api.libs.json.Reads[InlineAuthorizationDetails] = {
      for {
        id <- (__ \ "id").read[String]
        clientToken <- (__ \ "client_token").readNullable[String]
        parameters <- (__ \ "parameters").readNullable[_root_.play.api.libs.json.JsObject]
      } yield InlineAuthorizationDetails(id, clientToken, parameters)
    }

    def jsObjectInlineAuthorizationDetails(obj: io.flow.payment.v0.models.InlineAuthorizationDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      ) ++ (obj.clientToken match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("client_token" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.parameters match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("parameters" -> x)
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "inline_authorization_details")
    }

    implicit def jsonWritesPaymentInlineAuthorizationDetails: play.api.libs.json.Writes[InlineAuthorizationDetails] = {
      (obj: io.flow.payment.v0.models.InlineAuthorizationDetails) => {
        jsObjectInlineAuthorizationDetails(obj)
      }
    }

    implicit def jsonReadsPaymentInlineAuthorizationForm: play.api.libs.json.Reads[InlineAuthorizationForm] = {
      for {
        method <- (__ \ "method").read[String]
        issuer <- (__ \ "issuer").readNullable[io.flow.payment.v0.models.IssuerReference]
        orderNumber <- (__ \ "order_number").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        billingAddress <- (__ \ "billing_address").readNullable[io.flow.common.v0.models.BillingAddress]
        key <- (__ \ "key").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        ip <- (__ \ "ip").readNullable[String]
        payload <- (__ \ "payload").readNullable[io.flow.payment.v0.models.AuthorizationPayload]
      } yield InlineAuthorizationForm(method, issuer, orderNumber, amount, currency, billingAddress, key, attributes, ip, payload)
    }

    def jsObjectInlineAuthorizationForm(obj: io.flow.payment.v0.models.InlineAuthorizationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "method" -> play.api.libs.json.JsString(obj.method),
        "order_number" -> play.api.libs.json.JsString(obj.orderNumber),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.issuer match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("issuer" -> jsObjectIssuerReference(x))
      }) ++
      (obj.billingAddress match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("billing_address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.payload match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("payload" -> jsObjectAuthorizationPayload(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "inline_authorization_form")
    }

    implicit def jsonWritesPaymentInlineAuthorizationForm: play.api.libs.json.Writes[InlineAuthorizationForm] = {
      (obj: io.flow.payment.v0.models.InlineAuthorizationForm) => {
        jsObjectInlineAuthorizationForm(obj)
      }
    }

    implicit def jsonReadsPaymentIssuerReference: play.api.libs.json.Reads[IssuerReference] = {
      (__ \ "id").read[String].map { x => new IssuerReference(id = x) }
    }

    def jsObjectIssuerReference(obj: io.flow.payment.v0.models.IssuerReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesPaymentIssuerReference: play.api.libs.json.Writes[IssuerReference] = {
      (obj: io.flow.payment.v0.models.IssuerReference) => {
        jsObjectIssuerReference(obj)
      }
    }

    implicit def jsonReadsPaymentIssuerSummary: play.api.libs.json.Reads[IssuerSummary] = {
      for {
        iin <- (__ \ "iin").read[String]
        name <- (__ \ "name").readNullable[String]
        country <- (__ \ "country").readNullable[String]
      } yield IssuerSummary(iin, name, country)
    }

    def jsObjectIssuerSummary(obj: io.flow.payment.v0.models.IssuerSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "iin" -> play.api.libs.json.JsString(obj.iin)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.country match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("country" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesPaymentIssuerSummary: play.api.libs.json.Writes[IssuerSummary] = {
      (obj: io.flow.payment.v0.models.IssuerSummary) => {
        jsObjectIssuerSummary(obj)
      }
    }

    implicit def jsonReadsPaymentIssuerV1: play.api.libs.json.Reads[IssuerV1] = {
      for {
        iin <- (__ \ "iin").read[String]
        cardBrand <- (__ \ "card_brand").read[String]
        cardType <- (__ \ "card_type").readNullable[String]
        name <- (__ \ "name").readNullable[String]
        country <- (__ \ "country").readNullable[String]
      } yield IssuerV1(iin, cardBrand, cardType, name, country)
    }

    def jsObjectIssuerV1(obj: io.flow.payment.v0.models.IssuerV1): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "iin" -> play.api.libs.json.JsString(obj.iin),
        "card_brand" -> play.api.libs.json.JsString(obj.cardBrand)
      ) ++ (obj.cardType match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("card_type" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.country match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("country" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesPaymentIssuerV1: play.api.libs.json.Writes[IssuerV1] = {
      (obj: io.flow.payment.v0.models.IssuerV1) => {
        jsObjectIssuerV1(obj)
      }
    }

    implicit def jsonReadsPaymentMerchantOfRecordAuthorizationForm: play.api.libs.json.Reads[MerchantOfRecordAuthorizationForm] = {
      for {
        token <- (__ \ "token").read[String]
        orderNumber <- (__ \ "order_number").read[String]
        amount <- (__ \ "amount").readNullable[BigDecimal]
        currency <- (__ \ "currency").readNullable[String]
        key <- (__ \ "key").readNullable[String]
        cvv <- (__ \ "cvv").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        ip <- (__ \ "ip").readNullable[String]
        options <- (__ \ "options").readNullable[Seq[io.flow.payment.v0.models.AuthorizationOption]]
        redirectUrls <- (__ \ "redirect_urls").readNullable[io.flow.payment.v0.models.PostPaymentRedirectUrls]
        browserInfo <- (__ \ "browser_info").readNullable[io.flow.payment.v0.models.BrowserInfo]
        inlineActionConfiguration <- (__ \ "inline_action_configuration").readNullable[io.flow.payment.v0.models.InlineActionConfiguration]
      } yield MerchantOfRecordAuthorizationForm(token, orderNumber, amount, currency, key, cvv, attributes, ip, options, redirectUrls, browserInfo, inlineActionConfiguration)
    }

    def jsObjectMerchantOfRecordAuthorizationForm(obj: io.flow.payment.v0.models.MerchantOfRecordAuthorizationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "token" -> play.api.libs.json.JsString(obj.token),
        "order_number" -> play.api.libs.json.JsString(obj.orderNumber)
      ) ++ (obj.amount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("amount" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.cvv match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cvv" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.options match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("options" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.redirectUrls match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("redirect_urls" -> jsObjectPostPaymentRedirectUrls(x))
      }) ++
      (obj.browserInfo match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("browser_info" -> jsObjectBrowserInfo(x))
      }) ++
      (obj.inlineActionConfiguration match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("inline_action_configuration" -> jsObjectInlineActionConfiguration(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "merchant_of_record_authorization_form")
    }

    implicit def jsonWritesPaymentMerchantOfRecordAuthorizationForm: play.api.libs.json.Writes[MerchantOfRecordAuthorizationForm] = {
      (obj: io.flow.payment.v0.models.MerchantOfRecordAuthorizationForm) => {
        jsObjectMerchantOfRecordAuthorizationForm(obj)
      }
    }

    implicit def jsonReadsPaymentMerchantOfRecordPaymentForm: play.api.libs.json.Reads[MerchantOfRecordPaymentForm] = {
      for {
        method <- (__ \ "method").read[String]
        orderNumber <- (__ \ "order_number").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
      } yield MerchantOfRecordPaymentForm(method, orderNumber, amount, currency)
    }

    def jsObjectMerchantOfRecordPaymentForm(obj: io.flow.payment.v0.models.MerchantOfRecordPaymentForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "method" -> play.api.libs.json.JsString(obj.method),
        "order_number" -> play.api.libs.json.JsString(obj.orderNumber),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "merchant_of_record_payment_form")
    }

    implicit def jsonWritesPaymentMerchantOfRecordPaymentForm: play.api.libs.json.Writes[MerchantOfRecordPaymentForm] = {
      (obj: io.flow.payment.v0.models.MerchantOfRecordPaymentForm) => {
        jsObjectMerchantOfRecordPaymentForm(obj)
      }
    }

    implicit def jsonReadsPaymentOnlineAuthorization: play.api.libs.json.Reads[OnlineAuthorization] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        method <- (__ \ "method").readNullable[io.flow.reference.v0.models.PaymentMethod]
        merchantOfRecord <- (__ \ "merchant_of_record").readWithDefault[io.flow.common.v0.models.MerchantOfRecord](io.flow.common.v0.models.MerchantOfRecord.Flow)
        details <- (__ \ "details").readNullable[io.flow.payment.v0.models.OnlineAuthorizationDetails]
        payment <- (__ \ "payment").readNullable[_root_.play.api.libs.json.JsObject]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        requested <- (__ \ "requested").readNullable[io.flow.common.v0.models.Money]
        customer <- (__ \ "customer").read[io.flow.common.v0.models.OrderCustomer]
        attributes <- (__ \ "attributes").read[Map[String, String]]
        destination <- (__ \ "destination").readNullable[io.flow.common.v0.models.Address]
        billingAddress <- (__ \ "billing_address").readNullable[io.flow.common.v0.models.BillingAddress]
        order <- (__ \ "order").readNullable[io.flow.payment.v0.models.AuthorizationOrderReference]
        ip <- (__ \ "ip").readNullable[String]
        result <- (__ \ "result").read[io.flow.payment.v0.models.AuthorizationResult]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
        expiresAt <- (__ \ "expires_at").readNullable[_root_.org.joda.time.DateTime]
        base <- (__ \ "base").readNullable[io.flow.common.v0.models.Money]
        processor <- (__ \ "processor").readNullable[io.flow.payment.v0.models.ExpandablePaymentProcessor]
      } yield OnlineAuthorization(id, key, method, merchantOfRecord, details, payment, amount, currency, requested, customer, attributes, destination, billingAddress, order, ip, result, createdAt, expiresAt, base, processor)
    }

    def jsObjectOnlineAuthorization(obj: io.flow.payment.v0.models.OnlineAuthorization): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "merchant_of_record" -> play.api.libs.json.JsString(obj.merchantOfRecord.toString),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "customer" -> io.flow.common.v0.models.json.jsObjectOrderCustomer(obj.customer),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes),
        "result" -> jsObjectAuthorizationResult(obj.result),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt))
      ) ++ (obj.method match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("method" -> io.flow.reference.v0.models.json.jsObjectPaymentMethod(x))
      }) ++
      (obj.details match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("details" -> jsObjectOnlineAuthorizationDetails(x))
      }) ++
      (obj.payment match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("payment" -> x)
      }) ++
      (obj.requested match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("requested" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.destination match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination" -> io.flow.common.v0.models.json.jsObjectAddress(x))
      }) ++
      (obj.billingAddress match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("billing_address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      }) ++
      (obj.order match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order" -> jsObjectAuthorizationOrderReference(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.expiresAt match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("expires_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      }) ++
      (obj.base match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("base" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.processor match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("processor" -> jsObjectExpandablePaymentProcessor(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "online_authorization")
    }

    implicit def jsonWritesPaymentOnlineAuthorization: play.api.libs.json.Writes[OnlineAuthorization] = {
      (obj: io.flow.payment.v0.models.OnlineAuthorization) => {
        jsObjectOnlineAuthorization(obj)
      }
    }

    implicit def jsonReadsPaymentOnlinePaymentAuthorizationForm: play.api.libs.json.Reads[OnlinePaymentAuthorizationForm] = {
      for {
        paymentId <- (__ \ "payment_id").read[String]
        key <- (__ \ "key").readNullable[String]
      } yield OnlinePaymentAuthorizationForm(paymentId, key)
    }

    def jsObjectOnlinePaymentAuthorizationForm(obj: io.flow.payment.v0.models.OnlinePaymentAuthorizationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "payment_id" -> play.api.libs.json.JsString(obj.paymentId)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "online_payment_authorization_form")
    }

    implicit def jsonWritesPaymentOnlinePaymentAuthorizationForm: play.api.libs.json.Writes[OnlinePaymentAuthorizationForm] = {
      (obj: io.flow.payment.v0.models.OnlinePaymentAuthorizationForm) => {
        jsObjectOnlinePaymentAuthorizationForm(obj)
      }
    }

    implicit def jsonReadsPaymentPaymentCryptopay: play.api.libs.json.Reads[PaymentCryptopay] = {
      for {
        id <- (__ \ "id").read[String]
        order <- (__ \ "order").readNullable[io.flow.payment.v0.models.AuthorizationOrderReference]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        cryptopay <- (__ \ "cryptopay").read[io.flow.payment.v0.models.OnlineAuthorizationDetails]
      } yield PaymentCryptopay(id, order, amount, currency, cryptopay)
    }

    def jsObjectPaymentCryptopay(obj: io.flow.payment.v0.models.PaymentCryptopay): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "cryptopay" -> jsObjectOnlineAuthorizationDetails(obj.cryptopay)
      ) ++ (obj.order match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order" -> jsObjectAuthorizationOrderReference(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "payment_cryptopay")
    }

    implicit def jsonWritesPaymentPaymentCryptopay: play.api.libs.json.Writes[PaymentCryptopay] = {
      (obj: io.flow.payment.v0.models.PaymentCryptopay) => {
        jsObjectPaymentCryptopay(obj)
      }
    }

    implicit def jsonReadsPaymentPaymentError: play.api.libs.json.Reads[PaymentError] = {
      for {
        code <- (__ \ "code").read[String]
        messages <- (__ \ "messages").read[Seq[String]]
        codes <- (__ \ "codes").read[Seq[io.flow.payment.v0.models.PaymentErrorCode]]
      } yield PaymentError(code, messages, codes)
    }

    def jsObjectPaymentError(obj: io.flow.payment.v0.models.PaymentError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages),
        "codes" -> play.api.libs.json.Json.toJson(obj.codes)
      )
    }

    implicit def jsonWritesPaymentPaymentError: play.api.libs.json.Writes[PaymentError] = {
      (obj: io.flow.payment.v0.models.PaymentError) => {
        jsObjectPaymentError(obj)
      }
    }

    implicit def jsonReadsPaymentPaymentPaypal: play.api.libs.json.Reads[PaymentPaypal] = {
      for {
        id <- (__ \ "id").read[String]
        order <- (__ \ "order").readNullable[io.flow.payment.v0.models.AuthorizationOrderReference]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        paypal <- (__ \ "paypal").read[io.flow.payment.v0.models.OnlineAuthorizationDetails]
      } yield PaymentPaypal(id, order, amount, currency, paypal)
    }

    def jsObjectPaymentPaypal(obj: io.flow.payment.v0.models.PaymentPaypal): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "paypal" -> jsObjectOnlineAuthorizationDetails(obj.paypal)
      ) ++ (obj.order match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order" -> jsObjectAuthorizationOrderReference(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "payment_paypal")
    }

    implicit def jsonWritesPaymentPaymentPaypal: play.api.libs.json.Writes[PaymentPaypal] = {
      (obj: io.flow.payment.v0.models.PaymentPaypal) => {
        jsObjectPaymentPaypal(obj)
      }
    }

    implicit def jsonReadsPaymentPaymentProcessor: play.api.libs.json.Reads[PaymentProcessor] = {
      for {
        processor <- (__ \ "processor").read[String]
        operationIdentifier <- (__ \ "operation_identifier").readNullable[io.flow.payment.v0.models.PaymentProcessorIdentifier]
        account <- (__ \ "account").readNullable[io.flow.payment.v0.models.PaymentProcessorAccount]
      } yield PaymentProcessor(processor, operationIdentifier, account)
    }

    def jsObjectPaymentProcessor(obj: io.flow.payment.v0.models.PaymentProcessor): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "processor" -> play.api.libs.json.JsString(obj.processor)
      ) ++ (obj.operationIdentifier match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("operation_identifier" -> jsObjectPaymentProcessorIdentifier(x))
      }) ++
      (obj.account match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("account" -> jsObjectPaymentProcessorAccount(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "payment_processor")
    }

    implicit def jsonWritesPaymentPaymentProcessor: play.api.libs.json.Writes[PaymentProcessor] = {
      (obj: io.flow.payment.v0.models.PaymentProcessor) => {
        jsObjectPaymentProcessor(obj)
      }
    }

    implicit def jsonReadsPaymentPaymentProcessorAccount: play.api.libs.json.Reads[PaymentProcessorAccount] = {
      for {
        organization <- (__ \ "organization").read[String]
        key <- (__ \ "key").read[String]
        identifier <- (__ \ "identifier").read[io.flow.payment.v0.models.PaymentProcessorIdentifier]
        parentAccount <- (__ \ "parent_account").readNullable[io.flow.payment.v0.models.PaymentProcessorAccountReference]
      } yield PaymentProcessorAccount(organization, key, identifier, parentAccount)
    }

    def jsObjectPaymentProcessorAccount(obj: io.flow.payment.v0.models.PaymentProcessorAccount): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "key" -> play.api.libs.json.JsString(obj.key),
        "identifier" -> jsObjectPaymentProcessorIdentifier(obj.identifier)
      ) ++ (obj.parentAccount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("parent_account" -> jsObjectPaymentProcessorAccountReference(x))
      })
    }

    implicit def jsonWritesPaymentPaymentProcessorAccount: play.api.libs.json.Writes[PaymentProcessorAccount] = {
      (obj: io.flow.payment.v0.models.PaymentProcessorAccount) => {
        jsObjectPaymentProcessorAccount(obj)
      }
    }

    implicit def jsonReadsPaymentPaymentProcessorAccountReference: play.api.libs.json.Reads[PaymentProcessorAccountReference] = {
      for {
        organization <- (__ \ "organization").read[String]
        key <- (__ \ "key").read[String]
      } yield PaymentProcessorAccountReference(organization, key)
    }

    def jsObjectPaymentProcessorAccountReference(obj: io.flow.payment.v0.models.PaymentProcessorAccountReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonWritesPaymentPaymentProcessorAccountReference: play.api.libs.json.Writes[PaymentProcessorAccountReference] = {
      (obj: io.flow.payment.v0.models.PaymentProcessorAccountReference) => {
        jsObjectPaymentProcessorAccountReference(obj)
      }
    }

    implicit def jsonReadsPaymentPaymentProcessorIdentifier: play.api.libs.json.Reads[PaymentProcessorIdentifier] = {
      for {
        id <- (__ \ "id").read[String]
        label <- (__ \ "label").read[String]
      } yield PaymentProcessorIdentifier(id, label)
    }

    def jsObjectPaymentProcessorIdentifier(obj: io.flow.payment.v0.models.PaymentProcessorIdentifier): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "label" -> play.api.libs.json.JsString(obj.label)
      )
    }

    implicit def jsonWritesPaymentPaymentProcessorIdentifier: play.api.libs.json.Writes[PaymentProcessorIdentifier] = {
      (obj: io.flow.payment.v0.models.PaymentProcessorIdentifier) => {
        jsObjectPaymentProcessorIdentifier(obj)
      }
    }

    implicit def jsonReadsPaymentPaymentProcessorReference: play.api.libs.json.Reads[PaymentProcessorReference] = {
      (__ \ "processor").read[String].map { x => new PaymentProcessorReference(processor = x) }
    }

    def jsObjectPaymentProcessorReference(obj: io.flow.payment.v0.models.PaymentProcessorReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "processor" -> play.api.libs.json.JsString(obj.processor)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "payment_processor_reference")
    }

    implicit def jsonWritesPaymentPaymentProcessorReference: play.api.libs.json.Writes[PaymentProcessorReference] = {
      (obj: io.flow.payment.v0.models.PaymentProcessorReference) => {
        jsObjectPaymentProcessorReference(obj)
      }
    }

    implicit def jsonReadsPaymentPaymentReference: play.api.libs.json.Reads[PaymentReference] = {
      (__ \ "id").read[String].map { x => new PaymentReference(id = x) }
    }

    def jsObjectPaymentReference(obj: io.flow.payment.v0.models.PaymentReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesPaymentPaymentReference: play.api.libs.json.Writes[PaymentReference] = {
      (obj: io.flow.payment.v0.models.PaymentReference) => {
        jsObjectPaymentReference(obj)
      }
    }

    implicit def jsonReadsPaymentPaymentSourceConfirmationAction: play.api.libs.json.Reads[PaymentSourceConfirmationAction] = {
      (__ \ "type").read[io.flow.payment.v0.models.PaymentSourceConfirmationActionType].map { x => new PaymentSourceConfirmationAction(`type` = x) }
    }

    def jsObjectPaymentSourceConfirmationAction(obj: io.flow.payment.v0.models.PaymentSourceConfirmationAction): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      )
    }

    implicit def jsonWritesPaymentPaymentSourceConfirmationAction: play.api.libs.json.Writes[PaymentSourceConfirmationAction] = {
      (obj: io.flow.payment.v0.models.PaymentSourceConfirmationAction) => {
        jsObjectPaymentSourceConfirmationAction(obj)
      }
    }

    implicit def jsonReadsPaymentPaymentVersion: play.api.libs.json.Reads[PaymentVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        payment <- (__ \ "payment").read[io.flow.payment.v0.models.Payment]
      } yield PaymentVersion(id, timestamp, `type`, payment)
    }

    def jsObjectPaymentVersion(obj: io.flow.payment.v0.models.PaymentVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "payment" -> jsObjectPayment(obj.payment)
      )
    }

    implicit def jsonWritesPaymentPaymentVersion: play.api.libs.json.Writes[PaymentVersion] = {
      (obj: io.flow.payment.v0.models.PaymentVersion) => {
        jsObjectPaymentVersion(obj)
      }
    }

    implicit def jsonReadsPaymentPaypalAuthorizationDetails: play.api.libs.json.Reads[PaypalAuthorizationDetails] = {
      for {
        paymentId <- (__ \ "payment_id").read[String]
        paymentMethod <- (__ \ "payment_method").readNullable[String]
        paymentState <- (__ \ "payment_state").readNullable[String]
        payerEmail <- (__ \ "payer_email").readNullable[String]
        payerStatus <- (__ \ "payer_status").readNullable[String]
      } yield PaypalAuthorizationDetails(paymentId, paymentMethod, paymentState, payerEmail, payerStatus)
    }

    def jsObjectPaypalAuthorizationDetails(obj: io.flow.payment.v0.models.PaypalAuthorizationDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "payment_id" -> play.api.libs.json.JsString(obj.paymentId)
      ) ++ (obj.paymentMethod match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("payment_method" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.paymentState match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("payment_state" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.payerEmail match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("payer_email" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.payerStatus match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("payer_status" -> play.api.libs.json.JsString(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "paypal_authorization_details")
    }

    implicit def jsonWritesPaymentPaypalAuthorizationDetails: play.api.libs.json.Writes[PaypalAuthorizationDetails] = {
      (obj: io.flow.payment.v0.models.PaypalAuthorizationDetails) => {
        jsObjectPaypalAuthorizationDetails(obj)
      }
    }

    implicit def jsonReadsPaymentPaypalAuthorizationForm: play.api.libs.json.Reads[PaypalAuthorizationForm] = {
      for {
        paypalPaymentId <- (__ \ "paypal_payment_id").read[String]
        paypalPayerId <- (__ \ "paypal_payer_id").read[String]
        key <- (__ \ "key").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        ip <- (__ \ "ip").readNullable[String]
      } yield PaypalAuthorizationForm(paypalPaymentId, paypalPayerId, key, attributes, ip)
    }

    def jsObjectPaypalAuthorizationForm(obj: io.flow.payment.v0.models.PaypalAuthorizationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "paypal_payment_id" -> play.api.libs.json.JsString(obj.paypalPaymentId),
        "paypal_payer_id" -> play.api.libs.json.JsString(obj.paypalPayerId)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "paypal_authorization_form")
    }

    implicit def jsonWritesPaymentPaypalAuthorizationForm: play.api.libs.json.Writes[PaypalAuthorizationForm] = {
      (obj: io.flow.payment.v0.models.PaypalAuthorizationForm) => {
        jsObjectPaypalAuthorizationForm(obj)
      }
    }

    implicit def jsonReadsPaymentPostPaymentRedirectUrls: play.api.libs.json.Reads[PostPaymentRedirectUrls] = {
      for {
        success <- (__ \ "success").read[String]
        failure <- (__ \ "failure").readNullable[String]
      } yield PostPaymentRedirectUrls(success, failure)
    }

    def jsObjectPostPaymentRedirectUrls(obj: io.flow.payment.v0.models.PostPaymentRedirectUrls): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "success" -> play.api.libs.json.JsString(obj.success)
      ) ++ (obj.failure match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("failure" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesPaymentPostPaymentRedirectUrls: play.api.libs.json.Writes[PostPaymentRedirectUrls] = {
      (obj: io.flow.payment.v0.models.PostPaymentRedirectUrls) => {
        jsObjectPostPaymentRedirectUrls(obj)
      }
    }

    implicit def jsonReadsPaymentPublicKey: play.api.libs.json.Reads[PublicKey] = {
      (__ \ "id").read[String].map { x => new PublicKey(id = x) }
    }

    def jsObjectPublicKey(obj: io.flow.payment.v0.models.PublicKey): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesPaymentPublicKey: play.api.libs.json.Writes[PublicKey] = {
      (obj: io.flow.payment.v0.models.PublicKey) => {
        jsObjectPublicKey(obj)
      }
    }

    implicit def jsonReadsPaymentRedirectAuthorizationDetails: play.api.libs.json.Reads[RedirectAuthorizationDetails] = {
      for {
        id <- (__ \ "id").read[String]
        paymentRedirectUrl <- (__ \ "payment_redirect_url").read[String]
        confirmationDetails <- (__ \ "confirmation_details").readNullable[io.flow.payment.v0.models.ConfirmationDetails]
      } yield RedirectAuthorizationDetails(id, paymentRedirectUrl, confirmationDetails)
    }

    def jsObjectRedirectAuthorizationDetails(obj: io.flow.payment.v0.models.RedirectAuthorizationDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "payment_redirect_url" -> play.api.libs.json.JsString(obj.paymentRedirectUrl)
      ) ++ (obj.confirmationDetails match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("confirmation_details" -> jsObjectConfirmationDetails(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "redirect_authorization_details")
    }

    implicit def jsonWritesPaymentRedirectAuthorizationDetails: play.api.libs.json.Writes[RedirectAuthorizationDetails] = {
      (obj: io.flow.payment.v0.models.RedirectAuthorizationDetails) => {
        jsObjectRedirectAuthorizationDetails(obj)
      }
    }

    implicit def jsonReadsPaymentRedirectAuthorizationForm: play.api.libs.json.Reads[RedirectAuthorizationForm] = {
      for {
        method <- (__ \ "method").read[String]
        issuer <- (__ \ "issuer").readNullable[io.flow.payment.v0.models.IssuerReference]
        orderNumber <- (__ \ "order_number").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        redirectUrls <- (__ \ "redirect_urls").read[io.flow.payment.v0.models.PostPaymentRedirectUrls]
        key <- (__ \ "key").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        ip <- (__ \ "ip").readNullable[String]
      } yield RedirectAuthorizationForm(method, issuer, orderNumber, amount, currency, redirectUrls, key, attributes, ip)
    }

    def jsObjectRedirectAuthorizationForm(obj: io.flow.payment.v0.models.RedirectAuthorizationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "method" -> play.api.libs.json.JsString(obj.method),
        "order_number" -> play.api.libs.json.JsString(obj.orderNumber),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "redirect_urls" -> jsObjectPostPaymentRedirectUrls(obj.redirectUrls)
      ) ++ (obj.issuer match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("issuer" -> jsObjectIssuerReference(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "redirect_authorization_form")
    }

    implicit def jsonWritesPaymentRedirectAuthorizationForm: play.api.libs.json.Writes[RedirectAuthorizationForm] = {
      (obj: io.flow.payment.v0.models.RedirectAuthorizationForm) => {
        jsObjectRedirectAuthorizationForm(obj)
      }
    }

    implicit def jsonReadsPaymentRefund: play.api.libs.json.Reads[Refund] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        authorization <- (__ \ "authorization").read[io.flow.payment.v0.models.AuthorizationReference]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        requested <- (__ \ "requested").readNullable[io.flow.common.v0.models.Money]
        captures <- (__ \ "captures").read[Seq[io.flow.payment.v0.models.RefundCaptureSummary]]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        status <- (__ \ "status").readWithDefault[io.flow.payment.v0.models.RefundStatus](io.flow.payment.v0.models.RefundStatus.Succeeded)
        base <- (__ \ "base").readNullable[io.flow.common.v0.models.Money]
      } yield Refund(id, key, authorization, amount, currency, requested, captures, createdAt, attributes, status, base)
    }

    def jsObjectRefund(obj: io.flow.payment.v0.models.Refund): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "authorization" -> jsObjectAuthorizationReference(obj.authorization),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "captures" -> play.api.libs.json.Json.toJson(obj.captures),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt)),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.requested match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("requested" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.base match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("base" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      })
    }

    implicit def jsonWritesPaymentRefund: play.api.libs.json.Writes[Refund] = {
      (obj: io.flow.payment.v0.models.Refund) => {
        jsObjectRefund(obj)
      }
    }

    implicit def jsonReadsPaymentRefundCapture: play.api.libs.json.Reads[RefundCapture] = {
      for {
        id <- (__ \ "id").read[String]
        refund <- (__ \ "refund").read[io.flow.payment.v0.models.Refund]
        capture <- (__ \ "capture").read[io.flow.payment.v0.models.Capture]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        base <- (__ \ "base").read[io.flow.common.v0.models.Money]
        status <- (__ \ "status").readWithDefault[io.flow.payment.v0.models.RefundStatus](io.flow.payment.v0.models.RefundStatus.Succeeded)
      } yield RefundCapture(id, refund, capture, amount, currency, base, status)
    }

    def jsObjectRefundCapture(obj: io.flow.payment.v0.models.RefundCapture): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "refund" -> jsObjectRefund(obj.refund),
        "capture" -> jsObjectCapture(obj.capture),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "base" -> io.flow.common.v0.models.json.jsObjectMoney(obj.base),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      )
    }

    implicit def jsonWritesPaymentRefundCapture: play.api.libs.json.Writes[RefundCapture] = {
      (obj: io.flow.payment.v0.models.RefundCapture) => {
        jsObjectRefundCapture(obj)
      }
    }

    implicit def jsonReadsPaymentRefundCaptureSummary: play.api.libs.json.Reads[RefundCaptureSummary] = {
      for {
        capture <- (__ \ "capture").read[io.flow.payment.v0.models.Capture]
        amount <- (__ \ "amount").read[BigDecimal]
      } yield RefundCaptureSummary(capture, amount)
    }

    def jsObjectRefundCaptureSummary(obj: io.flow.payment.v0.models.RefundCaptureSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "capture" -> jsObjectCapture(obj.capture),
        "amount" -> play.api.libs.json.JsNumber(obj.amount)
      )
    }

    implicit def jsonWritesPaymentRefundCaptureSummary: play.api.libs.json.Writes[RefundCaptureSummary] = {
      (obj: io.flow.payment.v0.models.RefundCaptureSummary) => {
        jsObjectRefundCaptureSummary(obj)
      }
    }

    implicit def jsonReadsPaymentRefundError: play.api.libs.json.Reads[RefundError] = {
      for {
        code <- (__ \ "code").read[io.flow.error.v0.models.GenericErrorCode]
        messages <- (__ \ "messages").read[Seq[String]]
        declineCode <- (__ \ "decline_code").read[io.flow.payment.v0.models.RefundDeclineCode]
      } yield RefundError(code, messages, declineCode)
    }

    def jsObjectRefundError(obj: io.flow.payment.v0.models.RefundError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages),
        "decline_code" -> play.api.libs.json.JsString(obj.declineCode.toString)
      )
    }

    implicit def jsonWritesPaymentRefundError: play.api.libs.json.Writes[RefundError] = {
      (obj: io.flow.payment.v0.models.RefundError) => {
        jsObjectRefundError(obj)
      }
    }

    implicit def jsonReadsPaymentRefundForm: play.api.libs.json.Reads[RefundForm] = {
      for {
        authorizationId <- (__ \ "authorization_id").readNullable[String]
        captureId <- (__ \ "capture_id").readNullable[String]
        orderNumber <- (__ \ "order_number").readNullable[String]
        key <- (__ \ "key").readNullable[String]
        amount <- (__ \ "amount").readNullable[BigDecimal]
        currency <- (__ \ "currency").readNullable[String]
        rmaKey <- (__ \ "rma_key").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield RefundForm(authorizationId, captureId, orderNumber, key, amount, currency, rmaKey, attributes)
    }

    def jsObjectRefundForm(obj: io.flow.payment.v0.models.RefundForm): play.api.libs.json.JsObject = {
      (obj.authorizationId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("authorization_id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.captureId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("capture_id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.orderNumber match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order_number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.amount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("amount" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.rmaKey match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("rma_key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesPaymentRefundForm: play.api.libs.json.Writes[RefundForm] = {
      (obj: io.flow.payment.v0.models.RefundForm) => {
        jsObjectRefundForm(obj)
      }
    }

    implicit def jsonReadsPaymentRefundIdentifier: play.api.libs.json.Reads[RefundIdentifier] = {
      for {
        id <- (__ \ "id").read[String]
        refund <- (__ \ "refund").read[io.flow.payment.v0.models.RefundReference]
        name <- (__ \ "name").read[String]
        identifier <- (__ \ "identifier").read[String]
        primary <- (__ \ "primary").read[Boolean]
      } yield RefundIdentifier(id, refund, name, identifier, primary)
    }

    def jsObjectRefundIdentifier(obj: io.flow.payment.v0.models.RefundIdentifier): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "refund" -> jsObjectRefundReference(obj.refund),
        "name" -> play.api.libs.json.JsString(obj.name),
        "identifier" -> play.api.libs.json.JsString(obj.identifier),
        "primary" -> play.api.libs.json.JsBoolean(obj.primary)
      )
    }

    implicit def jsonWritesPaymentRefundIdentifier: play.api.libs.json.Writes[RefundIdentifier] = {
      (obj: io.flow.payment.v0.models.RefundIdentifier) => {
        jsObjectRefundIdentifier(obj)
      }
    }

    implicit def jsonReadsPaymentRefundOrderSummary: play.api.libs.json.Reads[RefundOrderSummary] = {
      for {
        orderNumber <- (__ \ "order_number").read[String]
        currency <- (__ \ "currency").read[String]
        captured <- (__ \ "captured").read[BigDecimal]
        refunded <- (__ \ "refunded").read[BigDecimal]
        amounts <- (__ \ "amounts").read[io.flow.payment.v0.models.RefundOrderSummaryAmounts]
      } yield RefundOrderSummary(orderNumber, currency, captured, refunded, amounts)
    }

    def jsObjectRefundOrderSummary(obj: io.flow.payment.v0.models.RefundOrderSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "order_number" -> play.api.libs.json.JsString(obj.orderNumber),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "captured" -> play.api.libs.json.JsNumber(obj.captured),
        "refunded" -> play.api.libs.json.JsNumber(obj.refunded),
        "amounts" -> jsObjectRefundOrderSummaryAmounts(obj.amounts)
      )
    }

    implicit def jsonWritesPaymentRefundOrderSummary: play.api.libs.json.Writes[RefundOrderSummary] = {
      (obj: io.flow.payment.v0.models.RefundOrderSummary) => {
        jsObjectRefundOrderSummary(obj)
      }
    }

    implicit def jsonReadsPaymentRefundOrderSummaryAmounts: play.api.libs.json.Reads[RefundOrderSummaryAmounts] = {
      for {
        balance <- (__ \ "balance").read[BigDecimal]
        balanceExcludingShipping <- (__ \ "balance_excluding_shipping").readNullable[BigDecimal]
        shipping <- (__ \ "shipping").readNullable[BigDecimal]
      } yield RefundOrderSummaryAmounts(balance, balanceExcludingShipping, shipping)
    }

    def jsObjectRefundOrderSummaryAmounts(obj: io.flow.payment.v0.models.RefundOrderSummaryAmounts): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "balance" -> play.api.libs.json.JsNumber(obj.balance)
      ) ++ (obj.balanceExcludingShipping match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("balance_excluding_shipping" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.shipping match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("shipping" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesPaymentRefundOrderSummaryAmounts: play.api.libs.json.Writes[RefundOrderSummaryAmounts] = {
      (obj: io.flow.payment.v0.models.RefundOrderSummaryAmounts) => {
        jsObjectRefundOrderSummaryAmounts(obj)
      }
    }

    implicit def jsonReadsPaymentRefundReference: play.api.libs.json.Reads[RefundReference] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
      } yield RefundReference(id, key)
    }

    def jsObjectRefundReference(obj: io.flow.payment.v0.models.RefundReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonWritesPaymentRefundReference: play.api.libs.json.Writes[RefundReference] = {
      (obj: io.flow.payment.v0.models.RefundReference) => {
        jsObjectRefundReference(obj)
      }
    }

    implicit def jsonReadsPaymentRefundVersion: play.api.libs.json.Reads[RefundVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        refund <- (__ \ "refund").read[io.flow.payment.v0.models.Refund]
      } yield RefundVersion(id, timestamp, `type`, refund)
    }

    def jsObjectRefundVersion(obj: io.flow.payment.v0.models.RefundVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "refund" -> jsObjectRefund(obj.refund)
      )
    }

    implicit def jsonWritesPaymentRefundVersion: play.api.libs.json.Writes[RefundVersion] = {
      (obj: io.flow.payment.v0.models.RefundVersion) => {
        jsObjectRefundVersion(obj)
      }
    }

    implicit def jsonReadsPaymentReversal: play.api.libs.json.Reads[Reversal] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        authorization <- (__ \ "authorization").read[io.flow.payment.v0.models.AuthorizationReference]
        status <- (__ \ "status").read[io.flow.payment.v0.models.ReversalStatus]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        requested <- (__ \ "requested").read[io.flow.common.v0.models.Money]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
        attributes <- (__ \ "attributes").read[Map[String, String]]
        base <- (__ \ "base").readNullable[io.flow.common.v0.models.Money]
      } yield Reversal(id, key, authorization, status, amount, currency, requested, createdAt, attributes, base)
    }

    def jsObjectReversal(obj: io.flow.payment.v0.models.Reversal): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "authorization" -> jsObjectAuthorizationReference(obj.authorization),
        "status" -> play.api.libs.json.JsString(obj.status.toString),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "requested" -> io.flow.common.v0.models.json.jsObjectMoney(obj.requested),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt)),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      ) ++ (obj.base match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("base" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      })
    }

    implicit def jsonWritesPaymentReversal: play.api.libs.json.Writes[Reversal] = {
      (obj: io.flow.payment.v0.models.Reversal) => {
        jsObjectReversal(obj)
      }
    }

    implicit def jsonReadsPaymentReversalError: play.api.libs.json.Reads[ReversalError] = {
      for {
        code <- (__ \ "code").read[String]
        messages <- (__ \ "messages").read[Seq[String]]
        codes <- (__ \ "codes").read[Seq[io.flow.payment.v0.models.ReversalErrorCode]]
      } yield ReversalError(code, messages, codes)
    }

    def jsObjectReversalError(obj: io.flow.payment.v0.models.ReversalError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages),
        "codes" -> play.api.libs.json.Json.toJson(obj.codes)
      )
    }

    implicit def jsonWritesPaymentReversalError: play.api.libs.json.Writes[ReversalError] = {
      (obj: io.flow.payment.v0.models.ReversalError) => {
        jsObjectReversalError(obj)
      }
    }

    implicit def jsonReadsPaymentReversalForm: play.api.libs.json.Reads[ReversalForm] = {
      for {
        key <- (__ \ "key").readNullable[String]
        authorizationId <- (__ \ "authorization_id").read[String]
        amount <- (__ \ "amount").readNullable[BigDecimal]
        currency <- (__ \ "currency").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield ReversalForm(key, authorizationId, amount, currency, attributes)
    }

    def jsObjectReversalForm(obj: io.flow.payment.v0.models.ReversalForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "authorization_id" -> play.api.libs.json.JsString(obj.authorizationId)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.amount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("amount" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesPaymentReversalForm: play.api.libs.json.Writes[ReversalForm] = {
      (obj: io.flow.payment.v0.models.ReversalForm) => {
        jsObjectReversalForm(obj)
      }
    }

    implicit def jsonReadsPaymentReversalPutForm: play.api.libs.json.Reads[ReversalPutForm] = {
      for {
        authorizationId <- (__ \ "authorization_id").read[String]
        amount <- (__ \ "amount").readNullable[BigDecimal]
        currency <- (__ \ "currency").readNullable[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield ReversalPutForm(authorizationId, amount, currency, attributes)
    }

    def jsObjectReversalPutForm(obj: io.flow.payment.v0.models.ReversalPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "authorization_id" -> play.api.libs.json.JsString(obj.authorizationId)
      ) ++ (obj.amount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("amount" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesPaymentReversalPutForm: play.api.libs.json.Writes[ReversalPutForm] = {
      (obj: io.flow.payment.v0.models.ReversalPutForm) => {
        jsObjectReversalPutForm(obj)
      }
    }

    implicit def jsonReadsPaymentReversalVersion: play.api.libs.json.Reads[ReversalVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        reversal <- (__ \ "reversal").read[io.flow.payment.v0.models.Reversal]
      } yield ReversalVersion(id, timestamp, `type`, reversal)
    }

    def jsObjectReversalVersion(obj: io.flow.payment.v0.models.ReversalVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "reversal" -> jsObjectReversal(obj.reversal)
      )
    }

    implicit def jsonWritesPaymentReversalVersion: play.api.libs.json.Writes[ReversalVersion] = {
      (obj: io.flow.payment.v0.models.ReversalVersion) => {
        jsObjectReversalVersion(obj)
      }
    }

    implicit def jsonReadsPaymentStripeAuthenticationData: play.api.libs.json.Reads[StripeAuthenticationData] = {
      (__ \ "secret_key_reference").read[String].map { x => new StripeAuthenticationData(secretKeyReference = x) }
    }

    def jsObjectStripeAuthenticationData(obj: io.flow.payment.v0.models.StripeAuthenticationData): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "secret_key_reference" -> play.api.libs.json.JsString(obj.secretKeyReference)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "stripe_authentication_data")
    }

    implicit def jsonWritesPaymentStripeAuthenticationData: play.api.libs.json.Writes[StripeAuthenticationData] = {
      (obj: io.flow.payment.v0.models.StripeAuthenticationData) => {
        jsObjectStripeAuthenticationData(obj)
      }
    }

    implicit def jsonReadsPaymentStripeAuthenticationDataForm: play.api.libs.json.Reads[StripeAuthenticationDataForm] = {
      for {
        accountId <- (__ \ "account_id").read[String]
        secretKey <- (__ \ "secret_key").read[String]
        key <- (__ \ "key").readNullable[String]
      } yield StripeAuthenticationDataForm(accountId, secretKey, key)
    }

    def jsObjectStripeAuthenticationDataForm(obj: io.flow.payment.v0.models.StripeAuthenticationDataForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "account_id" -> play.api.libs.json.JsString(obj.accountId),
        "secret_key" -> play.api.libs.json.JsString(obj.secretKey)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "stripe_authentication_data_form")
    }

    implicit def jsonWritesPaymentStripeAuthenticationDataForm: play.api.libs.json.Writes[StripeAuthenticationDataForm] = {
      (obj: io.flow.payment.v0.models.StripeAuthenticationDataForm) => {
        jsObjectStripeAuthenticationDataForm(obj)
      }
    }

    implicit def jsonReadsPaymentStripeAuthorizationResultActionDetails: play.api.libs.json.Reads[StripeAuthorizationResultActionDetails] = {
      for {
        clientSecret <- (__ \ "client_secret").readNullable[String]
        paymentMethodId <- (__ \ "payment_method_id").readNullable[String]
        publishableKey <- (__ \ "publishable_key").readNullable[String]
      } yield StripeAuthorizationResultActionDetails(clientSecret, paymentMethodId, publishableKey)
    }

    def jsObjectStripeAuthorizationResultActionDetails(obj: io.flow.payment.v0.models.StripeAuthorizationResultActionDetails): play.api.libs.json.JsObject = {
      (obj.clientSecret match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("client_secret" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.paymentMethodId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("payment_method_id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.publishableKey match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("publishable_key" -> play.api.libs.json.JsString(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "stripe_authorization_result_action_details")
    }

    implicit def jsonWritesPaymentStripeAuthorizationResultActionDetails: play.api.libs.json.Writes[StripeAuthorizationResultActionDetails] = {
      (obj: io.flow.payment.v0.models.StripeAuthorizationResultActionDetails) => {
        jsObjectStripeAuthorizationResultActionDetails(obj)
      }
    }

    implicit def jsonReadsPaymentThreeDSecure: play.api.libs.json.Reads[ThreeDSecure] = {
      for {
        code <- (__ \ "code").read[io.flow.payment.v0.models.ThreeDSecureCode]
        description <- (__ \ "description").readNullable[String]
      } yield ThreeDSecure(code, description)
    }

    def jsObjectThreeDSecure(obj: io.flow.payment.v0.models.ThreeDSecure): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesPaymentThreeDSecure: play.api.libs.json.Writes[ThreeDSecure] = {
      (obj: io.flow.payment.v0.models.ThreeDSecure) => {
        jsObjectThreeDSecure(obj)
      }
    }

    implicit def jsonReadsPaymentThreedsChallengeActionDetails: play.api.libs.json.Reads[ThreedsChallengeActionDetails] = {
      for {
        threedsChallengeAction <- (__ \ "threeds_challenge_action").read[io.flow.payment.v0.models.ThreedsChallengeAction]
        expiresAt <- (__ \ "expires_at").read[_root_.org.joda.time.DateTime]
      } yield ThreedsChallengeActionDetails(threedsChallengeAction, expiresAt)
    }

    def jsObjectThreedsChallengeActionDetails(obj: io.flow.payment.v0.models.ThreedsChallengeActionDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "threeds_challenge_action" -> jsObjectThreedsChallengeAction(obj.threedsChallengeAction),
        "expires_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.expiresAt))
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "threeds_challenge_action_details")
    }

    implicit def jsonWritesPaymentThreedsChallengeActionDetails: play.api.libs.json.Writes[ThreedsChallengeActionDetails] = {
      (obj: io.flow.payment.v0.models.ThreedsChallengeActionDetails) => {
        jsObjectThreedsChallengeActionDetails(obj)
      }
    }

    implicit def jsonReadsPaymentThreedsIdentifyActionDetails: play.api.libs.json.Reads[ThreedsIdentifyActionDetails] = {
      for {
        threedsIdentifyAction <- (__ \ "threeds_identify_action").read[io.flow.payment.v0.models.ThreedsIdentifyAction]
        expiresAt <- (__ \ "expires_at").read[_root_.org.joda.time.DateTime]
      } yield ThreedsIdentifyActionDetails(threedsIdentifyAction, expiresAt)
    }

    def jsObjectThreedsIdentifyActionDetails(obj: io.flow.payment.v0.models.ThreedsIdentifyActionDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "threeds_identify_action" -> jsObjectThreedsIdentifyAction(obj.threedsIdentifyAction),
        "expires_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.expiresAt))
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "threeds_identify_action_details")
    }

    implicit def jsonWritesPaymentThreedsIdentifyActionDetails: play.api.libs.json.Writes[ThreedsIdentifyActionDetails] = {
      (obj: io.flow.payment.v0.models.ThreedsIdentifyActionDetails) => {
        jsObjectThreedsIdentifyActionDetails(obj)
      }
    }

    implicit def jsonReadsPaymentThreedsTwoChallengeRequest: play.api.libs.json.Reads[ThreedsTwoChallengeRequest] = {
      for {
        acsUrl <- (__ \ "acs_url").read[String]
        challengeRequest <- (__ \ "challenge_request").read[String]
        sessionData <- (__ \ "session_data").readNullable[String]
      } yield ThreedsTwoChallengeRequest(acsUrl, challengeRequest, sessionData)
    }

    def jsObjectThreedsTwoChallengeRequest(obj: io.flow.payment.v0.models.ThreedsTwoChallengeRequest): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "acs_url" -> play.api.libs.json.JsString(obj.acsUrl),
        "challenge_request" -> play.api.libs.json.JsString(obj.challengeRequest)
      ) ++ (obj.sessionData match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("session_data" -> play.api.libs.json.JsString(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "threeds_two_challenge_request")
    }

    implicit def jsonWritesPaymentThreedsTwoChallengeRequest: play.api.libs.json.Writes[ThreedsTwoChallengeRequest] = {
      (obj: io.flow.payment.v0.models.ThreedsTwoChallengeRequest) => {
        jsObjectThreedsTwoChallengeRequest(obj)
      }
    }

    implicit def jsonReadsPaymentThreedsTwoMethod: play.api.libs.json.Reads[ThreedsTwoMethod] = {
      (__ \ "method").read[String].map { x => new ThreedsTwoMethod(method = x) }
    }

    def jsObjectThreedsTwoMethod(obj: io.flow.payment.v0.models.ThreedsTwoMethod): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "method" -> play.api.libs.json.JsString(obj.method)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "threeds_two_method")
    }

    implicit def jsonWritesPaymentThreedsTwoMethod: play.api.libs.json.Writes[ThreedsTwoMethod] = {
      (obj: io.flow.payment.v0.models.ThreedsTwoMethod) => {
        jsObjectThreedsTwoMethod(obj)
      }
    }

    implicit def jsonReadsPaymentVirtualCard: play.api.libs.json.Reads[VirtualCard] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        number <- (__ \ "number").readNullable[String]
        cvv <- (__ \ "cvv").readNullable[String]
        limit <- (__ \ "limit").read[io.flow.common.v0.models.Price]
        `type` <- (__ \ "type").read[io.flow.payment.v0.models.CardType]
        expiration <- (__ \ "expiration").read[io.flow.payment.v0.models.Expiration]
        iin <- (__ \ "iin").read[String]
        last4 <- (__ \ "last4").read[String]
        name <- (__ \ "name").read[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield VirtualCard(id, key, number, cvv, limit, `type`, expiration, iin, last4, name, attributes)
    }

    def jsObjectVirtualCard(obj: io.flow.payment.v0.models.VirtualCard): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "limit" -> io.flow.common.v0.models.json.jsObjectPrice(obj.limit),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "expiration" -> jsObjectExpiration(obj.expiration),
        "iin" -> play.api.libs.json.JsString(obj.iin),
        "last4" -> play.api.libs.json.JsString(obj.last4),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.number match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.cvv match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cvv" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesPaymentVirtualCard: play.api.libs.json.Writes[VirtualCard] = {
      (obj: io.flow.payment.v0.models.VirtualCard) => {
        jsObjectVirtualCard(obj)
      }
    }

    implicit def jsonReadsPaymentVirtualCardCapture: play.api.libs.json.Reads[VirtualCardCapture] = {
      for {
        id <- (__ \ "id").read[String]
        issuer <- (__ \ "issuer").read[io.flow.payment.v0.models.IssuerV1]
        virtualCard <- (__ \ "virtual_card").read[io.flow.payment.v0.models.VirtualCardReference]
        authorization <- (__ \ "authorization").read[io.flow.payment.v0.models.AuthorizationReference]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
      } yield VirtualCardCapture(id, issuer, virtualCard, authorization, amount, currency, createdAt)
    }

    def jsObjectVirtualCardCapture(obj: io.flow.payment.v0.models.VirtualCardCapture): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "issuer" -> jsObjectIssuerV1(obj.issuer),
        "virtual_card" -> jsObjectVirtualCardReference(obj.virtualCard),
        "authorization" -> jsObjectAuthorizationReference(obj.authorization),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt))
      )
    }

    implicit def jsonWritesPaymentVirtualCardCapture: play.api.libs.json.Writes[VirtualCardCapture] = {
      (obj: io.flow.payment.v0.models.VirtualCardCapture) => {
        jsObjectVirtualCardCapture(obj)
      }
    }

    implicit def jsonReadsPaymentVirtualCardCaptureVersion: play.api.libs.json.Reads[VirtualCardCaptureVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        virtualCardCapture <- (__ \ "virtual_card_capture").read[io.flow.payment.v0.models.VirtualCardCapture]
      } yield VirtualCardCaptureVersion(id, timestamp, `type`, virtualCardCapture)
    }

    def jsObjectVirtualCardCaptureVersion(obj: io.flow.payment.v0.models.VirtualCardCaptureVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "virtual_card_capture" -> jsObjectVirtualCardCapture(obj.virtualCardCapture)
      )
    }

    implicit def jsonWritesPaymentVirtualCardCaptureVersion: play.api.libs.json.Writes[VirtualCardCaptureVersion] = {
      (obj: io.flow.payment.v0.models.VirtualCardCaptureVersion) => {
        jsObjectVirtualCardCaptureVersion(obj)
      }
    }

    implicit def jsonReadsPaymentVirtualCardForm: play.api.libs.json.Reads[VirtualCardForm] = {
      for {
        limit <- (__ \ "limit").read[io.flow.common.v0.models.Money]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield VirtualCardForm(limit, attributes)
    }

    def jsObjectVirtualCardForm(obj: io.flow.payment.v0.models.VirtualCardForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "limit" -> io.flow.common.v0.models.json.jsObjectMoney(obj.limit)
      ) ++ (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesPaymentVirtualCardForm: play.api.libs.json.Writes[VirtualCardForm] = {
      (obj: io.flow.payment.v0.models.VirtualCardForm) => {
        jsObjectVirtualCardForm(obj)
      }
    }

    implicit def jsonReadsPaymentVirtualCardReference: play.api.libs.json.Reads[VirtualCardReference] = {
      (__ \ "id").read[String].map { x => new VirtualCardReference(id = x) }
    }

    def jsObjectVirtualCardReference(obj: io.flow.payment.v0.models.VirtualCardReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesPaymentVirtualCardReference: play.api.libs.json.Writes[VirtualCardReference] = {
      (obj: io.flow.payment.v0.models.VirtualCardReference) => {
        jsObjectVirtualCardReference(obj)
      }
    }

    implicit def jsonReadsPaymentVirtualCardRefund: play.api.libs.json.Reads[VirtualCardRefund] = {
      for {
        id <- (__ \ "id").read[String]
        issuer <- (__ \ "issuer").read[io.flow.payment.v0.models.IssuerV1]
        virtualCard <- (__ \ "virtual_card").read[io.flow.payment.v0.models.VirtualCardReference]
        authorization <- (__ \ "authorization").read[io.flow.payment.v0.models.AuthorizationReference]
        amount <- (__ \ "amount").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
      } yield VirtualCardRefund(id, issuer, virtualCard, authorization, amount, currency, createdAt)
    }

    def jsObjectVirtualCardRefund(obj: io.flow.payment.v0.models.VirtualCardRefund): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "issuer" -> jsObjectIssuerV1(obj.issuer),
        "virtual_card" -> jsObjectVirtualCardReference(obj.virtualCard),
        "authorization" -> jsObjectAuthorizationReference(obj.authorization),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt))
      )
    }

    implicit def jsonWritesPaymentVirtualCardRefund: play.api.libs.json.Writes[VirtualCardRefund] = {
      (obj: io.flow.payment.v0.models.VirtualCardRefund) => {
        jsObjectVirtualCardRefund(obj)
      }
    }

    implicit def jsonReadsPaymentVirtualCardRefundVersion: play.api.libs.json.Reads[VirtualCardRefundVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        virtualCardRefund <- (__ \ "virtual_card_refund").read[io.flow.payment.v0.models.VirtualCardRefund]
      } yield VirtualCardRefundVersion(id, timestamp, `type`, virtualCardRefund)
    }

    def jsObjectVirtualCardRefundVersion(obj: io.flow.payment.v0.models.VirtualCardRefundVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "virtual_card_refund" -> jsObjectVirtualCardRefund(obj.virtualCardRefund)
      )
    }

    implicit def jsonWritesPaymentVirtualCardRefundVersion: play.api.libs.json.Writes[VirtualCardRefundVersion] = {
      (obj: io.flow.payment.v0.models.VirtualCardRefundVersion) => {
        jsObjectVirtualCardRefundVersion(obj)
      }
    }

    implicit def jsonReadsPaymentVirtualCardVersion: play.api.libs.json.Reads[VirtualCardVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        virtualCard <- (__ \ "virtual_card").read[io.flow.payment.v0.models.VirtualCard]
      } yield VirtualCardVersion(id, timestamp, `type`, virtualCard)
    }

    def jsObjectVirtualCardVersion(obj: io.flow.payment.v0.models.VirtualCardVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "virtual_card" -> jsObjectVirtualCard(obj.virtualCard)
      )
    }

    implicit def jsonWritesPaymentVirtualCardVersion: play.api.libs.json.Writes[VirtualCardVersion] = {
      (obj: io.flow.payment.v0.models.VirtualCardVersion) => {
        jsObjectVirtualCardVersion(obj)
      }
    }

    implicit def jsonReadsPaymentAdyenNativeData: play.api.libs.json.Reads[AdyenNativeData] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "adyen_identify_shopper_data" => js.validate[io.flow.payment.v0.models.AdyenIdentifyShopperData]
          case "adyen_challenge_shopper_data" => js.validate[io.flow.payment.v0.models.AdyenChallengeShopperData]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AdyenNativeDataUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectAdyenNativeData(obj: io.flow.payment.v0.models.AdyenNativeData): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.AdyenIdentifyShopperData => jsObjectAdyenIdentifyShopperData(x)
        case x: io.flow.payment.v0.models.AdyenChallengeShopperData => jsObjectAdyenChallengeShopperData(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentAdyenNativeData: play.api.libs.json.Writes[AdyenNativeData] = {
      (obj: io.flow.payment.v0.models.AdyenNativeData) => {
        jsObjectAdyenNativeData(obj)
      }
    }

    implicit def jsonReadsPaymentAuthorization: play.api.libs.json.Reads[Authorization] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "card_authorization" => js.validate[io.flow.payment.v0.models.CardAuthorization]
          case "online_authorization" => js.validate[io.flow.payment.v0.models.OnlineAuthorization]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectAuthorization(obj: io.flow.payment.v0.models.Authorization): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.CardAuthorization => jsObjectCardAuthorization(x)
        case x: io.flow.payment.v0.models.OnlineAuthorization => jsObjectOnlineAuthorization(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentAuthorization: play.api.libs.json.Writes[Authorization] = {
      (obj: io.flow.payment.v0.models.Authorization) => {
        jsObjectAuthorization(obj)
      }
    }

    implicit def jsonReadsPaymentAuthorizationForm: play.api.libs.json.Reads[AuthorizationForm] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "authorization_copy_form" => js.validate[io.flow.payment.v0.models.AuthorizationCopyForm]
          case "direct_authorization_form" => js.validate[io.flow.payment.v0.models.DirectAuthorizationForm]
          case "merchant_of_record_authorization_form" => js.validate[io.flow.payment.v0.models.MerchantOfRecordAuthorizationForm]
          case "paypal_authorization_form" => js.validate[io.flow.payment.v0.models.PaypalAuthorizationForm]
          case "redirect_authorization_form" => js.validate[io.flow.payment.v0.models.RedirectAuthorizationForm]
          case "inline_authorization_form" => js.validate[io.flow.payment.v0.models.InlineAuthorizationForm]
          case "ach_authorization_form" => js.validate[io.flow.payment.v0.models.AchAuthorizationForm]
          case "card_payment_source_authorization_form" => js.validate[io.flow.payment.v0.models.CardPaymentSourceAuthorizationForm]
          case "online_payment_authorization_form" => js.validate[io.flow.payment.v0.models.OnlinePaymentAuthorizationForm]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationFormUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectAuthorizationForm(obj: io.flow.payment.v0.models.AuthorizationForm): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.AuthorizationCopyForm => jsObjectAuthorizationCopyForm(x)
        case x: io.flow.payment.v0.models.DirectAuthorizationForm => jsObjectDirectAuthorizationForm(x)
        case x: io.flow.payment.v0.models.MerchantOfRecordAuthorizationForm => jsObjectMerchantOfRecordAuthorizationForm(x)
        case x: io.flow.payment.v0.models.PaypalAuthorizationForm => jsObjectPaypalAuthorizationForm(x)
        case x: io.flow.payment.v0.models.RedirectAuthorizationForm => jsObjectRedirectAuthorizationForm(x)
        case x: io.flow.payment.v0.models.InlineAuthorizationForm => jsObjectInlineAuthorizationForm(x)
        case x: io.flow.payment.v0.models.AchAuthorizationForm => jsObjectAchAuthorizationForm(x)
        case x: io.flow.payment.v0.models.CardPaymentSourceAuthorizationForm => jsObjectCardPaymentSourceAuthorizationForm(x)
        case x: io.flow.payment.v0.models.OnlinePaymentAuthorizationForm => jsObjectOnlinePaymentAuthorizationForm(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentAuthorizationForm: play.api.libs.json.Writes[AuthorizationForm] = {
      (obj: io.flow.payment.v0.models.AuthorizationForm) => {
        jsObjectAuthorizationForm(obj)
      }
    }

    implicit def jsonReadsPaymentAuthorizationPayloadParameters: play.api.libs.json.Reads[AuthorizationPayloadParameters] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "google_pay_authorization_payload" => js.validate[io.flow.payment.v0.models.GooglePayAuthorizationPayload]
          case "apple_pay_merchant_validation_payload" => js.validate[io.flow.payment.v0.models.ApplePayMerchantValidationPayload]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationPayloadParametersUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectAuthorizationPayloadParameters(obj: io.flow.payment.v0.models.AuthorizationPayloadParameters): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.GooglePayAuthorizationPayload => jsObjectGooglePayAuthorizationPayload(x)
        case x: io.flow.payment.v0.models.ApplePayMerchantValidationPayload => jsObjectApplePayMerchantValidationPayload(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentAuthorizationPayloadParameters: play.api.libs.json.Writes[AuthorizationPayloadParameters] = {
      (obj: io.flow.payment.v0.models.AuthorizationPayloadParameters) => {
        jsObjectAuthorizationPayloadParameters(obj)
      }
    }

    implicit def jsonReadsPaymentAuthorizationResultAction: play.api.libs.json.Reads[AuthorizationResultAction] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "authorization_result_action_get" => js.validate[io.flow.payment.v0.models.AuthorizationResultActionGet]
          case "authorization_result_action_post" => js.validate[io.flow.payment.v0.models.AuthorizationResultActionPost]
          case "authorization_result_action_wait" => js.validate[io.flow.payment.v0.models.AuthorizationResultActionWait]
          case "authorization_result_action_native" => js.validate[io.flow.payment.v0.models.AuthorizationResultActionNative]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationResultActionUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectAuthorizationResultAction(obj: io.flow.payment.v0.models.AuthorizationResultAction): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.AuthorizationResultActionGet => jsObjectAuthorizationResultActionGet(x)
        case x: io.flow.payment.v0.models.AuthorizationResultActionPost => jsObjectAuthorizationResultActionPost(x)
        case x: io.flow.payment.v0.models.AuthorizationResultActionWait => jsObjectAuthorizationResultActionWait(x)
        case x: io.flow.payment.v0.models.AuthorizationResultActionNative => jsObjectAuthorizationResultActionNative(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentAuthorizationResultAction: play.api.libs.json.Writes[AuthorizationResultAction] = {
      (obj: io.flow.payment.v0.models.AuthorizationResultAction) => {
        jsObjectAuthorizationResultAction(obj)
      }
    }

    implicit def jsonReadsPaymentAuthorizationResultActionDetails: play.api.libs.json.Reads[AuthorizationResultActionDetails] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "adyen_native_action_details" => js.validate[io.flow.payment.v0.models.AdyenNativeActionDetails]
          case "stripe_authorization_result_action_details" => js.validate[io.flow.payment.v0.models.StripeAuthorizationResultActionDetails]
          case "threeds_identify_action_details" => js.validate[io.flow.payment.v0.models.ThreedsIdentifyActionDetails]
          case "threeds_challenge_action_details" => js.validate[io.flow.payment.v0.models.ThreedsChallengeActionDetails]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.AuthorizationResultActionDetailsUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectAuthorizationResultActionDetails(obj: io.flow.payment.v0.models.AuthorizationResultActionDetails): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.AdyenNativeActionDetails => jsObjectAdyenNativeActionDetails(x)
        case x: io.flow.payment.v0.models.StripeAuthorizationResultActionDetails => jsObjectStripeAuthorizationResultActionDetails(x)
        case x: io.flow.payment.v0.models.ThreedsIdentifyActionDetails => jsObjectThreedsIdentifyActionDetails(x)
        case x: io.flow.payment.v0.models.ThreedsChallengeActionDetails => jsObjectThreedsChallengeActionDetails(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentAuthorizationResultActionDetails: play.api.libs.json.Writes[AuthorizationResultActionDetails] = {
      (obj: io.flow.payment.v0.models.AuthorizationResultActionDetails) => {
        jsObjectAuthorizationResultActionDetails(obj)
      }
    }

    implicit def jsonReadsPaymentBrowserActionConfiguration: play.api.libs.json.Reads[BrowserActionConfiguration] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "card_browser_action_configuration" => js.validate[io.flow.payment.v0.models.CardBrowserActionConfiguration]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.BrowserActionConfigurationUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectBrowserActionConfiguration(obj: io.flow.payment.v0.models.BrowserActionConfiguration): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.CardBrowserActionConfiguration => jsObjectCardBrowserActionConfiguration(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentBrowserActionConfiguration: play.api.libs.json.Writes[BrowserActionConfiguration] = {
      (obj: io.flow.payment.v0.models.BrowserActionConfiguration) => {
        jsObjectBrowserActionConfiguration(obj)
      }
    }

    implicit def jsonReadsPaymentConfirmationDetails: play.api.libs.json.Reads[ConfirmationDetails] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "direct_debit" => js.validate[io.flow.payment.v0.models.DirectDebit]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ConfirmationDetailsUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectConfirmationDetails(obj: io.flow.payment.v0.models.ConfirmationDetails): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.DirectDebit => jsObjectDirectDebit(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentConfirmationDetails: play.api.libs.json.Writes[ConfirmationDetails] = {
      (obj: io.flow.payment.v0.models.ConfirmationDetails) => {
        jsObjectConfirmationDetails(obj)
      }
    }

    implicit def jsonReadsPaymentExpandableCard: play.api.libs.json.Reads[ExpandableCard] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "card" => js.validate[io.flow.payment.v0.models.Card]
          case "card_reference" => js.validate[io.flow.payment.v0.models.CardReference]
          case "card_summary" => js.validate[io.flow.payment.v0.models.CardSummary]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ExpandableCardUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectExpandableCard(obj: io.flow.payment.v0.models.ExpandableCard): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.Card => jsObjectCard(x)
        case x: io.flow.payment.v0.models.CardReference => jsObjectCardReference(x)
        case x: io.flow.payment.v0.models.CardSummary => jsObjectCardSummary(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentExpandableCard: play.api.libs.json.Writes[ExpandableCard] = {
      (obj: io.flow.payment.v0.models.ExpandableCard) => {
        jsObjectExpandableCard(obj)
      }
    }

    implicit def jsonReadsPaymentExpandablePaymentProcessor: play.api.libs.json.Reads[ExpandablePaymentProcessor] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "payment_processor" => js.validate[io.flow.payment.v0.models.PaymentProcessor]
          case "payment_processor_reference" => js.validate[io.flow.payment.v0.models.PaymentProcessorReference]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ExpandablePaymentProcessorUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectExpandablePaymentProcessor(obj: io.flow.payment.v0.models.ExpandablePaymentProcessor): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.PaymentProcessor => jsObjectPaymentProcessor(x)
        case x: io.flow.payment.v0.models.PaymentProcessorReference => jsObjectPaymentProcessorReference(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentExpandablePaymentProcessor: play.api.libs.json.Writes[ExpandablePaymentProcessor] = {
      (obj: io.flow.payment.v0.models.ExpandablePaymentProcessor) => {
        jsObjectExpandablePaymentProcessor(obj)
      }
    }

    implicit def jsonReadsPaymentGatewayAuthenticationData: play.api.libs.json.Reads[GatewayAuthenticationData] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "stripe_authentication_data" => js.validate[io.flow.payment.v0.models.StripeAuthenticationData]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.GatewayAuthenticationDataUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectGatewayAuthenticationData(obj: io.flow.payment.v0.models.GatewayAuthenticationData): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.StripeAuthenticationData => jsObjectStripeAuthenticationData(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentGatewayAuthenticationData: play.api.libs.json.Writes[GatewayAuthenticationData] = {
      (obj: io.flow.payment.v0.models.GatewayAuthenticationData) => {
        jsObjectGatewayAuthenticationData(obj)
      }
    }

    implicit def jsonReadsPaymentGatewayAuthenticationDataForm: play.api.libs.json.Reads[GatewayAuthenticationDataForm] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "stripe_authentication_data_form" => js.validate[io.flow.payment.v0.models.StripeAuthenticationDataForm]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.GatewayAuthenticationDataFormUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectGatewayAuthenticationDataForm(obj: io.flow.payment.v0.models.GatewayAuthenticationDataForm): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.StripeAuthenticationDataForm => jsObjectStripeAuthenticationDataForm(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentGatewayAuthenticationDataForm: play.api.libs.json.Writes[GatewayAuthenticationDataForm] = {
      (obj: io.flow.payment.v0.models.GatewayAuthenticationDataForm) => {
        jsObjectGatewayAuthenticationDataForm(obj)
      }
    }

    implicit def jsonReadsPaymentInlineActionConfiguration: play.api.libs.json.Reads[InlineActionConfiguration] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "browser_inline_action_configuration" => js.validate[io.flow.payment.v0.models.BrowserInlineActionConfiguration]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.InlineActionConfigurationUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectInlineActionConfiguration(obj: io.flow.payment.v0.models.InlineActionConfiguration): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.BrowserInlineActionConfiguration => jsObjectBrowserInlineActionConfiguration(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentInlineActionConfiguration: play.api.libs.json.Writes[InlineActionConfiguration] = {
      (obj: io.flow.payment.v0.models.InlineActionConfiguration) => {
        jsObjectInlineActionConfiguration(obj)
      }
    }

    implicit def jsonReadsPaymentOnlineAuthorizationDetails: play.api.libs.json.Reads[OnlineAuthorizationDetails] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "cryptopay_authorization_details" => js.validate[io.flow.payment.v0.models.CryptopayAuthorizationDetails]
          case "paypal_authorization_details" => js.validate[io.flow.payment.v0.models.PaypalAuthorizationDetails]
          case "redirect_authorization_details" => js.validate[io.flow.payment.v0.models.RedirectAuthorizationDetails]
          case "inline_authorization_details" => js.validate[io.flow.payment.v0.models.InlineAuthorizationDetails]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.OnlineAuthorizationDetailsUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectOnlineAuthorizationDetails(obj: io.flow.payment.v0.models.OnlineAuthorizationDetails): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.CryptopayAuthorizationDetails => jsObjectCryptopayAuthorizationDetails(x)
        case x: io.flow.payment.v0.models.PaypalAuthorizationDetails => jsObjectPaypalAuthorizationDetails(x)
        case x: io.flow.payment.v0.models.RedirectAuthorizationDetails => jsObjectRedirectAuthorizationDetails(x)
        case x: io.flow.payment.v0.models.InlineAuthorizationDetails => jsObjectInlineAuthorizationDetails(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentOnlineAuthorizationDetails: play.api.libs.json.Writes[OnlineAuthorizationDetails] = {
      (obj: io.flow.payment.v0.models.OnlineAuthorizationDetails) => {
        jsObjectOnlineAuthorizationDetails(obj)
      }
    }

    implicit def jsonReadsPaymentPayment: play.api.libs.json.Reads[Payment] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "payment_paypal" => js.validate[io.flow.payment.v0.models.PaymentPaypal]
          case "payment_cryptopay" => js.validate[io.flow.payment.v0.models.PaymentCryptopay]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.PaymentUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectPayment(obj: io.flow.payment.v0.models.Payment): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.PaymentPaypal => jsObjectPaymentPaypal(x)
        case x: io.flow.payment.v0.models.PaymentCryptopay => jsObjectPaymentCryptopay(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentPayment: play.api.libs.json.Writes[Payment] = {
      (obj: io.flow.payment.v0.models.Payment) => {
        jsObjectPayment(obj)
      }
    }

    implicit def jsonReadsPaymentPaymentForm: play.api.libs.json.Reads[PaymentForm] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "merchant_of_record_payment_form" => js.validate[io.flow.payment.v0.models.MerchantOfRecordPaymentForm]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.PaymentFormUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectPaymentForm(obj: io.flow.payment.v0.models.PaymentForm): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.MerchantOfRecordPaymentForm => jsObjectMerchantOfRecordPaymentForm(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentPaymentForm: play.api.libs.json.Writes[PaymentForm] = {
      (obj: io.flow.payment.v0.models.PaymentForm) => {
        jsObjectPaymentForm(obj)
      }
    }

    implicit def jsonReadsPaymentPaymentSource: play.api.libs.json.Reads[PaymentSource] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "card_payment_source" => js.validate[io.flow.payment.v0.models.CardPaymentSource]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.PaymentSourceUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectPaymentSource(obj: io.flow.payment.v0.models.PaymentSource): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.CardPaymentSource => jsObjectCardPaymentSource(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentPaymentSource: play.api.libs.json.Writes[PaymentSource] = {
      (obj: io.flow.payment.v0.models.PaymentSource) => {
        jsObjectPaymentSource(obj)
      }
    }

    implicit def jsonReadsPaymentPaymentSourceForm: play.api.libs.json.Reads[PaymentSourceForm] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "card_payment_source_form" => js.validate[io.flow.payment.v0.models.CardPaymentSourceForm]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.PaymentSourceFormUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectPaymentSourceForm(obj: io.flow.payment.v0.models.PaymentSourceForm): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.CardPaymentSourceForm => jsObjectCardPaymentSourceForm(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentPaymentSourceForm: play.api.libs.json.Writes[PaymentSourceForm] = {
      (obj: io.flow.payment.v0.models.PaymentSourceForm) => {
        jsObjectPaymentSourceForm(obj)
      }
    }

    implicit def jsonReadsPaymentThreedsChallengeAction: play.api.libs.json.Reads[ThreedsChallengeAction] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "threeds_two_challenge_request" => js.validate[io.flow.payment.v0.models.ThreedsTwoChallengeRequest]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ThreedsChallengeActionUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectThreedsChallengeAction(obj: io.flow.payment.v0.models.ThreedsChallengeAction): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.ThreedsTwoChallengeRequest => jsObjectThreedsTwoChallengeRequest(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentThreedsChallengeAction: play.api.libs.json.Writes[ThreedsChallengeAction] = {
      (obj: io.flow.payment.v0.models.ThreedsChallengeAction) => {
        jsObjectThreedsChallengeAction(obj)
      }
    }

    implicit def jsonReadsPaymentThreedsIdentifyAction: play.api.libs.json.Reads[ThreedsIdentifyAction] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "threeds_two_method" => js.validate[io.flow.payment.v0.models.ThreedsTwoMethod]
          case other => play.api.libs.json.JsSuccess(io.flow.payment.v0.models.ThreedsIdentifyActionUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectThreedsIdentifyAction(obj: io.flow.payment.v0.models.ThreedsIdentifyAction): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.payment.v0.models.ThreedsTwoMethod => jsObjectThreedsTwoMethod(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesPaymentThreedsIdentifyAction: play.api.libs.json.Writes[ThreedsIdentifyAction] = {
      (obj: io.flow.payment.v0.models.ThreedsIdentifyAction) => {
        jsObjectThreedsIdentifyAction(obj)
      }
    }
  }
}

package io.flow.payment.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}

    // import models directly for backwards compatibility with prior versions of the generator
    import Core._
    import Models._

    object Core {
      implicit def pathBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.DateTime] = ApibuilderPathBindable(ApibuilderTypes.dateTimeIso8601)
      implicit def queryStringBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.DateTime] = ApibuilderQueryStringBindable(ApibuilderTypes.dateTimeIso8601)

      implicit def pathBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.LocalDate] = ApibuilderPathBindable(ApibuilderTypes.dateIso8601)
      implicit def queryStringBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.LocalDate] = ApibuilderQueryStringBindable(ApibuilderTypes.dateIso8601)
    }

    object Models {
      import io.flow.payment.v0.models._

      val authorizationDeclineCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.AuthorizationDeclineCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.AuthorizationDeclineCode] {
        override def convert(value: String): io.flow.payment.v0.models.AuthorizationDeclineCode = io.flow.payment.v0.models.AuthorizationDeclineCode(value)
        override def convert(value: io.flow.payment.v0.models.AuthorizationDeclineCode): String = value.toString
        override def example: io.flow.payment.v0.models.AuthorizationDeclineCode = io.flow.payment.v0.models.AuthorizationDeclineCode.Expired
        override def validValues: Seq[io.flow.payment.v0.models.AuthorizationDeclineCode] = io.flow.payment.v0.models.AuthorizationDeclineCode.all
      }
      implicit def pathBindableAuthorizationDeclineCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.AuthorizationDeclineCode] = ApibuilderPathBindable(authorizationDeclineCodeConverter)
      implicit def queryStringBindableAuthorizationDeclineCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.AuthorizationDeclineCode] = ApibuilderQueryStringBindable(authorizationDeclineCodeConverter)

      val authorizationOptionConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.AuthorizationOption] = new ApibuilderTypeConverter[io.flow.payment.v0.models.AuthorizationOption] {
        override def convert(value: String): io.flow.payment.v0.models.AuthorizationOption = io.flow.payment.v0.models.AuthorizationOption(value)
        override def convert(value: io.flow.payment.v0.models.AuthorizationOption): String = value.toString
        override def example: io.flow.payment.v0.models.AuthorizationOption = io.flow.payment.v0.models.AuthorizationOption.StoreCard
        override def validValues: Seq[io.flow.payment.v0.models.AuthorizationOption] = io.flow.payment.v0.models.AuthorizationOption.all
      }
      implicit def pathBindableAuthorizationOption(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.AuthorizationOption] = ApibuilderPathBindable(authorizationOptionConverter)
      implicit def queryStringBindableAuthorizationOption(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.AuthorizationOption] = ApibuilderQueryStringBindable(authorizationOptionConverter)

      val authorizationResultActionTypeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.AuthorizationResultActionType] = new ApibuilderTypeConverter[io.flow.payment.v0.models.AuthorizationResultActionType] {
        override def convert(value: String): io.flow.payment.v0.models.AuthorizationResultActionType = io.flow.payment.v0.models.AuthorizationResultActionType(value)
        override def convert(value: io.flow.payment.v0.models.AuthorizationResultActionType): String = value.toString
        override def example: io.flow.payment.v0.models.AuthorizationResultActionType = io.flow.payment.v0.models.AuthorizationResultActionType.Native
        override def validValues: Seq[io.flow.payment.v0.models.AuthorizationResultActionType] = io.flow.payment.v0.models.AuthorizationResultActionType.all
      }
      implicit def pathBindableAuthorizationResultActionType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.AuthorizationResultActionType] = ApibuilderPathBindable(authorizationResultActionTypeConverter)
      implicit def queryStringBindableAuthorizationResultActionType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.AuthorizationResultActionType] = ApibuilderQueryStringBindable(authorizationResultActionTypeConverter)

      val authorizationStatusConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.AuthorizationStatus] = new ApibuilderTypeConverter[io.flow.payment.v0.models.AuthorizationStatus] {
        override def convert(value: String): io.flow.payment.v0.models.AuthorizationStatus = io.flow.payment.v0.models.AuthorizationStatus(value)
        override def convert(value: io.flow.payment.v0.models.AuthorizationStatus): String = value.toString
        override def example: io.flow.payment.v0.models.AuthorizationStatus = io.flow.payment.v0.models.AuthorizationStatus.Pending
        override def validValues: Seq[io.flow.payment.v0.models.AuthorizationStatus] = io.flow.payment.v0.models.AuthorizationStatus.all
      }
      implicit def pathBindableAuthorizationStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.AuthorizationStatus] = ApibuilderPathBindable(authorizationStatusConverter)
      implicit def queryStringBindableAuthorizationStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.AuthorizationStatus] = ApibuilderQueryStringBindable(authorizationStatusConverter)

      val avsCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.AvsCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.AvsCode] {
        override def convert(value: String): io.flow.payment.v0.models.AvsCode = io.flow.payment.v0.models.AvsCode(value)
        override def convert(value: io.flow.payment.v0.models.AvsCode): String = value.toString
        override def example: io.flow.payment.v0.models.AvsCode = io.flow.payment.v0.models.AvsCode.Match
        override def validValues: Seq[io.flow.payment.v0.models.AvsCode] = io.flow.payment.v0.models.AvsCode.all
      }
      implicit def pathBindableAvsCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.AvsCode] = ApibuilderPathBindable(avsCodeConverter)
      implicit def queryStringBindableAvsCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.AvsCode] = ApibuilderQueryStringBindable(avsCodeConverter)

      val captureDeclineCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.CaptureDeclineCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.CaptureDeclineCode] {
        override def convert(value: String): io.flow.payment.v0.models.CaptureDeclineCode = io.flow.payment.v0.models.CaptureDeclineCode(value)
        override def convert(value: io.flow.payment.v0.models.CaptureDeclineCode): String = value.toString
        override def example: io.flow.payment.v0.models.CaptureDeclineCode = io.flow.payment.v0.models.CaptureDeclineCode.Expired
        override def validValues: Seq[io.flow.payment.v0.models.CaptureDeclineCode] = io.flow.payment.v0.models.CaptureDeclineCode.all
      }
      implicit def pathBindableCaptureDeclineCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.CaptureDeclineCode] = ApibuilderPathBindable(captureDeclineCodeConverter)
      implicit def queryStringBindableCaptureDeclineCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.CaptureDeclineCode] = ApibuilderQueryStringBindable(captureDeclineCodeConverter)

      val captureStatusConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.CaptureStatus] = new ApibuilderTypeConverter[io.flow.payment.v0.models.CaptureStatus] {
        override def convert(value: String): io.flow.payment.v0.models.CaptureStatus = io.flow.payment.v0.models.CaptureStatus(value)
        override def convert(value: io.flow.payment.v0.models.CaptureStatus): String = value.toString
        override def example: io.flow.payment.v0.models.CaptureStatus = io.flow.payment.v0.models.CaptureStatus.Pending
        override def validValues: Seq[io.flow.payment.v0.models.CaptureStatus] = io.flow.payment.v0.models.CaptureStatus.all
      }
      implicit def pathBindableCaptureStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.CaptureStatus] = ApibuilderPathBindable(captureStatusConverter)
      implicit def queryStringBindableCaptureStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.CaptureStatus] = ApibuilderQueryStringBindable(captureStatusConverter)

      val cardErrorCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.CardErrorCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.CardErrorCode] {
        override def convert(value: String): io.flow.payment.v0.models.CardErrorCode = io.flow.payment.v0.models.CardErrorCode(value)
        override def convert(value: io.flow.payment.v0.models.CardErrorCode): String = value.toString
        override def example: io.flow.payment.v0.models.CardErrorCode = io.flow.payment.v0.models.CardErrorCode.InvalidAddress
        override def validValues: Seq[io.flow.payment.v0.models.CardErrorCode] = io.flow.payment.v0.models.CardErrorCode.all
      }
      implicit def pathBindableCardErrorCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.CardErrorCode] = ApibuilderPathBindable(cardErrorCodeConverter)
      implicit def queryStringBindableCardErrorCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.CardErrorCode] = ApibuilderQueryStringBindable(cardErrorCodeConverter)

      val cardTypeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.CardType] = new ApibuilderTypeConverter[io.flow.payment.v0.models.CardType] {
        override def convert(value: String): io.flow.payment.v0.models.CardType = io.flow.payment.v0.models.CardType(value)
        override def convert(value: io.flow.payment.v0.models.CardType): String = value.toString
        override def example: io.flow.payment.v0.models.CardType = io.flow.payment.v0.models.CardType.AmericanExpress
        override def validValues: Seq[io.flow.payment.v0.models.CardType] = io.flow.payment.v0.models.CardType.all
      }
      implicit def pathBindableCardType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.CardType] = ApibuilderPathBindable(cardTypeConverter)
      implicit def queryStringBindableCardType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.CardType] = ApibuilderQueryStringBindable(cardTypeConverter)

      val cvvCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.CvvCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.CvvCode] {
        override def convert(value: String): io.flow.payment.v0.models.CvvCode = io.flow.payment.v0.models.CvvCode(value)
        override def convert(value: io.flow.payment.v0.models.CvvCode): String = value.toString
        override def example: io.flow.payment.v0.models.CvvCode = io.flow.payment.v0.models.CvvCode.Match
        override def validValues: Seq[io.flow.payment.v0.models.CvvCode] = io.flow.payment.v0.models.CvvCode.all
      }
      implicit def pathBindableCvvCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.CvvCode] = ApibuilderPathBindable(cvvCodeConverter)
      implicit def queryStringBindableCvvCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.CvvCode] = ApibuilderQueryStringBindable(cvvCodeConverter)

      val paymentErrorCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.PaymentErrorCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.PaymentErrorCode] {
        override def convert(value: String): io.flow.payment.v0.models.PaymentErrorCode = io.flow.payment.v0.models.PaymentErrorCode(value)
        override def convert(value: io.flow.payment.v0.models.PaymentErrorCode): String = value.toString
        override def example: io.flow.payment.v0.models.PaymentErrorCode = io.flow.payment.v0.models.PaymentErrorCode.Duplicate
        override def validValues: Seq[io.flow.payment.v0.models.PaymentErrorCode] = io.flow.payment.v0.models.PaymentErrorCode.all
      }
      implicit def pathBindablePaymentErrorCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.PaymentErrorCode] = ApibuilderPathBindable(paymentErrorCodeConverter)
      implicit def queryStringBindablePaymentErrorCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.PaymentErrorCode] = ApibuilderQueryStringBindable(paymentErrorCodeConverter)

      val paymentSourceConfirmationActionTypeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.PaymentSourceConfirmationActionType] = new ApibuilderTypeConverter[io.flow.payment.v0.models.PaymentSourceConfirmationActionType] {
        override def convert(value: String): io.flow.payment.v0.models.PaymentSourceConfirmationActionType = io.flow.payment.v0.models.PaymentSourceConfirmationActionType(value)
        override def convert(value: io.flow.payment.v0.models.PaymentSourceConfirmationActionType): String = value.toString
        override def example: io.flow.payment.v0.models.PaymentSourceConfirmationActionType = io.flow.payment.v0.models.PaymentSourceConfirmationActionType.Cvv
        override def validValues: Seq[io.flow.payment.v0.models.PaymentSourceConfirmationActionType] = io.flow.payment.v0.models.PaymentSourceConfirmationActionType.all
      }
      implicit def pathBindablePaymentSourceConfirmationActionType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.PaymentSourceConfirmationActionType] = ApibuilderPathBindable(paymentSourceConfirmationActionTypeConverter)
      implicit def queryStringBindablePaymentSourceConfirmationActionType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.PaymentSourceConfirmationActionType] = ApibuilderQueryStringBindable(paymentSourceConfirmationActionTypeConverter)

      val refundDeclineCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.RefundDeclineCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.RefundDeclineCode] {
        override def convert(value: String): io.flow.payment.v0.models.RefundDeclineCode = io.flow.payment.v0.models.RefundDeclineCode(value)
        override def convert(value: io.flow.payment.v0.models.RefundDeclineCode): String = value.toString
        override def example: io.flow.payment.v0.models.RefundDeclineCode = io.flow.payment.v0.models.RefundDeclineCode.Expired
        override def validValues: Seq[io.flow.payment.v0.models.RefundDeclineCode] = io.flow.payment.v0.models.RefundDeclineCode.all
      }
      implicit def pathBindableRefundDeclineCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.RefundDeclineCode] = ApibuilderPathBindable(refundDeclineCodeConverter)
      implicit def queryStringBindableRefundDeclineCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.RefundDeclineCode] = ApibuilderQueryStringBindable(refundDeclineCodeConverter)

      val refundStatusConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.RefundStatus] = new ApibuilderTypeConverter[io.flow.payment.v0.models.RefundStatus] {
        override def convert(value: String): io.flow.payment.v0.models.RefundStatus = io.flow.payment.v0.models.RefundStatus(value)
        override def convert(value: io.flow.payment.v0.models.RefundStatus): String = value.toString
        override def example: io.flow.payment.v0.models.RefundStatus = io.flow.payment.v0.models.RefundStatus.Pending
        override def validValues: Seq[io.flow.payment.v0.models.RefundStatus] = io.flow.payment.v0.models.RefundStatus.all
      }
      implicit def pathBindableRefundStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.RefundStatus] = ApibuilderPathBindable(refundStatusConverter)
      implicit def queryStringBindableRefundStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.RefundStatus] = ApibuilderQueryStringBindable(refundStatusConverter)

      val reversalErrorCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.ReversalErrorCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.ReversalErrorCode] {
        override def convert(value: String): io.flow.payment.v0.models.ReversalErrorCode = io.flow.payment.v0.models.ReversalErrorCode(value)
        override def convert(value: io.flow.payment.v0.models.ReversalErrorCode): String = value.toString
        override def example: io.flow.payment.v0.models.ReversalErrorCode = io.flow.payment.v0.models.ReversalErrorCode.AmountExceedsBalance
        override def validValues: Seq[io.flow.payment.v0.models.ReversalErrorCode] = io.flow.payment.v0.models.ReversalErrorCode.all
      }
      implicit def pathBindableReversalErrorCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.ReversalErrorCode] = ApibuilderPathBindable(reversalErrorCodeConverter)
      implicit def queryStringBindableReversalErrorCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.ReversalErrorCode] = ApibuilderQueryStringBindable(reversalErrorCodeConverter)

      val reversalStatusConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.ReversalStatus] = new ApibuilderTypeConverter[io.flow.payment.v0.models.ReversalStatus] {
        override def convert(value: String): io.flow.payment.v0.models.ReversalStatus = io.flow.payment.v0.models.ReversalStatus(value)
        override def convert(value: io.flow.payment.v0.models.ReversalStatus): String = value.toString
        override def example: io.flow.payment.v0.models.ReversalStatus = io.flow.payment.v0.models.ReversalStatus.Pending
        override def validValues: Seq[io.flow.payment.v0.models.ReversalStatus] = io.flow.payment.v0.models.ReversalStatus.all
      }
      implicit def pathBindableReversalStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.ReversalStatus] = ApibuilderPathBindable(reversalStatusConverter)
      implicit def queryStringBindableReversalStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.ReversalStatus] = ApibuilderQueryStringBindable(reversalStatusConverter)

      val threeDSecureCodeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.ThreeDSecureCode] = new ApibuilderTypeConverter[io.flow.payment.v0.models.ThreeDSecureCode] {
        override def convert(value: String): io.flow.payment.v0.models.ThreeDSecureCode = io.flow.payment.v0.models.ThreeDSecureCode(value)
        override def convert(value: io.flow.payment.v0.models.ThreeDSecureCode): String = value.toString
        override def example: io.flow.payment.v0.models.ThreeDSecureCode = io.flow.payment.v0.models.ThreeDSecureCode.Verified
        override def validValues: Seq[io.flow.payment.v0.models.ThreeDSecureCode] = io.flow.payment.v0.models.ThreeDSecureCode.all
      }
      implicit def pathBindableThreeDSecureCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.ThreeDSecureCode] = ApibuilderPathBindable(threeDSecureCodeConverter)
      implicit def queryStringBindableThreeDSecureCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.ThreeDSecureCode] = ApibuilderQueryStringBindable(threeDSecureCodeConverter)

      val threedsTwoChallengeViewportConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.ThreedsTwoChallengeViewport] = new ApibuilderTypeConverter[io.flow.payment.v0.models.ThreedsTwoChallengeViewport] {
        override def convert(value: String): io.flow.payment.v0.models.ThreedsTwoChallengeViewport = io.flow.payment.v0.models.ThreedsTwoChallengeViewport(value)
        override def convert(value: io.flow.payment.v0.models.ThreedsTwoChallengeViewport): String = value.toString
        override def example: io.flow.payment.v0.models.ThreedsTwoChallengeViewport = io.flow.payment.v0.models.ThreedsTwoChallengeViewport.XxxSmall
        override def validValues: Seq[io.flow.payment.v0.models.ThreedsTwoChallengeViewport] = io.flow.payment.v0.models.ThreedsTwoChallengeViewport.all
      }
      implicit def pathBindableThreedsTwoChallengeViewport(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.ThreedsTwoChallengeViewport] = ApibuilderPathBindable(threedsTwoChallengeViewportConverter)
      implicit def queryStringBindableThreedsTwoChallengeViewport(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.ThreedsTwoChallengeViewport] = ApibuilderQueryStringBindable(threedsTwoChallengeViewportConverter)

      val tokenTypeConverter: ApibuilderTypeConverter[io.flow.payment.v0.models.TokenType] = new ApibuilderTypeConverter[io.flow.payment.v0.models.TokenType] {
        override def convert(value: String): io.flow.payment.v0.models.TokenType = io.flow.payment.v0.models.TokenType(value)
        override def convert(value: io.flow.payment.v0.models.TokenType): String = value.toString
        override def example: io.flow.payment.v0.models.TokenType = io.flow.payment.v0.models.TokenType.Permanent
        override def validValues: Seq[io.flow.payment.v0.models.TokenType] = io.flow.payment.v0.models.TokenType.all
      }
      implicit def pathBindableTokenType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.payment.v0.models.TokenType] = ApibuilderPathBindable(tokenTypeConverter)
      implicit def queryStringBindableTokenType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.payment.v0.models.TokenType] = ApibuilderQueryStringBindable(tokenTypeConverter)
    }

    trait ApibuilderTypeConverter[T] {

      def convert(value: String): T

      def convert(value: T): String

      def example: T

      def validValues: Seq[T] = Nil

      def errorMessage(key: String, value: String, ex: java.lang.Exception): String = {
        val base = s"Invalid value '$value' for parameter '$key'. "
        validValues.toList match {
          case Nil => base + "Ex: " + convert(example)
          case values => base + ". Valid values are: " + values.mkString("'", "', '", "'")
        }
      }
    }

    object ApibuilderTypes {
      val dateTimeIso8601: ApibuilderTypeConverter[_root_.org.joda.time.DateTime] = new ApibuilderTypeConverter[_root_.org.joda.time.DateTime] {
        override def convert(value: String): _root_.org.joda.time.DateTime = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(value)
        override def convert(value: _root_.org.joda.time.DateTime): String = _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(value)
        override def example: _root_.org.joda.time.DateTime = _root_.org.joda.time.DateTime.now
      }

      val dateIso8601: ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] = new ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] {
        override def convert(value: String): _root_.org.joda.time.LocalDate = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(value)
        override def convert(value: _root_.org.joda.time.LocalDate): String = _root_.org.joda.time.format.ISODateTimeFormat.date.print(value)
        override def example: _root_.org.joda.time.LocalDate = _root_.org.joda.time.LocalDate.now
      }
    }

    final case class ApibuilderQueryStringBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends QueryStringBindable[T] {

      override def bind(key: String, params: Map[String, Seq[String]]): _root_.scala.Option[_root_.scala.Either[String, T]] = {
        params.getOrElse(key, Nil).headOption.map { v =>
          try {
            Right(
              converters.convert(v)
            )
          } catch {
            case ex: java.lang.Exception => Left(
              converters.errorMessage(key, v, ex)
            )
          }
        }
      }

      override def unbind(key: String, value: T): String = {
        s"$key=${converters.convert(value)}"
      }
    }

    final case class ApibuilderPathBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends PathBindable[T] {

      override def bind(key: String, value: String): _root_.scala.Either[String, T] = {
        try {
          Right(
            converters.convert(value)
          )
        } catch {
          case ex: java.lang.Exception => Left(
            converters.errorMessage(key, value, ex)
          )
        }
      }

      override def unbind(key: String, value: T): String = {
        converters.convert(value)
      }
    }

  }

}
