/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.10.75
 * apibuilder 0.15.33 app.apibuilder.io/flow/inventory/latest/play_2_x_json
 */
package io.flow.inventory.v0.models {

  /**
   * Types of rules used to apply on inventory to calculate available quantity
   */
  sealed trait InventoryStrategy extends _root_.scala.Product with _root_.scala.Serializable {
    def inventoryStrategyDiscriminator: InventoryStrategyDiscriminator

  }

  /**
   * Defines the valid discriminator values for the type InventoryStrategy
   */
  sealed trait InventoryStrategyDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object InventoryStrategyDiscriminator {

    /**
     * Enables backorders, setting an optional number of units that we allow for
     * backorder. For example, a backorder w/ quantity 10 will enable selling until the
     * actual inventory quantity is -10.
     */
    case object InventoryBackorder extends InventoryStrategyDiscriminator { override def toString = "inventory_backorder" }
    /**
     * Treats inventory as available as long as the actual inventory quantity is > the
     * specified quantity. A common use case is to set quantity to zero to indicate
     * availability as long as there is at least 1 unit available.
     */
    case object InventoryStock extends InventoryStrategyDiscriminator { override def toString = "inventory_stock" }
    /**
     * Items affected with rules pursuing an unlimited strategy will always be
     * available
     */
    case object InventoryUnlimited extends InventoryStrategyDiscriminator { override def toString = "inventory_unlimited" }
    /**
     * Items affected with rules pursuing an ecommerce platform strategy will always
     * follow the ecommerce platform inventory
     */
    case object InventoryFollowEcommercePlatform extends InventoryStrategyDiscriminator { override def toString = "inventory_follow_ecommerce_platform" }

    final case class UNDEFINED(override val toString: String) extends InventoryStrategyDiscriminator

    val all: scala.List[InventoryStrategyDiscriminator] = scala.List(InventoryBackorder, InventoryStock, InventoryUnlimited, InventoryFollowEcommercePlatform)

    private[this] val byName: Map[String, InventoryStrategyDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): InventoryStrategyDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[InventoryStrategyDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * Types of failed inventory reservation reasons
   */
  sealed trait ReservationError extends _root_.scala.Product with _root_.scala.Serializable {
    def reservationErrorCode: ReservationErrorCode

  }

  /**
   * Defines the valid code values for the type ReservationError
   */
  sealed trait ReservationErrorCode extends _root_.scala.Product with _root_.scala.Serializable

  object ReservationErrorCode {

    /**
     * Inventory is not available for all or subset of item quantities requested
     */
    case object NoInventoryReservationError extends ReservationErrorCode { override def toString = "no_inventory" }
    /**
     * API call to external API (ex: PFS) timed out
     */
    case object ExternalApiTimeoutReservationError extends ReservationErrorCode { override def toString = "external_api_timeout" }
    /**
     * Generic reservation error
     */
    case object GenericReservationError extends ReservationErrorCode { override def toString = "generic_reservation_error" }

    final case class UNDEFINED(override val toString: String) extends ReservationErrorCode

    val all: scala.List[ReservationErrorCode] = scala.List(NoInventoryReservationError, ExternalApiTimeoutReservationError, GenericReservationError)

    private[this] val byName: Map[String, ReservationErrorCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ReservationErrorCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ReservationErrorCode] = byName.get(value.toLowerCase)

  }
  final case class ExternalApiTimeoutReservationError(
    messages: Seq[String]
  ) extends ReservationError {
    override val reservationErrorCode: ReservationErrorCode = ReservationErrorCode.ExternalApiTimeoutReservationError
  }

  final case class GenericReservationError(
    messages: Seq[String]
  ) extends ReservationError {
    override val reservationErrorCode: ReservationErrorCode = ReservationErrorCode.GenericReservationError
  }

  /**
   * Enables backorders, setting an optional number of units that we allow for
   * backorder. For example, a backorder w/ quantity 10 will enable selling until the
   * actual inventory quantity is -10.
   */

  final case class InventoryBackorder(
    quantity: Long
  ) extends InventoryStrategy {
    override val inventoryStrategyDiscriminator: InventoryStrategyDiscriminator = InventoryStrategyDiscriminator.InventoryBackorder
  }

  final case class InventoryCenterReference(
    key: String
  )

  final case class InventoryCheckResponse(
    items: Seq[io.flow.inventory.v0.models.InventoryCheckResponseItem]
  )

  final case class InventoryCheckResponseItem(
    number: String,
    quantity: Long,
    inventoryStatus: io.flow.inventory.v0.models.InventoryStatus
  )

  final case class InventoryExperienceReference(
    key: String
  )

  /**
   * Items affected with rules pursuing an ecommerce platform strategy will always
   * follow the ecommerce platform inventory
   */

  final case class InventoryFollowEcommercePlatform(
    quantity: Long
  ) extends InventoryStrategy {
    override val inventoryStrategyDiscriminator: InventoryStrategyDiscriminator = InventoryStrategyDiscriminator.InventoryFollowEcommercePlatform
  }

  final case class InventoryItemReference(
    number: String
  )

  final case class InventoryRequest(
    items: Seq[io.flow.inventory.v0.models.InventoryRequestItem]
  )

  final case class InventoryRequestItem(
    number: String,
    quantity: Long
  )

  /**
   * Ordered list of rules to apply, from first to last, to get available quantity.
   * This is unique per organization
   *
   * @param position Order in which rule applicability will be checked
   * @param query Query to be used to apply this rule. Only '*' is available for now, which will
   *        apply to all cases
   * @param strategy Type of inventory strategy to be used for this rule
   */

  final case class InventoryRule(
    id: String,
    position: Long,
    query: String,
    strategy: io.flow.inventory.v0.models.InventoryStrategy
  )

  /**
   * @param position Order in which rule applicability will be checked
   * @param query Query to be used to apply this rule. Only '*' is available for now, which will
   *        apply to all cases
   * @param strategy Type of inventory strategy to be used for this rule
   */

  final case class InventoryRuleForm(
    position: Long,
    query: String,
    strategy: io.flow.inventory.v0.models.InventoryStrategy
  )

  final case class InventoryRuleVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    inventoryRule: io.flow.inventory.v0.models.InventoryRule
  )

  /**
   * Inventory snapshot reflects the current quantity and available number of units
   * for a given center / item
   *
   * @param available Actual available quantity for an item at a given center
   * @param center Location capable of fulfilling a shipment for item in inventory
   * @param item Client item being stored in inventory
   * @param quantity Running total of inventory update quantities provided
   */

  final case class InventorySnapshot(
    id: String,
    available: Long,
    center: io.flow.inventory.v0.models.InventoryCenterReference,
    item: io.flow.inventory.v0.models.InventoryItemReference,
    quantity: Long
  )

  final case class InventorySnapshotVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    inventorySnapshot: io.flow.inventory.v0.models.InventorySnapshot
  )

  /**
   * Treats inventory as available as long as the actual inventory quantity is > the
   * specified quantity. A common use case is to set quantity to zero to indicate
   * availability as long as there is at least 1 unit available.
   */

  final case class InventoryStock(
    quantity: Long
  ) extends InventoryStrategy {
    override val inventoryStrategyDiscriminator: InventoryStrategyDiscriminator = InventoryStrategyDiscriminator.InventoryStock
  }

  /**
   * Items affected with rules pursuing an unlimited strategy will always be
   * available
   */

  final case class InventoryUnlimited(
    placeholder: String = "unlimited"
  ) extends InventoryStrategy {
    override val inventoryStrategyDiscriminator: InventoryStrategyDiscriminator = InventoryStrategyDiscriminator.InventoryUnlimited
  }

  /**
   * Represents a single update on inventory quantity
   *
   * @param center Location capable of fulfilling a shipment for item in inventory
   * @param item Client item number being stored in inventory
   * @param quantity Amount of the update made
   */

  final case class InventoryUpdate(
    id: String,
    idempotencyKey: String,
    center: io.flow.inventory.v0.models.InventoryCenterReference,
    item: io.flow.inventory.v0.models.InventoryItemReference,
    notes: _root_.play.api.libs.json.JsObject,
    quantity: Long,
    `type`: io.flow.inventory.v0.models.UpdateType
  )

  /**
   * Form used to create an update on inventory. If inventory for center/item has not
   * been previously created, a new row is created for the center/item tuple.
   *
   * @param center Center capable of fulfilling a shipment for item in inventory
   * @param itemNumber Summary about the item being kept in inventory
   * @param quantity Amount of the update to be made
   */

  final case class InventoryUpdateForm(
    center: String,
    idempotencyKey: String,
    itemNumber: String,
    quantity: Long,
    `type`: io.flow.inventory.v0.models.UpdateType,
    notes: _root_.scala.Option[_root_.play.api.libs.json.JsObject] = None
  )

  final case class InventoryUpdateVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    inventoryUpdate: io.flow.inventory.v0.models.InventoryUpdate
  )

  final case class NoInventoryReservationError(
    messages: Seq[String],
    items: Seq[io.flow.inventory.v0.models.NoInventoryReservationErrorItem]
  ) extends ReservationError {
    override val reservationErrorCode: ReservationErrorCode = ReservationErrorCode.NoInventoryReservationError
  }

  final case class NoInventoryReservationErrorItem(
    number: String,
    requestedQuantity: Long,
    availableQuantity: Long
  )

  final case class PfsInventoryCheckResponse(
    items: Map[String, io.flow.inventory.v0.models.PfsInventoryCheckResponseItem]
  )

  final case class PfsInventoryCheckResponseItem(
    number: String,
    ats: Long,
    inStock: Boolean
  )

  final case class PfsInventoryStatus(
    status: String
  )

  /**
   * Inventory reservation for a set of items in organization that potentially
   * expires at specified date/time
   *
   * @param reservedUntil Records the length of this reservation. When omitted, inventory is to be treated
   *        as first-come, first-served.
   */

  final case class Reservation(
    id: String,
    key: String,
    order: _root_.scala.Option[io.flow.inventory.v0.models.ReservationOrderReference] = None,
    items: Seq[io.flow.inventory.v0.models.ReservationItem],
    reservedUntil: _root_.scala.Option[_root_.org.joda.time.DateTime] = None
  )

  final case class ReservationForm(
    orderNumber: _root_.scala.Option[String] = None,
    items: Seq[io.flow.inventory.v0.models.ReservationItemForm]
  )

  /**
   * @param quantity Number of reserved items.
   */

  final case class ReservationItem(
    item: io.flow.inventory.v0.models.ReservationItemReference,
    quantity: Long
  )

  /**
   * @param quantity Number of items to reserve.
   */

  final case class ReservationItemForm(
    itemNumber: String,
    quantity: Long
  )

  final case class ReservationItemReference(
    number: String
  )

  final case class ReservationOrderReference(
    number: String
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union InventoryStrategy, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class InventoryStrategyUndefinedType(
    description: String
  ) extends InventoryStrategy {
    override val inventoryStrategyDiscriminator: InventoryStrategyDiscriminator = InventoryStrategyDiscriminator.UNDEFINED(description)
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ReservationError, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */

  final case class ReservationErrorUndefinedType(
    description: String
  ) extends ReservationError {
    override val reservationErrorCode: ReservationErrorCode = ReservationErrorCode.UNDEFINED(description)
  }
  /**
   * The aggregate function to be applied
   */
  sealed trait Aggregate extends _root_.scala.Product with _root_.scala.Serializable

  object Aggregate {

    case object Maximum extends Aggregate { override def toString = "maximum" }
    case object Minimum extends Aggregate { override def toString = "minimum" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Aggregate

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Aggregate] = scala.List(Maximum, Minimum)

    private[this]
    val byName: Map[String, Aggregate] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Aggregate = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Aggregate] = byName.get(value.toLowerCase)

  }

  sealed trait InventoryStatus extends _root_.scala.Product with _root_.scala.Serializable

  object InventoryStatus {

    case object HasInventory extends InventoryStatus { override def toString = "has_inventory" }
    case object NoInventory extends InventoryStatus { override def toString = "no_inventory" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends InventoryStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[InventoryStatus] = scala.List(HasInventory, NoInventory)

    private[this]
    val byName: Map[String, InventoryStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): InventoryStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[InventoryStatus] = byName.get(value.toLowerCase)

  }

  /**
   * Types of updates that can be made on quantity of inventory
   */
  sealed trait UpdateType extends _root_.scala.Product with _root_.scala.Serializable

  object UpdateType {

    /**
     * Long value to increment or decrement. Positive quantities are added to inventory
     * while negative quantities are decrement from inventory.
     */
    case object Change extends UpdateType {
      override def toString = "change"
    }
    /**
     * Set absolute quantity to new value with no regard for previous updates
     */
    case object Set extends UpdateType {
      override def toString = "set"
    }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends UpdateType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[UpdateType] = scala.List(Change, Set)

    private[this]
    val byName: Map[String, UpdateType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): UpdateType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[UpdateType] = byName.get(value.toLowerCase)

  }

}

package io.flow.inventory.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.common.v0.models.json._
    import io.flow.error.v0.models.json._
    import io.flow.fulfillment.v0.models.json._
    import io.flow.inventory.v0.models.json._
    import io.flow.permission.v0.models.json._

    private[v0] implicit val jsonReadsUUID: play.api.libs.json.Reads[_root_.java.util.UUID] = __.read[String].map { str =>
      _root_.java.util.UUID.fromString(str)
    }

    private[v0] implicit val jsonWritesUUID: play.api.libs.json.Writes[_root_.java.util.UUID] = (x: _root_.java.util.UUID) => play.api.libs.json.JsString(x.toString)

    private[v0] implicit val jsonReadsJodaDateTime: play.api.libs.json.Reads[_root_.org.joda.time.DateTime] = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime: play.api.libs.json.Writes[_root_.org.joda.time.DateTime] = (x: _root_.org.joda.time.DateTime) => {
      play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x))
    }

    private[v0] implicit val jsonReadsJodaLocalDate: play.api.libs.json.Reads[_root_.org.joda.time.LocalDate] = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(str)
    }

    private[v0] implicit val jsonWritesJodaLocalDate: play.api.libs.json.Writes[_root_.org.joda.time.LocalDate] = (x: _root_.org.joda.time.LocalDate) => {
      play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.date.print(x))
    }

    implicit val jsonReadsInventoryAggregate: play.api.libs.json.Reads[io.flow.inventory.v0.models.Aggregate] = new play.api.libs.json.Reads[io.flow.inventory.v0.models.Aggregate] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.inventory.v0.models.Aggregate] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.Aggregate(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.Aggregate(v))
              case err: play.api.libs.json.JsError =>
                (js \ "aggregate").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.Aggregate(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesInventoryAggregate(obj: io.flow.inventory.v0.models.Aggregate) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAggregate(obj: io.flow.inventory.v0.models.Aggregate) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesInventoryAggregate: play.api.libs.json.Writes[Aggregate] = {
      (obj: io.flow.inventory.v0.models.Aggregate) => {
        jsonWritesInventoryAggregate(obj)
      }
    }

    implicit val jsonReadsInventoryInventoryStatus: play.api.libs.json.Reads[io.flow.inventory.v0.models.InventoryStatus] = new play.api.libs.json.Reads[io.flow.inventory.v0.models.InventoryStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.inventory.v0.models.InventoryStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.InventoryStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.InventoryStatus(v))
              case err: play.api.libs.json.JsError =>
                (js \ "inventory_status").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.InventoryStatus(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesInventoryInventoryStatus(obj: io.flow.inventory.v0.models.InventoryStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectInventoryStatus(obj: io.flow.inventory.v0.models.InventoryStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesInventoryInventoryStatus: play.api.libs.json.Writes[InventoryStatus] = {
      (obj: io.flow.inventory.v0.models.InventoryStatus) => {
        jsonWritesInventoryInventoryStatus(obj)
      }
    }

    implicit val jsonReadsInventoryUpdateType: play.api.libs.json.Reads[io.flow.inventory.v0.models.UpdateType] = new play.api.libs.json.Reads[io.flow.inventory.v0.models.UpdateType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.inventory.v0.models.UpdateType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.UpdateType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.UpdateType(v))
              case err: play.api.libs.json.JsError =>
                (js \ "update_type").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.UpdateType(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesInventoryUpdateType(obj: io.flow.inventory.v0.models.UpdateType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectUpdateType(obj: io.flow.inventory.v0.models.UpdateType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesInventoryUpdateType: play.api.libs.json.Writes[UpdateType] = {
      (obj: io.flow.inventory.v0.models.UpdateType) => {
        jsonWritesInventoryUpdateType(obj)
      }
    }

    implicit def jsonReadsInventoryExternalApiTimeoutReservationError: play.api.libs.json.Reads[ExternalApiTimeoutReservationError] = {
      (__ \ "messages").read[Seq[String]].map { x => new ExternalApiTimeoutReservationError(messages = x) }
    }

    def jsObjectExternalApiTimeoutReservationError(obj: io.flow.inventory.v0.models.ExternalApiTimeoutReservationError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "messages" -> play.api.libs.json.Json.toJson(obj.messages)
      ) ++ play.api.libs.json.Json.obj("code" -> "external_api_timeout")
    }

    implicit def jsonWritesInventoryExternalApiTimeoutReservationError: play.api.libs.json.Writes[ExternalApiTimeoutReservationError] = {
      (obj: io.flow.inventory.v0.models.ExternalApiTimeoutReservationError) => {
        jsObjectExternalApiTimeoutReservationError(obj)
      }
    }

    implicit def jsonReadsInventoryGenericReservationError: play.api.libs.json.Reads[GenericReservationError] = {
      (__ \ "messages").read[Seq[String]].map { x => new GenericReservationError(messages = x) }
    }

    def jsObjectGenericReservationError(obj: io.flow.inventory.v0.models.GenericReservationError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "messages" -> play.api.libs.json.Json.toJson(obj.messages)
      ) ++ play.api.libs.json.Json.obj("code" -> "generic_reservation_error")
    }

    implicit def jsonWritesInventoryGenericReservationError: play.api.libs.json.Writes[GenericReservationError] = {
      (obj: io.flow.inventory.v0.models.GenericReservationError) => {
        jsObjectGenericReservationError(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryBackorder: play.api.libs.json.Reads[InventoryBackorder] = {
      (__ \ "quantity").read[Long].map { x => new InventoryBackorder(quantity = x) }
    }

    def jsObjectInventoryBackorder(obj: io.flow.inventory.v0.models.InventoryBackorder): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "inventory_backorder")
    }

    implicit def jsonWritesInventoryInventoryBackorder: play.api.libs.json.Writes[InventoryBackorder] = {
      (obj: io.flow.inventory.v0.models.InventoryBackorder) => {
        jsObjectInventoryBackorder(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryCenterReference: play.api.libs.json.Reads[InventoryCenterReference] = {
      (__ \ "key").read[String].map { x => new InventoryCenterReference(key = x) }
    }

    def jsObjectInventoryCenterReference(obj: io.flow.inventory.v0.models.InventoryCenterReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonWritesInventoryInventoryCenterReference: play.api.libs.json.Writes[InventoryCenterReference] = {
      (obj: io.flow.inventory.v0.models.InventoryCenterReference) => {
        jsObjectInventoryCenterReference(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryCheckResponse: play.api.libs.json.Reads[InventoryCheckResponse] = {
      (__ \ "items").read[Seq[io.flow.inventory.v0.models.InventoryCheckResponseItem]].map { x => new InventoryCheckResponse(items = x) }
    }

    def jsObjectInventoryCheckResponse(obj: io.flow.inventory.v0.models.InventoryCheckResponse): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      )
    }

    implicit def jsonWritesInventoryInventoryCheckResponse: play.api.libs.json.Writes[InventoryCheckResponse] = {
      (obj: io.flow.inventory.v0.models.InventoryCheckResponse) => {
        jsObjectInventoryCheckResponse(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryCheckResponseItem: play.api.libs.json.Reads[InventoryCheckResponseItem] = {
      for {
        number <- (__ \ "number").read[String]
        quantity <- (__ \ "quantity").read[Long]
        inventoryStatus <- (__ \ "inventory_status").read[io.flow.inventory.v0.models.InventoryStatus]
      } yield InventoryCheckResponseItem(number, quantity, inventoryStatus)
    }

    def jsObjectInventoryCheckResponseItem(obj: io.flow.inventory.v0.models.InventoryCheckResponseItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "inventory_status" -> play.api.libs.json.JsString(obj.inventoryStatus.toString)
      )
    }

    implicit def jsonWritesInventoryInventoryCheckResponseItem: play.api.libs.json.Writes[InventoryCheckResponseItem] = {
      (obj: io.flow.inventory.v0.models.InventoryCheckResponseItem) => {
        jsObjectInventoryCheckResponseItem(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryExperienceReference: play.api.libs.json.Reads[InventoryExperienceReference] = {
      (__ \ "key").read[String].map { x => new InventoryExperienceReference(key = x) }
    }

    def jsObjectInventoryExperienceReference(obj: io.flow.inventory.v0.models.InventoryExperienceReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonWritesInventoryInventoryExperienceReference: play.api.libs.json.Writes[InventoryExperienceReference] = {
      (obj: io.flow.inventory.v0.models.InventoryExperienceReference) => {
        jsObjectInventoryExperienceReference(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryFollowEcommercePlatform: play.api.libs.json.Reads[InventoryFollowEcommercePlatform] = {
      (__ \ "quantity").read[Long].map { x => new InventoryFollowEcommercePlatform(quantity = x) }
    }

    def jsObjectInventoryFollowEcommercePlatform(obj: io.flow.inventory.v0.models.InventoryFollowEcommercePlatform): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "inventory_follow_ecommerce_platform")
    }

    implicit def jsonWritesInventoryInventoryFollowEcommercePlatform: play.api.libs.json.Writes[InventoryFollowEcommercePlatform] = {
      (obj: io.flow.inventory.v0.models.InventoryFollowEcommercePlatform) => {
        jsObjectInventoryFollowEcommercePlatform(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryItemReference: play.api.libs.json.Reads[InventoryItemReference] = {
      (__ \ "number").read[String].map { x => new InventoryItemReference(number = x) }
    }

    def jsObjectInventoryItemReference(obj: io.flow.inventory.v0.models.InventoryItemReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonWritesInventoryInventoryItemReference: play.api.libs.json.Writes[InventoryItemReference] = {
      (obj: io.flow.inventory.v0.models.InventoryItemReference) => {
        jsObjectInventoryItemReference(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryRequest: play.api.libs.json.Reads[InventoryRequest] = {
      (__ \ "items").read[Seq[io.flow.inventory.v0.models.InventoryRequestItem]].map { x => new InventoryRequest(items = x) }
    }

    def jsObjectInventoryRequest(obj: io.flow.inventory.v0.models.InventoryRequest): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      )
    }

    implicit def jsonWritesInventoryInventoryRequest: play.api.libs.json.Writes[InventoryRequest] = {
      (obj: io.flow.inventory.v0.models.InventoryRequest) => {
        jsObjectInventoryRequest(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryRequestItem: play.api.libs.json.Reads[InventoryRequestItem] = {
      for {
        number <- (__ \ "number").read[String]
        quantity <- (__ \ "quantity").read[Long]
      } yield InventoryRequestItem(number, quantity)
    }

    def jsObjectInventoryRequestItem(obj: io.flow.inventory.v0.models.InventoryRequestItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      )
    }

    implicit def jsonWritesInventoryInventoryRequestItem: play.api.libs.json.Writes[InventoryRequestItem] = {
      (obj: io.flow.inventory.v0.models.InventoryRequestItem) => {
        jsObjectInventoryRequestItem(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryRule: play.api.libs.json.Reads[InventoryRule] = {
      for {
        id <- (__ \ "id").read[String]
        position <- (__ \ "position").read[Long]
        query <- (__ \ "query").read[String]
        strategy <- (__ \ "strategy").read[io.flow.inventory.v0.models.InventoryStrategy]
      } yield InventoryRule(id, position, query, strategy)
    }

    def jsObjectInventoryRule(obj: io.flow.inventory.v0.models.InventoryRule): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "position" -> play.api.libs.json.JsNumber(obj.position),
        "query" -> play.api.libs.json.JsString(obj.query),
        "strategy" -> jsObjectInventoryStrategy(obj.strategy)
      )
    }

    implicit def jsonWritesInventoryInventoryRule: play.api.libs.json.Writes[InventoryRule] = {
      (obj: io.flow.inventory.v0.models.InventoryRule) => {
        jsObjectInventoryRule(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryRuleForm: play.api.libs.json.Reads[InventoryRuleForm] = {
      for {
        position <- (__ \ "position").read[Long]
        query <- (__ \ "query").read[String]
        strategy <- (__ \ "strategy").read[io.flow.inventory.v0.models.InventoryStrategy]
      } yield InventoryRuleForm(position, query, strategy)
    }

    def jsObjectInventoryRuleForm(obj: io.flow.inventory.v0.models.InventoryRuleForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "position" -> play.api.libs.json.JsNumber(obj.position),
        "query" -> play.api.libs.json.JsString(obj.query),
        "strategy" -> jsObjectInventoryStrategy(obj.strategy)
      )
    }

    implicit def jsonWritesInventoryInventoryRuleForm: play.api.libs.json.Writes[InventoryRuleForm] = {
      (obj: io.flow.inventory.v0.models.InventoryRuleForm) => {
        jsObjectInventoryRuleForm(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryRuleVersion: play.api.libs.json.Reads[InventoryRuleVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        inventoryRule <- (__ \ "inventory_rule").read[io.flow.inventory.v0.models.InventoryRule]
      } yield InventoryRuleVersion(id, timestamp, `type`, inventoryRule)
    }

    def jsObjectInventoryRuleVersion(obj: io.flow.inventory.v0.models.InventoryRuleVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "inventory_rule" -> jsObjectInventoryRule(obj.inventoryRule)
      )
    }

    implicit def jsonWritesInventoryInventoryRuleVersion: play.api.libs.json.Writes[InventoryRuleVersion] = {
      (obj: io.flow.inventory.v0.models.InventoryRuleVersion) => {
        jsObjectInventoryRuleVersion(obj)
      }
    }

    implicit def jsonReadsInventoryInventorySnapshot: play.api.libs.json.Reads[InventorySnapshot] = {
      for {
        id <- (__ \ "id").read[String]
        available <- (__ \ "available").read[Long]
        center <- (__ \ "center").read[io.flow.inventory.v0.models.InventoryCenterReference]
        item <- (__ \ "item").read[io.flow.inventory.v0.models.InventoryItemReference]
        quantity <- (__ \ "quantity").read[Long]
      } yield InventorySnapshot(id, available, center, item, quantity)
    }

    def jsObjectInventorySnapshot(obj: io.flow.inventory.v0.models.InventorySnapshot): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "available" -> play.api.libs.json.JsNumber(obj.available),
        "center" -> jsObjectInventoryCenterReference(obj.center),
        "item" -> jsObjectInventoryItemReference(obj.item),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      )
    }

    implicit def jsonWritesInventoryInventorySnapshot: play.api.libs.json.Writes[InventorySnapshot] = {
      (obj: io.flow.inventory.v0.models.InventorySnapshot) => {
        jsObjectInventorySnapshot(obj)
      }
    }

    implicit def jsonReadsInventoryInventorySnapshotVersion: play.api.libs.json.Reads[InventorySnapshotVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        inventorySnapshot <- (__ \ "inventory_snapshot").read[io.flow.inventory.v0.models.InventorySnapshot]
      } yield InventorySnapshotVersion(id, timestamp, `type`, inventorySnapshot)
    }

    def jsObjectInventorySnapshotVersion(obj: io.flow.inventory.v0.models.InventorySnapshotVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "inventory_snapshot" -> jsObjectInventorySnapshot(obj.inventorySnapshot)
      )
    }

    implicit def jsonWritesInventoryInventorySnapshotVersion: play.api.libs.json.Writes[InventorySnapshotVersion] = {
      (obj: io.flow.inventory.v0.models.InventorySnapshotVersion) => {
        jsObjectInventorySnapshotVersion(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryStock: play.api.libs.json.Reads[InventoryStock] = {
      (__ \ "quantity").read[Long].map { x => new InventoryStock(quantity = x) }
    }

    def jsObjectInventoryStock(obj: io.flow.inventory.v0.models.InventoryStock): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "inventory_stock")
    }

    implicit def jsonWritesInventoryInventoryStock: play.api.libs.json.Writes[InventoryStock] = {
      (obj: io.flow.inventory.v0.models.InventoryStock) => {
        jsObjectInventoryStock(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryUnlimited: play.api.libs.json.Reads[InventoryUnlimited] = {
      (__ \ "placeholder").readWithDefault[String]("unlimited").map { x => new InventoryUnlimited(placeholder = x) }
    }

    def jsObjectInventoryUnlimited(obj: io.flow.inventory.v0.models.InventoryUnlimited): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "placeholder" -> play.api.libs.json.JsString(obj.placeholder)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "inventory_unlimited")
    }

    implicit def jsonWritesInventoryInventoryUnlimited: play.api.libs.json.Writes[InventoryUnlimited] = {
      (obj: io.flow.inventory.v0.models.InventoryUnlimited) => {
        jsObjectInventoryUnlimited(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryUpdate: play.api.libs.json.Reads[InventoryUpdate] = {
      for {
        id <- (__ \ "id").read[String]
        idempotencyKey <- (__ \ "idempotency_key").read[String]
        center <- (__ \ "center").read[io.flow.inventory.v0.models.InventoryCenterReference]
        item <- (__ \ "item").read[io.flow.inventory.v0.models.InventoryItemReference]
        notes <- (__ \ "notes").read[_root_.play.api.libs.json.JsObject]
        quantity <- (__ \ "quantity").read[Long]
        `type` <- (__ \ "type").read[io.flow.inventory.v0.models.UpdateType]
      } yield InventoryUpdate(id, idempotencyKey, center, item, notes, quantity, `type`)
    }

    def jsObjectInventoryUpdate(obj: io.flow.inventory.v0.models.InventoryUpdate): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "idempotency_key" -> play.api.libs.json.JsString(obj.idempotencyKey),
        "center" -> jsObjectInventoryCenterReference(obj.center),
        "item" -> jsObjectInventoryItemReference(obj.item),
        "notes" -> obj.notes,
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      )
    }

    implicit def jsonWritesInventoryInventoryUpdate: play.api.libs.json.Writes[InventoryUpdate] = {
      (obj: io.flow.inventory.v0.models.InventoryUpdate) => {
        jsObjectInventoryUpdate(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryUpdateForm: play.api.libs.json.Reads[InventoryUpdateForm] = {
      for {
        center <- (__ \ "center").read[String]
        idempotencyKey <- (__ \ "idempotency_key").read[String]
        itemNumber <- (__ \ "item_number").read[String]
        quantity <- (__ \ "quantity").read[Long]
        `type` <- (__ \ "type").read[io.flow.inventory.v0.models.UpdateType]
        notes <- (__ \ "notes").readNullable[_root_.play.api.libs.json.JsObject]
      } yield InventoryUpdateForm(center, idempotencyKey, itemNumber, quantity, `type`, notes)
    }

    def jsObjectInventoryUpdateForm(obj: io.flow.inventory.v0.models.InventoryUpdateForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "center" -> play.api.libs.json.JsString(obj.center),
        "idempotency_key" -> play.api.libs.json.JsString(obj.idempotencyKey),
        "item_number" -> play.api.libs.json.JsString(obj.itemNumber),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      ) ++ (obj.notes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("notes" -> x)
      })
    }

    implicit def jsonWritesInventoryInventoryUpdateForm: play.api.libs.json.Writes[InventoryUpdateForm] = {
      (obj: io.flow.inventory.v0.models.InventoryUpdateForm) => {
        jsObjectInventoryUpdateForm(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryUpdateVersion: play.api.libs.json.Reads[InventoryUpdateVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        inventoryUpdate <- (__ \ "inventory_update").read[io.flow.inventory.v0.models.InventoryUpdate]
      } yield InventoryUpdateVersion(id, timestamp, `type`, inventoryUpdate)
    }

    def jsObjectInventoryUpdateVersion(obj: io.flow.inventory.v0.models.InventoryUpdateVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "inventory_update" -> jsObjectInventoryUpdate(obj.inventoryUpdate)
      )
    }

    implicit def jsonWritesInventoryInventoryUpdateVersion: play.api.libs.json.Writes[InventoryUpdateVersion] = {
      (obj: io.flow.inventory.v0.models.InventoryUpdateVersion) => {
        jsObjectInventoryUpdateVersion(obj)
      }
    }

    implicit def jsonReadsInventoryNoInventoryReservationError: play.api.libs.json.Reads[NoInventoryReservationError] = {
      for {
        messages <- (__ \ "messages").read[Seq[String]]
        items <- (__ \ "items").read[Seq[io.flow.inventory.v0.models.NoInventoryReservationErrorItem]]
      } yield NoInventoryReservationError(messages, items)
    }

    def jsObjectNoInventoryReservationError(obj: io.flow.inventory.v0.models.NoInventoryReservationError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "messages" -> play.api.libs.json.Json.toJson(obj.messages),
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ play.api.libs.json.Json.obj("code" -> "no_inventory")
    }

    implicit def jsonWritesInventoryNoInventoryReservationError: play.api.libs.json.Writes[NoInventoryReservationError] = {
      (obj: io.flow.inventory.v0.models.NoInventoryReservationError) => {
        jsObjectNoInventoryReservationError(obj)
      }
    }

    implicit def jsonReadsInventoryNoInventoryReservationErrorItem: play.api.libs.json.Reads[NoInventoryReservationErrorItem] = {
      for {
        number <- (__ \ "number").read[String]
        requestedQuantity <- (__ \ "requested_quantity").read[Long]
        availableQuantity <- (__ \ "available_quantity").read[Long]
      } yield NoInventoryReservationErrorItem(number, requestedQuantity, availableQuantity)
    }

    def jsObjectNoInventoryReservationErrorItem(obj: io.flow.inventory.v0.models.NoInventoryReservationErrorItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "requested_quantity" -> play.api.libs.json.JsNumber(obj.requestedQuantity),
        "available_quantity" -> play.api.libs.json.JsNumber(obj.availableQuantity)
      )
    }

    implicit def jsonWritesInventoryNoInventoryReservationErrorItem: play.api.libs.json.Writes[NoInventoryReservationErrorItem] = {
      (obj: io.flow.inventory.v0.models.NoInventoryReservationErrorItem) => {
        jsObjectNoInventoryReservationErrorItem(obj)
      }
    }

    implicit def jsonReadsInventoryPfsInventoryCheckResponse: play.api.libs.json.Reads[PfsInventoryCheckResponse] = {
      (__ \ "items").read[Map[String, io.flow.inventory.v0.models.PfsInventoryCheckResponseItem]].map { x => new PfsInventoryCheckResponse(items = x) }
    }

    def jsObjectPfsInventoryCheckResponse(obj: io.flow.inventory.v0.models.PfsInventoryCheckResponse): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      )
    }

    implicit def jsonWritesInventoryPfsInventoryCheckResponse: play.api.libs.json.Writes[PfsInventoryCheckResponse] = {
      (obj: io.flow.inventory.v0.models.PfsInventoryCheckResponse) => {
        jsObjectPfsInventoryCheckResponse(obj)
      }
    }

    implicit def jsonReadsInventoryPfsInventoryCheckResponseItem: play.api.libs.json.Reads[PfsInventoryCheckResponseItem] = {
      for {
        number <- (__ \ "number").read[String]
        ats <- (__ \ "ats").read[Long]
        inStock <- (__ \ "in_stock").read[Boolean]
      } yield PfsInventoryCheckResponseItem(number, ats, inStock)
    }

    def jsObjectPfsInventoryCheckResponseItem(obj: io.flow.inventory.v0.models.PfsInventoryCheckResponseItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "ats" -> play.api.libs.json.JsNumber(obj.ats),
        "in_stock" -> play.api.libs.json.JsBoolean(obj.inStock)
      )
    }

    implicit def jsonWritesInventoryPfsInventoryCheckResponseItem: play.api.libs.json.Writes[PfsInventoryCheckResponseItem] = {
      (obj: io.flow.inventory.v0.models.PfsInventoryCheckResponseItem) => {
        jsObjectPfsInventoryCheckResponseItem(obj)
      }
    }

    implicit def jsonReadsInventoryPfsInventoryStatus: play.api.libs.json.Reads[PfsInventoryStatus] = {
      (__ \ "status").read[String].map { x => new PfsInventoryStatus(status = x) }
    }

    def jsObjectPfsInventoryStatus(obj: io.flow.inventory.v0.models.PfsInventoryStatus): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status)
      )
    }

    implicit def jsonWritesInventoryPfsInventoryStatus: play.api.libs.json.Writes[PfsInventoryStatus] = {
      (obj: io.flow.inventory.v0.models.PfsInventoryStatus) => {
        jsObjectPfsInventoryStatus(obj)
      }
    }

    implicit def jsonReadsInventoryReservation: play.api.libs.json.Reads[Reservation] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        order <- (__ \ "order").readNullable[io.flow.inventory.v0.models.ReservationOrderReference]
        items <- (__ \ "items").read[Seq[io.flow.inventory.v0.models.ReservationItem]]
        reservedUntil <- (__ \ "reserved_until").readNullable[_root_.org.joda.time.DateTime]
      } yield Reservation(id, key, order, items, reservedUntil)
    }

    def jsObjectReservation(obj: io.flow.inventory.v0.models.Reservation): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.order match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order" -> jsObjectReservationOrderReference(x))
      }) ++
      (obj.reservedUntil match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("reserved_until" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      })
    }

    implicit def jsonWritesInventoryReservation: play.api.libs.json.Writes[Reservation] = {
      (obj: io.flow.inventory.v0.models.Reservation) => {
        jsObjectReservation(obj)
      }
    }

    implicit def jsonReadsInventoryReservationForm: play.api.libs.json.Reads[ReservationForm] = {
      for {
        orderNumber <- (__ \ "order_number").readNullable[String]
        items <- (__ \ "items").read[Seq[io.flow.inventory.v0.models.ReservationItemForm]]
      } yield ReservationForm(orderNumber, items)
    }

    def jsObjectReservationForm(obj: io.flow.inventory.v0.models.ReservationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.orderNumber match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order_number" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesInventoryReservationForm: play.api.libs.json.Writes[ReservationForm] = {
      (obj: io.flow.inventory.v0.models.ReservationForm) => {
        jsObjectReservationForm(obj)
      }
    }

    implicit def jsonReadsInventoryReservationItem: play.api.libs.json.Reads[ReservationItem] = {
      for {
        item <- (__ \ "item").read[io.flow.inventory.v0.models.ReservationItemReference]
        quantity <- (__ \ "quantity").read[Long]
      } yield ReservationItem(item, quantity)
    }

    def jsObjectReservationItem(obj: io.flow.inventory.v0.models.ReservationItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "item" -> jsObjectReservationItemReference(obj.item),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      )
    }

    implicit def jsonWritesInventoryReservationItem: play.api.libs.json.Writes[ReservationItem] = {
      (obj: io.flow.inventory.v0.models.ReservationItem) => {
        jsObjectReservationItem(obj)
      }
    }

    implicit def jsonReadsInventoryReservationItemForm: play.api.libs.json.Reads[ReservationItemForm] = {
      for {
        itemNumber <- (__ \ "item_number").read[String]
        quantity <- (__ \ "quantity").read[Long]
      } yield ReservationItemForm(itemNumber, quantity)
    }

    def jsObjectReservationItemForm(obj: io.flow.inventory.v0.models.ReservationItemForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "item_number" -> play.api.libs.json.JsString(obj.itemNumber),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      )
    }

    implicit def jsonWritesInventoryReservationItemForm: play.api.libs.json.Writes[ReservationItemForm] = {
      (obj: io.flow.inventory.v0.models.ReservationItemForm) => {
        jsObjectReservationItemForm(obj)
      }
    }

    implicit def jsonReadsInventoryReservationItemReference: play.api.libs.json.Reads[ReservationItemReference] = {
      (__ \ "number").read[String].map { x => new ReservationItemReference(number = x) }
    }

    def jsObjectReservationItemReference(obj: io.flow.inventory.v0.models.ReservationItemReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonWritesInventoryReservationItemReference: play.api.libs.json.Writes[ReservationItemReference] = {
      (obj: io.flow.inventory.v0.models.ReservationItemReference) => {
        jsObjectReservationItemReference(obj)
      }
    }

    implicit def jsonReadsInventoryReservationOrderReference: play.api.libs.json.Reads[ReservationOrderReference] = {
      (__ \ "number").read[String].map { x => new ReservationOrderReference(number = x) }
    }

    def jsObjectReservationOrderReference(obj: io.flow.inventory.v0.models.ReservationOrderReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonWritesInventoryReservationOrderReference: play.api.libs.json.Writes[ReservationOrderReference] = {
      (obj: io.flow.inventory.v0.models.ReservationOrderReference) => {
        jsObjectReservationOrderReference(obj)
      }
    }

    implicit def jsonReadsInventoryInventoryStrategy: play.api.libs.json.Reads[InventoryStrategy] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "inventory_backorder" => js.validate[io.flow.inventory.v0.models.InventoryBackorder]
          case "inventory_stock" => js.validate[io.flow.inventory.v0.models.InventoryStock]
          case "inventory_unlimited" => js.validate[io.flow.inventory.v0.models.InventoryUnlimited]
          case "inventory_follow_ecommerce_platform" => js.validate[io.flow.inventory.v0.models.InventoryFollowEcommercePlatform]
          case other => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.InventoryStrategyUndefinedType(other))
        }
      }
      (js \ "discriminator").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectInventoryStrategy(obj: io.flow.inventory.v0.models.InventoryStrategy): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.inventory.v0.models.InventoryBackorder => jsObjectInventoryBackorder(x)
        case x: io.flow.inventory.v0.models.InventoryStock => jsObjectInventoryStock(x)
        case x: io.flow.inventory.v0.models.InventoryUnlimited => jsObjectInventoryUnlimited(x)
        case x: io.flow.inventory.v0.models.InventoryFollowEcommercePlatform => jsObjectInventoryFollowEcommercePlatform(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesInventoryInventoryStrategy: play.api.libs.json.Writes[InventoryStrategy] = {
      (obj: io.flow.inventory.v0.models.InventoryStrategy) => {
        jsObjectInventoryStrategy(obj)
      }
    }

    implicit def jsonReadsInventoryReservationError: play.api.libs.json.Reads[ReservationError] = (js: play.api.libs.json.JsValue) => {
      def readDiscriminator(discriminator: String) = {
        discriminator match {
          case "no_inventory" => js.validate[io.flow.inventory.v0.models.NoInventoryReservationError]
          case "external_api_timeout" => js.validate[io.flow.inventory.v0.models.ExternalApiTimeoutReservationError]
          case "generic_reservation_error" => js.validate[io.flow.inventory.v0.models.GenericReservationError]
          case other => play.api.libs.json.JsSuccess(io.flow.inventory.v0.models.ReservationErrorUndefinedType(other))
        }
      }
      (js \ "code").validate[String] match {
        case e: play.api.libs.json.JsError => e
        case s: play.api.libs.json.JsSuccess[String] => readDiscriminator(s.value)
      }
    }

    def jsObjectReservationError(obj: io.flow.inventory.v0.models.ReservationError): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.inventory.v0.models.NoInventoryReservationError => jsObjectNoInventoryReservationError(x)
        case x: io.flow.inventory.v0.models.ExternalApiTimeoutReservationError => jsObjectExternalApiTimeoutReservationError(x)
        case x: io.flow.inventory.v0.models.GenericReservationError => jsObjectGenericReservationError(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesInventoryReservationError: play.api.libs.json.Writes[ReservationError] = {
      (obj: io.flow.inventory.v0.models.ReservationError) => {
        jsObjectReservationError(obj)
      }
    }
  }
}

package io.flow.inventory.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}

    // import models directly for backwards compatibility with prior versions of the generator
    import Core._
    import Models._

    object Core {
      implicit def pathBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.DateTime] = ApibuilderPathBindable(ApibuilderTypes.dateTimeIso8601)
      implicit def queryStringBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.DateTime] = ApibuilderQueryStringBindable(ApibuilderTypes.dateTimeIso8601)

      implicit def pathBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.LocalDate] = ApibuilderPathBindable(ApibuilderTypes.dateIso8601)
      implicit def queryStringBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.LocalDate] = ApibuilderQueryStringBindable(ApibuilderTypes.dateIso8601)
    }

    object Models {
      import io.flow.inventory.v0.models._

      val aggregateConverter: ApibuilderTypeConverter[io.flow.inventory.v0.models.Aggregate] = new ApibuilderTypeConverter[io.flow.inventory.v0.models.Aggregate] {
        override def convert(value: String): io.flow.inventory.v0.models.Aggregate = io.flow.inventory.v0.models.Aggregate(value)
        override def convert(value: io.flow.inventory.v0.models.Aggregate): String = value.toString
        override def example: io.flow.inventory.v0.models.Aggregate = io.flow.inventory.v0.models.Aggregate.Maximum
        override def validValues: Seq[io.flow.inventory.v0.models.Aggregate] = io.flow.inventory.v0.models.Aggregate.all
      }
      implicit def pathBindableAggregate(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.inventory.v0.models.Aggregate] = ApibuilderPathBindable(aggregateConverter)
      implicit def queryStringBindableAggregate(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.inventory.v0.models.Aggregate] = ApibuilderQueryStringBindable(aggregateConverter)

      val inventoryStatusConverter: ApibuilderTypeConverter[io.flow.inventory.v0.models.InventoryStatus] = new ApibuilderTypeConverter[io.flow.inventory.v0.models.InventoryStatus] {
        override def convert(value: String): io.flow.inventory.v0.models.InventoryStatus = io.flow.inventory.v0.models.InventoryStatus(value)
        override def convert(value: io.flow.inventory.v0.models.InventoryStatus): String = value.toString
        override def example: io.flow.inventory.v0.models.InventoryStatus = io.flow.inventory.v0.models.InventoryStatus.HasInventory
        override def validValues: Seq[io.flow.inventory.v0.models.InventoryStatus] = io.flow.inventory.v0.models.InventoryStatus.all
      }
      implicit def pathBindableInventoryStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.inventory.v0.models.InventoryStatus] = ApibuilderPathBindable(inventoryStatusConverter)
      implicit def queryStringBindableInventoryStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.inventory.v0.models.InventoryStatus] = ApibuilderQueryStringBindable(inventoryStatusConverter)

      val updateTypeConverter: ApibuilderTypeConverter[io.flow.inventory.v0.models.UpdateType] = new ApibuilderTypeConverter[io.flow.inventory.v0.models.UpdateType] {
        override def convert(value: String): io.flow.inventory.v0.models.UpdateType = io.flow.inventory.v0.models.UpdateType(value)
        override def convert(value: io.flow.inventory.v0.models.UpdateType): String = value.toString
        override def example: io.flow.inventory.v0.models.UpdateType = io.flow.inventory.v0.models.UpdateType.Change
        override def validValues: Seq[io.flow.inventory.v0.models.UpdateType] = io.flow.inventory.v0.models.UpdateType.all
      }
      implicit def pathBindableUpdateType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.inventory.v0.models.UpdateType] = ApibuilderPathBindable(updateTypeConverter)
      implicit def queryStringBindableUpdateType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.inventory.v0.models.UpdateType] = ApibuilderQueryStringBindable(updateTypeConverter)
    }

    trait ApibuilderTypeConverter[T] {

      def convert(value: String): T

      def convert(value: T): String

      def example: T

      def validValues: Seq[T] = Nil

      def errorMessage(key: String, value: String, ex: java.lang.Exception): String = {
        val base = s"Invalid value '$value' for parameter '$key'. "
        validValues.toList match {
          case Nil => base + "Ex: " + convert(example)
          case values => base + ". Valid values are: " + values.mkString("'", "', '", "'")
        }
      }
    }

    object ApibuilderTypes {
      val dateTimeIso8601: ApibuilderTypeConverter[_root_.org.joda.time.DateTime] = new ApibuilderTypeConverter[_root_.org.joda.time.DateTime] {
        override def convert(value: String): _root_.org.joda.time.DateTime = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(value)
        override def convert(value: _root_.org.joda.time.DateTime): String = _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(value)
        override def example: _root_.org.joda.time.DateTime = _root_.org.joda.time.DateTime.now
      }

      val dateIso8601: ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] = new ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] {
        override def convert(value: String): _root_.org.joda.time.LocalDate = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(value)
        override def convert(value: _root_.org.joda.time.LocalDate): String = _root_.org.joda.time.format.ISODateTimeFormat.date.print(value)
        override def example: _root_.org.joda.time.LocalDate = _root_.org.joda.time.LocalDate.now
      }
    }

    final case class ApibuilderQueryStringBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends QueryStringBindable[T] {

      override def bind(key: String, params: Map[String, Seq[String]]): _root_.scala.Option[_root_.scala.Either[String, T]] = {
        params.getOrElse(key, Nil).headOption.map { v =>
          try {
            Right(
              converters.convert(v)
            )
          } catch {
            case ex: java.lang.Exception => Left(
              converters.errorMessage(key, v, ex)
            )
          }
        }
      }

      override def unbind(key: String, value: T): String = {
        s"$key=${converters.convert(value)}"
      }
    }

    final case class ApibuilderPathBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends PathBindable[T] {

      override def bind(key: String, value: String): _root_.scala.Either[String, T] = {
        try {
          Right(
            converters.convert(value)
          )
        } catch {
          case ex: java.lang.Exception => Left(
            converters.errorMessage(key, value, ex)
          )
        }
      }

      override def unbind(key: String, value: T): String = {
        converters.convert(value)
      }
    }

  }

}
