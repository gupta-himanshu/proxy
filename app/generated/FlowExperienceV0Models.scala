/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.10.59
 * apibuilder 0.15.33 app.apibuilder.io/flow/experience/latest/play_2_x_json
 */
package io.flow.experience.v0.models {

  /**
   * @param subtotal Base price of this item before discounts, duties, taxes or subsidies.
   * @param discount Discounts that apply exclusively to this item. Should always be a negative
   *        value.
   * @param duties Duties to be paid on behalf of this item.
   * @param tax Tax to be paid on behalf of this item.
   * @param taxSubsidy Tax paid by the client on behalf of the consumer. Should always be a negative
   *        value.
   * @param dutiesSubsidy Duty paid by the client on behalf of the consumer. Should always be a negative
   *        value.
   */
  trait AllocationLineSummaryFields {
    def subtotal: io.flow.common.v0.models.MoneyWithBase
    def discount: io.flow.common.v0.models.MoneyWithBase
    def duties: io.flow.common.v0.models.MoneyWithBase
    def tax: io.flow.common.v0.models.MoneyWithBase
    def taxSubsidy: io.flow.common.v0.models.MoneyWithBase
    def dutiesSubsidy: io.flow.common.v0.models.MoneyWithBase
    def total: io.flow.common.v0.models.MoneyWithBase
  }
  sealed trait AllocationComponent extends _root_.scala.Product with _root_.scala.Serializable {
    def key: io.flow.order.price.v0.models.OrderPriceDetailComponentKey
    def total: io.flow.common.v0.models.PriceWithBase
    def price: _root_.scala.Option[io.flow.common.v0.models.PriceWithBase]
  }

  /**
   * Defines the valid discriminator values for the type AllocationComponent
   */
  sealed trait AllocationComponentDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object AllocationComponentDiscriminator {

    case object AllocationDetailComponent extends AllocationComponentDiscriminator { override def toString = "allocation_detail_component" }
    case object AllocationLevyComponent extends AllocationComponentDiscriminator { override def toString = "allocation_levy_component" }

    final case class UNDEFINED(override val toString: String) extends AllocationComponentDiscriminator

    val all: scala.List[AllocationComponentDiscriminator] = scala.List(AllocationDetailComponent, AllocationLevyComponent)

    private[this] val byName: Map[String, AllocationComponentDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AllocationComponentDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AllocationComponentDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait AllocationDetail extends _root_.scala.Product with _root_.scala.Serializable {
    def key: io.flow.order.price.v0.models.OrderPriceDetailKey
    def total: io.flow.common.v0.models.PriceWithBase
    def included: Seq[io.flow.experience.v0.models.AllocationComponent]
    def notIncluded: Seq[io.flow.experience.v0.models.AllocationComponent]
  }

  /**
   * Defines the valid discriminator values for the type AllocationDetail
   */
  sealed trait AllocationDetailDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object AllocationDetailDiscriminator {

    case object AllocationLineDetail extends AllocationDetailDiscriminator { override def toString = "allocation_line_detail" }
    case object AllocationOrderDetail extends AllocationDetailDiscriminator { override def toString = "allocation_order_detail" }

    final case class UNDEFINED(override val toString: String) extends AllocationDetailDiscriminator

    val all: scala.List[AllocationDetailDiscriminator] = scala.List(AllocationLineDetail, AllocationOrderDetail)

    private[this] val byName: Map[String, AllocationDetailDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AllocationDetailDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AllocationDetailDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait DiscountRuleEntitlement extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type DiscountRuleEntitlement
   */
  sealed trait DiscountRuleEntitlementDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object DiscountRuleEntitlementDiscriminator {

    case object DiscountRuleSubsidyEntitlement extends DiscountRuleEntitlementDiscriminator { override def toString = "subsidy" }

    final case class UNDEFINED(override val toString: String) extends DiscountRuleEntitlementDiscriminator

    val all: scala.List[DiscountRuleEntitlementDiscriminator] = scala.List(DiscountRuleSubsidyEntitlement)

    private[this] val byName: Map[String, DiscountRuleEntitlementDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DiscountRuleEntitlementDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DiscountRuleEntitlementDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait ExpandableExperience extends _root_.scala.Product with _root_.scala.Serializable {
    def key: String
  }

  /**
   * Defines the valid discriminator values for the type ExpandableExperience
   */
  sealed trait ExpandableExperienceDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ExpandableExperienceDiscriminator {

    case object Experience extends ExpandableExperienceDiscriminator { override def toString = "experience" }
    case object ExperienceReference extends ExpandableExperienceDiscriminator { override def toString = "experience_reference" }

    final case class UNDEFINED(override val toString: String) extends ExpandableExperienceDiscriminator

    val all: scala.List[ExpandableExperienceDiscriminator] = scala.List(Experience, ExperienceReference)

    private[this] val byName: Map[String, ExpandableExperienceDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExpandableExperienceDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExpandableExperienceDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait ExpandableOrder extends _root_.scala.Product with _root_.scala.Serializable {
    def id: String
    def number: String
  }

  /**
   * Defines the valid discriminator values for the type ExpandableOrder
   */
  sealed trait ExpandableOrderDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object ExpandableOrderDiscriminator {

    case object Order extends ExpandableOrderDiscriminator { override def toString = "order" }
    case object OrderReference extends ExpandableOrderDiscriminator { override def toString = "order_reference" }

    final case class UNDEFINED(override val toString: String) extends ExpandableOrderDiscriminator

    val all: scala.List[ExpandableOrderDiscriminator] = scala.List(Order, OrderReference)

    private[this] val byName: Map[String, ExpandableOrderDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExpandableOrderDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExpandableOrderDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait OrderNumberGenerator extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type OrderNumberGenerator
   */
  sealed trait OrderNumberGeneratorDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object OrderNumberGeneratorDiscriminator {

    case object OrderNumberGeneratorUuid extends OrderNumberGeneratorDiscriminator { override def toString = "uuid" }
    case object OrderNumberGeneratorHexadecimal extends OrderNumberGeneratorDiscriminator { override def toString = "hexadecimal" }
    case object OrderNumberGeneratorPrefixSuffix extends OrderNumberGeneratorDiscriminator { override def toString = "prefix_suffix" }

    final case class UNDEFINED(override val toString: String) extends OrderNumberGeneratorDiscriminator

    val all: scala.List[OrderNumberGeneratorDiscriminator] = scala.List(OrderNumberGeneratorUuid, OrderNumberGeneratorHexadecimal, OrderNumberGeneratorPrefixSuffix)

    private[this] val byName: Map[String, OrderNumberGeneratorDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderNumberGeneratorDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderNumberGeneratorDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait OrderPromotion extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type OrderPromotion
   */
  sealed trait OrderPromotionDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object OrderPromotionDiscriminator {

    case object FreeShippingOrderPromotion extends OrderPromotionDiscriminator { override def toString = "free_shipping_order_promotion" }

    final case class UNDEFINED(override val toString: String) extends OrderPromotionDiscriminator

    val all: scala.List[OrderPromotionDiscriminator] = scala.List(FreeShippingOrderPromotion)

    private[this] val byName: Map[String, OrderPromotionDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderPromotionDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderPromotionDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait OrderPromotionForm extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type OrderPromotionForm
   */
  sealed trait OrderPromotionFormDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object OrderPromotionFormDiscriminator {

    case object FreeShippingOrderPromotionForm extends OrderPromotionFormDiscriminator { override def toString = "free_shipping_order_promotion_form" }

    final case class UNDEFINED(override val toString: String) extends OrderPromotionFormDiscriminator

    val all: scala.List[OrderPromotionFormDiscriminator] = scala.List(FreeShippingOrderPromotionForm)

    private[this] val byName: Map[String, OrderPromotionFormDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderPromotionFormDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderPromotionFormDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait OrderRefundSummaryForm extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type OrderRefundSummaryForm
   */
  sealed trait OrderRefundSummaryFormDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object OrderRefundSummaryFormDiscriminator {

    case object OrderRefundSummaryFullForm extends OrderRefundSummaryFormDiscriminator { override def toString = "order_refund_summary_full_form" }
    case object OrderRefundSummaryPartialForm extends OrderRefundSummaryFormDiscriminator { override def toString = "order_refund_summary_partial_form" }

    final case class UNDEFINED(override val toString: String) extends OrderRefundSummaryFormDiscriminator

    val all: scala.List[OrderRefundSummaryFormDiscriminator] = scala.List(OrderRefundSummaryFullForm, OrderRefundSummaryPartialForm)

    private[this] val byName: Map[String, OrderRefundSummaryFormDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderRefundSummaryFormDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderRefundSummaryFormDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait PaymentMethodTag extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type PaymentMethodTag
   */
  sealed trait PaymentMethodTagDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object PaymentMethodTagDiscriminator {

    case object OrganizationPaymentMethodTag extends PaymentMethodTagDiscriminator { override def toString = "organization_payment_method_tag" }
    case object ExperiencePaymentMethodTag extends PaymentMethodTagDiscriminator { override def toString = "experience_payment_method_tag" }

    final case class UNDEFINED(override val toString: String) extends PaymentMethodTagDiscriminator

    val all: scala.List[PaymentMethodTagDiscriminator] = scala.List(OrganizationPaymentMethodTag, ExperiencePaymentMethodTag)

    private[this] val byName: Map[String, PaymentMethodTagDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PaymentMethodTagDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PaymentMethodTagDiscriminator] = byName.get(value.toLowerCase)

  }

  sealed trait Promotion extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid discriminator values for the type Promotion
   */
  sealed trait PromotionDiscriminator extends _root_.scala.Product with _root_.scala.Serializable

  object PromotionDiscriminator {

    case object FreeShipping extends PromotionDiscriminator { override def toString = "free_shipping" }
    case object Discount extends PromotionDiscriminator { override def toString = "discount" }

    final case class UNDEFINED(override val toString: String) extends PromotionDiscriminator

    val all: scala.List[PromotionDiscriminator] = scala.List(FreeShipping, Discount)

    private[this] val byName: Map[String, PromotionDiscriminator] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PromotionDiscriminator = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PromotionDiscriminator] = byName.get(value.toLowerCase)

  }

  /**
   * @param country The ISO 3166-3 country code. Case insensitive. See
   *        https://api.flow.io/reference/countries
   * @param formats Dictates the layouts in which fields are to appear to the customer. For example,
   *        when entering a destination address during checkout.
   * @param provinceType The local terminology for province
   * @param postalType The local terminology for postal code
   */
  final case class AddressConfiguration(
    country: String,
    fieldValidation: io.flow.experience.v0.models.AddressFieldValidation,
    provinces: Seq[io.flow.experience.v0.models.AddressConfigurationProvince] = Nil,
    formats: Seq[io.flow.experience.v0.models.AddressConfigurationFormat] = Nil,
    provinceType: _root_.scala.Option[io.flow.reference.v0.models.ProvinceType] = None,
    postalType: _root_.scala.Option[io.flow.reference.v0.models.PostalType] = None
  )

  final case class AddressConfigurationFieldPlacement(
    name: io.flow.experience.v0.models.AddressFieldName
  )

  /**
   * Field placements within an address configuration format
   *
   * @param placements Placements dictate the ordering of address fields on a line.
   */
  final case class AddressConfigurationFormat(
    placements: Seq[io.flow.experience.v0.models.AddressConfigurationFieldPlacement]
  )

  /**
   * @param value This will either be the name of the province (e.g. Ontario) or the code (e.g.
   *        ON) based on the organization configuration
   * @param name The name of the province
   * @param translations This will contain translation details for the province
   */
  final case class AddressConfigurationProvince(
    value: String,
    name: String,
    translations: _root_.scala.Option[Seq[io.flow.experience.v0.models.AddressConfigurationProvinceTranslation]] = None
  )

  final case class AddressConfigurationProvinceTranslation(
    locale: io.flow.experience.v0.models.AddressConfigurationProvinceTranslationLocale,
    name: String
  )

  final case class AddressConfigurationProvinceTranslationLocale(
    id: String,
    name: String,
    language: String
  )

  final case class AddressFieldValidation(
    firstName: Seq[io.flow.field.validation.v0.models.FieldValidationRule] = Nil,
    lastName: Seq[io.flow.field.validation.v0.models.FieldValidationRule] = Nil,
    street1: Seq[io.flow.field.validation.v0.models.FieldValidationRule] = Nil,
    street2: Seq[io.flow.field.validation.v0.models.FieldValidationRule] = Nil,
    city: Seq[io.flow.field.validation.v0.models.FieldValidationRule] = Nil,
    province: Seq[io.flow.field.validation.v0.models.FieldValidationRule] = Nil,
    postal: Seq[io.flow.field.validation.v0.models.FieldValidationRule] = Nil,
    phone: Seq[io.flow.field.validation.v0.models.FieldValidationRule] = Nil,
    vatRegistrationNumber: Seq[io.flow.field.validation.v0.models.FieldValidationRule] = Nil
  )

  @deprecated("Use 'allocation_v2'")
  final case class Allocation(
    order: io.flow.experience.v0.models.AllocationOrderSummary,
    details: Seq[io.flow.experience.v0.models.AllocationDetail]
  )

  /**
   * Represents any component that is not VAT or duty, such as item price, rounding,
   * shipping, etc.
   *
   * @param total Represents the total price of this line item, which equals the price times the
   *        quantity.
   * @param price Represents the price of all included detail components for one unit of this line
   *        item.
   */
  final case class AllocationDetailComponent(
    override val key: io.flow.order.price.v0.models.OrderPriceDetailComponentKey,
    override val total: io.flow.common.v0.models.PriceWithBase,
    override val price: _root_.scala.Option[io.flow.common.v0.models.PriceWithBase] = None
  ) extends AllocationComponent

  /**
   * Represents either a VAT or duty component.
   *
   * @param total Represents the total price of this line item, which equals the price times the
   *        quantity.
   * @param rate The rate of the levy.
   * @param name The name of the levy, for display purposes.
   * @param price Represents the price of all included detail components for one unit of this line
   *        item.
   * @param accuracy Used to flag prices that are estimated and why. Missing values will be
   *        considered calculated. An order may only be submitted if all price components
   *        are calculated.
   * @param basis The taxable/dutiable basis from which this levy component was produced. Should
   *        be equal to total / rate.
   */
  final case class AllocationLevyComponent(
    override val key: io.flow.order.price.v0.models.OrderPriceDetailComponentKey,
    override val total: io.flow.common.v0.models.PriceWithBase,
    rate: BigDecimal,
    name: String,
    override val price: _root_.scala.Option[io.flow.common.v0.models.PriceWithBase] = None,
    accuracy: io.flow.price.v0.models.PriceAccuracy = io.flow.price.v0.models.PriceAccuracy.Calculated,
    basis: _root_.scala.Option[io.flow.common.v0.models.MoneyWithBase] = None
  ) extends AllocationComponent

  /**
   * @param id Unique identifier for this line. Introduced in Oct 2020 and thus optional.
   * @param price Represents the price of all included detail components for one unit of this line
   *        item.
   * @param included Contains all components that are included in this detail's total.
   * @param notIncluded Contains all components that are not included in this detail's total. For
   *        example, this may contain VAT components when the VAT pricing setting is
   *        displayed or ignored.
   */
  final case class AllocationLineDetail(
    id: _root_.scala.Option[String] = None,
    number: String,
    quantity: Long,
    override val key: io.flow.order.price.v0.models.OrderPriceDetailKey,
    price: io.flow.common.v0.models.PriceWithBase,
    override val total: io.flow.common.v0.models.PriceWithBase,
    override val included: Seq[io.flow.experience.v0.models.AllocationComponent],
    override val notIncluded: Seq[io.flow.experience.v0.models.AllocationComponent]
  ) extends AllocationDetail

  /**
   * A line-based view of order financials.
   *
   * @param subtotal Base price of this item before discounts, duties, taxes or subsidies.
   * @param discount Discounts that apply exclusively to this item. Should always be a negative
   *        value.
   * @param duties Duties to be paid on behalf of this item.
   * @param tax Tax to be paid on behalf of this item.
   * @param taxSubsidy Tax paid by the client on behalf of the consumer. Should always be a negative
   *        value.
   * @param dutiesSubsidy Duty paid by the client on behalf of the consumer. Should always be a negative
   *        value.
   */
  final case class AllocationLineSummary(
    lineItems: Seq[io.flow.experience.v0.models.AllocationLineSummaryLineItem],
    shipping: io.flow.experience.v0.models.AllocationLineSummaryShipping,
    override val subtotal: io.flow.common.v0.models.MoneyWithBase,
    override val discount: io.flow.common.v0.models.MoneyWithBase,
    override val duties: io.flow.common.v0.models.MoneyWithBase,
    override val tax: io.flow.common.v0.models.MoneyWithBase,
    override val taxSubsidy: io.flow.common.v0.models.MoneyWithBase,
    override val dutiesSubsidy: io.flow.common.v0.models.MoneyWithBase,
    override val total: io.flow.common.v0.models.MoneyWithBase
  ) extends AllocationLineSummaryFields

  /**
   * A simplified view on order financial details. Represents a single line on an
   * order.
   *
   * @param subtotal Base price of this item before discounts, duties, taxes or subsidies.
   * @param discount Discounts that apply exclusively to this item. Should always be a negative
   *        value.
   * @param duties Duties to be paid on behalf of this item.
   * @param tax Tax to be paid on behalf of this item.
   * @param taxSubsidy Tax paid by the client on behalf of the consumer. Should always be a negative
   *        value.
   * @param dutiesSubsidy Duty paid by the client on behalf of the consumer. Should always be a negative
   *        value.
   */
  final case class AllocationLineSummaryLineItem(
    itemNumber: String,
    lineNumber: _root_.scala.Option[String] = None,
    override val subtotal: io.flow.common.v0.models.MoneyWithBase,
    override val discount: io.flow.common.v0.models.MoneyWithBase,
    override val duties: io.flow.common.v0.models.MoneyWithBase,
    override val tax: io.flow.common.v0.models.MoneyWithBase,
    override val taxSubsidy: io.flow.common.v0.models.MoneyWithBase,
    override val dutiesSubsidy: io.flow.common.v0.models.MoneyWithBase,
    override val total: io.flow.common.v0.models.MoneyWithBase
  ) extends AllocationLineSummaryFields

  /**
   * A simplified view on order financial details. Represents the shipping details
   * for an order.
   *
   * @param subtotal Base price of this item before discounts, duties, taxes or subsidies.
   * @param discount Discounts that apply exclusively to this item. Should always be a negative
   *        value.
   * @param duties Duties to be paid on behalf of this item.
   * @param tax Tax to be paid on behalf of this item.
   * @param taxSubsidy Tax paid by the client on behalf of the consumer. Should always be a negative
   *        value.
   * @param dutiesSubsidy Duty paid by the client on behalf of the consumer. Should always be a negative
   *        value.
   */
  final case class AllocationLineSummaryShipping(
    override val subtotal: io.flow.common.v0.models.MoneyWithBase,
    override val discount: io.flow.common.v0.models.MoneyWithBase,
    override val duties: io.flow.common.v0.models.MoneyWithBase,
    override val tax: io.flow.common.v0.models.MoneyWithBase,
    override val taxSubsidy: io.flow.common.v0.models.MoneyWithBase,
    override val dutiesSubsidy: io.flow.common.v0.models.MoneyWithBase,
    override val total: io.flow.common.v0.models.MoneyWithBase
  ) extends AllocationLineSummaryFields

  /**
   * Represents an order-specific detail such as shipping, insurance, or an
   * order-level discount.
   *
   * @param included Contains all components that are included in this detail's total.
   * @param notIncluded Contains all components that are not included in this detail's total. For
   *        example, this may contain VAT components when the VAT pricing setting is
   *        displayed or ignored.
   */
  final case class AllocationOrderDetail(
    override val key: io.flow.order.price.v0.models.OrderPriceDetailKey,
    override val total: io.flow.common.v0.models.PriceWithBase,
    override val included: Seq[io.flow.experience.v0.models.AllocationComponent],
    override val notIncluded: Seq[io.flow.experience.v0.models.AllocationComponent]
  ) extends AllocationDetail

  /**
   * @param submittedAt The timestamp on which the order is submitted
   */
  final case class AllocationOrderSummary(
    id: String,
    number: String,
    submittedAt: _root_.scala.Option[_root_.org.joda.time.DateTime] = None
  )

  final case class AllocationV2(
    id: String,
    order: io.flow.experience.v0.models.AllocationOrderSummary,
    details: Seq[io.flow.experience.v0.models.AllocationDetail],
    total: io.flow.catalog.v0.models.LocalizedTotal
  )

  final case class AvailablePromotion(
    id: String,
    shippingConfiguration: io.flow.fulfillment.v0.models.ShippingConfigurationReference,
    region: io.flow.experience.v0.models.RegionReference,
    promotions: Seq[io.flow.experience.v0.models.Promotion]
  )

  /**
   * A Checkout Attribute defines an attribute that will be made available via the
   * checkout item content. This is useful if you would like to surface a specific
   * attribute (like 'size' or 'color') in checkout.
   *
   * @param attributeKeys The attribute keys containing the desired value. The first key that is defined
   *        will be selected. For example, specify ['size', 'sizeName'] to select the 'size'
   *        attribute if present, and if not the 'sizeName' attribute.
   */
  final case class CheckoutAttribute(
    id: String,
    experience: io.flow.experience.v0.models.ExperienceReference,
    key: String,
    name: String,
    attributeKeys: Seq[String],
    position: Long
  )

  /**
   * @param name Defaults to the key
   * @param attributeKeys The attribute keys containing the desired value. The first key that is defined
   *        will be selected. For example, specify ['size', 'sizeName'] to select the 'size'
   *        attribute if present, and if not the 'sizeName' attribute.
   */
  final case class CheckoutAttributeForm(
    key: String,
    name: _root_.scala.Option[String] = None,
    experienceKey: String,
    attributeKeys: Seq[String],
    position: _root_.scala.Option[Long] = None
  )

  /**
   * A Checkout Item Content provides information about an item to support rendering
   * of that item in the context of checkout
   *
   * @param attributes Returns a list of item attributes w/ intent 'checkout_content'
   * @param image Provides the primary image to use in checkout. This image will be selected by
   *        finding the item image with tag 'checkout', defaulting to another available
   *        image if there is one.
   */
  final case class CheckoutItemContent(
    item: io.flow.catalog.v0.models.Item,
    name: String,
    description: _root_.scala.Option[String] = None,
    attributes: Seq[io.flow.experience.v0.models.CheckoutItemContentAttribute],
    image: _root_.scala.Option[io.flow.catalog.v0.models.Image] = None
  )

  final case class CheckoutItemContentAttribute(
    key: String,
    name: String,
    value: String
  )

  /**
   * @param country ISO 3166-3 country code as defined in https://api.flow.io/reference/countries
   */
  final case class CountryStatus(
    id: String,
    country: String,
    status: io.flow.experience.v0.models.ExperienceCountryStatus
  )

  final case class CountryStatusForm(
    status: io.flow.experience.v0.models.ExperienceCountryStatus
  )

  /**
   * A Credit Payment records a 'non cash' payment against an order (e.g. a store
   * credit, gift card, etc.), recording the amount of that credit and additional
   * details to reconcile payments. The primary purpose of the credit payment is to
   * record that a payment has been made against an order so the remaining balance
   * can be correctly computed.
   *
   * @param description Description to show to the user describing the source of this credit payment
   * @param value The value of the credit in the local and base currencies of the associated
   *        order. This value will match the original credit payment if the currency is the
   *        same as the order or otherwise will match the currency of the order
   * @param original The provided value and maximum value amounts and currencies applicable fot the
   *        store credit
   */
  final case class CreditPayment(
    id: String,
    order: io.flow.experience.v0.models.ExpandableOrder,
    key: String,
    description: String,
    value: io.flow.common.v0.models.PriceWithBase,
    original: io.flow.experience.v0.models.OriginalPrices,
    attributes: Map[String, String]
  )

  final case class CreditPaymentError(
    code: io.flow.experience.v0.models.CreditPaymentErrorCode,
    messages: Seq[String],
    codes: Seq[io.flow.experience.v0.models.CreditPaymentErrorCode]
  )

  /**
   * @param description Description to show to the user describing the source of this credit payment
   * @param max Indicates the maximum amount applicable for this credit payment.
   * @param currency The ISO-4217 3 character currency code in which the amount is calculated.
   */
  final case class CreditPaymentForm(
    orderNumber: String,
    description: String,
    amount: BigDecimal,
    max: BigDecimal,
    currency: String,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  final case class CreditPaymentVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    creditPayment: io.flow.experience.v0.models.CreditPayment
  )

  /**
   * @param timezone The timezone name. Case insensitive. See https://api.flow.io/reference/timezones
   */
  final case class DatetimeWithTimezone(
    datetime: _root_.org.joda.time.DateTime,
    timezone: String
  )

  /**
   * @param default Default delivered duty setting based on experience default settings and
   *        reference data.
   * @param available Available delivered duty options to pick.
   */
  final case class DeliveredDutySetting(
    default: io.flow.common.v0.models.DeliveredDuty,
    available: Seq[io.flow.common.v0.models.DeliveredDuty],
    display: _root_.scala.Option[io.flow.experience.v0.models.DeliveredDutyDisplayType] = None
  )

  /**
   * @param code Indicates what discount code this discount is associated with
   */
  final case class Discount(
    id: String,
    code: _root_.scala.Option[String] = None,
    label: String,
    price: io.flow.common.v0.models.PriceWithBase,
    attributes: _root_.scala.Option[Map[String, String]] = None
  ) extends Promotion

  final case class DiscountRule(
    offers: Seq[io.flow.experience.v0.models.DiscountRuleOffer]
  )

  /**
   * @param entitlement The recipient of the offer
   */
  final case class DiscountRuleOffer(
    discount: io.flow.common.v0.models.DiscountOffer,
    entitlement: io.flow.experience.v0.models.DiscountRuleEntitlement
  )

  final case class DiscountRuleSettings(
    id: String,
    name: String,
    fromWithTz: io.flow.experience.v0.models.DatetimeWithTimezone,
    toWithTz: _root_.scala.Option[io.flow.experience.v0.models.DatetimeWithTimezone] = None,
    status: io.flow.experience.v0.models.DiscountRuleStatus,
    experienceKeys: Seq[String],
    rule: io.flow.experience.v0.models.DiscountRule
  )

  final case class DiscountRuleSettingsForm(
    name: String,
    fromWithTz: io.flow.experience.v0.models.DatetimeWithTimezone,
    toWithTz: _root_.scala.Option[io.flow.experience.v0.models.DatetimeWithTimezone] = None,
    experienceKeys: Seq[String],
    rule: io.flow.experience.v0.models.DiscountRule
  )

  final case class DiscountRuleSubsidyEntitlement(
    targets: Seq[io.flow.experience.v0.models.DiscountRuleSubsidyTarget]
  ) extends DiscountRuleEntitlement

  /**
   * Experiences define a local experience for a given geographic region
   *
   * @param deliveredDuty Determines if a given experience should be DDP, DDU, or customer choice. If DDP,
   *        note that in some cases if a customer is shipping to a country where DDP is not
   *        available, information may still come back as DDU
   * @param region Reference to region as defined in https://api.flow.io/reference/regions
   * @param country When otherwise not known, the default country to use for this experience. One
   *        example would be an experience setup for Europe - when you request landed cost,
   *        if there is no geolocation information available, we will use this country as
   *        the basis for landed cost. ISO 3166 3 currency code as defined in
   *        https://api.flow.io/reference/countries
   * @param currency This currency defines the base currency for all pricing related features - e.g.
   *        pricing functions. ISO 4217 3 currency code as defined in
   *        https://api.flow.io/reference/currencies
   * @param language The default language to use for when displaying products, e.g. to display
   *        product information in this language by default. ISO 639 2 language code as
   *        defined in https://api.flow.io/reference/languages
   * @param position Position of this experience relative to other experiences. Lower position
   *        indicates experience should be considered first. Main use is to resolve incoming
   *        geolocation data (e.g. ip, country) to pick an experience. We do this by walking
   *        through the list of experiences to find the first one that matches the user's
   *        geography.
   * @param status Will always be present (optional for backwards compatibility).
   */
  final case class Experience(
    id: String,
    override val key: String,
    name: String,
    deliveredDuty: io.flow.common.v0.models.DeliveredDuty,
    region: io.flow.experience.v0.models.RegionReference,
    country: String,
    currency: String,
    language: String,
    measurementSystem: io.flow.common.v0.models.MeasurementSystem,
    subcatalog: io.flow.catalog.v0.models.SubcatalogReference,
    position: Long,
    settings: io.flow.experience.v0.models.ExperienceSettings,
    status: _root_.scala.Option[io.flow.experience.v0.models.ExperienceStatus] = None
  ) extends ExpandableExperience

  final case class ExperienceCheckoutConfigurationSettings(
    configuration: io.flow.experience.v0.models.ExperienceConfigurationReference
  )

  final case class ExperienceCheckoutSettings(
    id: String,
    experience: io.flow.experience.v0.models.ExperienceOverview,
    checkoutConfiguration: io.flow.experience.v0.models.ExperienceConfigurationReference
  )

  final case class ExperienceCheckoutSettingsForm(
    checkoutConfigurationId: String
  )

  /**
   * Represents a request to clone an experience.
   *
   * @param clonedExperience This is the newly created (cloned) experience
   */
  final case class ExperienceClone(
    id: String,
    sourceExperience: io.flow.experience.v0.models.ExperienceReference,
    clonedExperience: _root_.scala.Option[io.flow.experience.v0.models.ExperienceReference] = None,
    status: io.flow.experience.v0.models.ExperienceCloneStatus
  )

  /**
   * Form for cloning an experience
   *
   * @param name Name for the new cloned experience. Will be auto generated if not provided
   */
  final case class ExperienceCloneForm(
    name: _root_.scala.Option[String] = None
  )

  final case class ExperienceConfigurationReference(
    id: String
  )

  final case class ExperienceCurrencyFormat(
    symbol: io.flow.common.v0.models.CurrencySymbolFormat,
    labelFormatters: Seq[io.flow.common.v0.models.CurrencyLabelFormatter]
  )

  final case class ExperienceCurrencyFormatForm(
    symbol: io.flow.common.v0.models.CurrencySymbolFormat,
    labelFormatters: Seq[io.flow.common.v0.models.CurrencyLabelFormatter]
  )

  /**
   * Defines a set of defaults for a given organization and region
   *
   * @param key Default key - guaranteed to be unique
   * @param name Default name for the experience - guaranteed to be unique
   */
  final case class ExperienceDefaults(
    key: String,
    name: String,
    deliveredDuty: io.flow.common.v0.models.DeliveredDuty,
    country: String,
    currency: String,
    language: String,
    measurementSystem: io.flow.common.v0.models.MeasurementSystem
  )

  /**
   * Experiences define a local experience for a given geographic region
   *
   * @param regionId The actual geographic area to which this experience is targeted. Value is the
   *        region Id as defined in https://api.flow.io/reference/regions - To create a
   *        'default' experience, set region_id to 'world'
   * @param name Name for the experience
   * @param deliveredDuty Determines if a given experience should be DDP, DDU, or customer choice. If DDP,
   *        note that in some cases if a customer is shipping to a country where DDP is not
   *        available, information may still come back as DDU. If not provided, Flow will
   *        set a base default based on the country
   * @param country When otherwise not known, the default country to use for this experience. One
   *        example would be an experience setup for Europe - when you request landed cost,
   *        if there is no geolocation information available, we will use this country as
   *        the basis for landed cost. ISO 3166 3 currency code as defined in
   *        https://api.flow.io/reference/countries
   * @param currency The default currency for this experience which will define the currency of the
   *        pricing for this experience as well as the default currency displayed when no
   *        other information is available. Value is an ISO 4217 3 currency code as defined
   *        in https://api.flow.io/reference/currencies
   * @param language The default language in which to display information for this experience, when
   *        no other information is present. Value is an ISO 639 2 language code as defined
   *        in https://api.flow.io/reference/languages
   * @param key The key to use for this experience. If not provided, we will generate a unique
   *        key based on the experience name.
   * @param position The order in which experiences will be displayed. Lower numbers will have
   *        priority. If not provided, an experience will either take the existing
   *        experience's position or default to the end of the list if an existing
   *        experience cannot be found
   * @param subcatalogId The Id of the subcatalog that will define the specific list of products to offer
   *        in this experience. If not specified, a new subcatalog will be created.
   */
  final case class ExperienceForm(
    regionId: String,
    name: String,
    deliveredDuty: _root_.scala.Option[io.flow.common.v0.models.DeliveredDuty] = None,
    country: _root_.scala.Option[String] = None,
    currency: _root_.scala.Option[String] = None,
    language: _root_.scala.Option[String] = None,
    key: _root_.scala.Option[String] = None,
    position: _root_.scala.Option[Long] = None,
    measurementSystem: _root_.scala.Option[io.flow.common.v0.models.MeasurementSystem] = None,
    subcatalogId: _root_.scala.Option[String] = None
  )

  /**
   * Experience Geo summarizes an experience along with geographic info
   *
   * @param region Reference to region as defined in https://api.flow.io/reference/regions
   * @param country ISO 3166 3 currency code as defined in https://api.flow.io/reference/countries
   * @param currency ISO 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   * @param language ISO 639 2 language code as defined in https://api.flow.io/reference/languages
   */
  final case class ExperienceGeo(
    key: String,
    name: String,
    region: io.flow.experience.v0.models.RegionReference,
    country: String,
    currency: String,
    language: String,
    measurementSystem: io.flow.common.v0.models.MeasurementSystem
  )

  final case class ExperienceLogisticsSettings(
    id: String,
    experience: io.flow.experience.v0.models.ExperienceOverview,
    shippingConfiguration: io.flow.fulfillment.v0.models.ShippingConfigurationReference
  )

  /**
   * Assigns logistics related settings to an experience
   */
  final case class ExperienceLogisticsSettingsPutForm(
    shippingConfigurationKey: String
  )

  final case class ExperienceLogisticsSummary(
    outbound: _root_.scala.Option[io.flow.experience.v0.models.ExperienceLogisticsTierSummary] = None,
    `return`: _root_.scala.Option[io.flow.experience.v0.models.ExperienceLogisticsTierSummary] = None
  )

  final case class ExperienceLogisticsTierSummary(
    prices: io.flow.experience.v0.models.ExperienceLogisticsTierSummaryPrices
  )

  /**
   * @param minimum Across all the tiers for this experience, returns the minimum tier shipping
   *        price.
   */
  final case class ExperienceLogisticsTierSummaryPrices(
    minimum: io.flow.common.v0.models.Price
  )

  final case class ExperienceOverview(
    id: String,
    key: String
  )

  final case class ExperiencePaymentMethodRule(
    experienceKey: String,
    paymentMethodRules: Seq[io.flow.experience.v0.models.PaymentMethodRule]
  )

  /**
   * @param paymentMethodId The id of a payment method.
   * @param tags A collection of active tags for this payment such as whether it is to be
   *        displayed at checkout.
   * @param q Query used to filter payment methods shown on the experience checkout. For
   *        example, only show PayPal for the canada experience when the order's destination
   *        is Canda and is below 1000 CAD
   */
  final case class ExperiencePaymentMethodRuleForm(
    paymentMethodId: String,
    tags: Seq[io.flow.experience.v0.models.ExperiencePaymentMethodTag],
    q: _root_.scala.Option[String] = None
  )

  /**
   * @param position Position of this experience price book mapping. Lower position indicates
   *        experience price book mapping should be considered first.
   */
  final case class ExperiencePriceBookMapping(
    id: String,
    experience: io.flow.experience.v0.models.ExperienceReference,
    priceBook: io.flow.price.v0.models.PriceBookReference,
    position: Long
  )

  /**
   * @param position Position of this experience price book mapping. Lower position indicates
   *        experience price book mapping should be considered first.
   */
  final case class ExperiencePriceBookMappingForm(
    priceBookKey: String,
    position: _root_.scala.Option[Long] = None
  )

  final case class ExperiencePriceBookMappingPutForm(
    priceBooks: Seq[io.flow.experience.v0.models.ExperiencePriceBookMappingForm]
  )

  final case class ExperiencePriceConversion(
    request: io.flow.experience.v0.models.ExperiencePriceConversionRequest,
    price: io.flow.common.v0.models.PriceWithBase
  )

  /**
   * @param base The requested base currency ISO code
   * @param local The requested local currency ISO code
   */
  final case class ExperiencePriceConversionRequest(
    value: BigDecimal,
    base: String,
    local: String
  )

  /**
   * Conversion of a price from the organization's base currency into a local
   * currency, using display rules suitable for price facets in search.
   */
  final case class ExperiencePriceConversionResponse(
    prices: Seq[io.flow.experience.v0.models.ExperiencePriceConversion]
  )

  final case class ExperiencePriceFacetConversion(
    request: io.flow.experience.v0.models.ExperiencePriceFacetConversionRequest,
    price: io.flow.common.v0.models.PriceWithBase
  )

  /**
   * @param base The requested base currency ISO code
   * @param local The requested local currency ISO code
   */
  final case class ExperiencePriceFacetConversionRequest(
    boundary: io.flow.experience.v0.models.PriceFacetBoundary,
    value: BigDecimal,
    base: String,
    local: String
  )

  /**
   * Conversion of a price from the organization's base currency into a local
   * currency, using display rules suitable for price facets in search.
   */
  final case class ExperiencePriceFacetConversionResponse(
    facets: Seq[io.flow.experience.v0.models.ExperiencePriceFacetConversion]
  )

  final case class ExperienceReference(
    override val key: String
  ) extends ExpandableExperience

  /**
   * @param deliveredDuty Wrapper for settings for delivered duties. This includes the default for the
   *        experience and the choices available for a customer to pick.
   * @param pricingSettings Wrapper for settings for pricing. This includes the defaults for the experience
   *        and whether they are editable.
   * @param logisticsSettings Wrapper for settings for logistics. This includes the shipping configuration key
   *        used by the experience.
   * @param checkoutSettings Wrapper for settings for Checkout UI.
   */
  final case class ExperienceSettings(
    deliveredDuty: io.flow.experience.v0.models.DeliveredDutySetting,
    pricingSettings: _root_.scala.Option[io.flow.experience.v0.models.PricingSettings] = None,
    logisticsSettings: _root_.scala.Option[io.flow.experience.v0.models.LogisticsSettings] = None,
    checkoutSettings: _root_.scala.Option[io.flow.experience.v0.models.ExperienceCheckoutConfigurationSettings] = None
  )

  /**
   * The experience status form is used to update the status of a particular
   * experience.
   */
  final case class ExperienceStatusForm(
    status: io.flow.experience.v0.models.ExperienceStatus
  )

  final case class ExperienceVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    experience: io.flow.experience.v0.models.Experience
  )

  /**
   * @param trigger Trigger used to calculate eligibility for free shipping, showing information
   *        necessary.
   * @param max Maximum value for this promotion. For example, a free shipping promo may be
   *        setup with a max of 10 CAD meaning we will apply free shipping up to a maximum
   *        value of 10 CAD
   */
  final case class FreeShipping(
    trigger: io.flow.experience.v0.models.PromotionTrigger,
    max: _root_.scala.Option[io.flow.common.v0.models.Price] = None
  ) extends Promotion

  /**
   * @param trigger Trigger used to calculate eligibility for free shipping, showing information
   *        necessary.
   * @param max Maximum value for this promotion. For example, a free shipping promo may be
   *        setup with a max of 10 CAD meaning we will apply free shipping up to a maximum
   *        value of 10 CAD
   * @param attributes A set of key/value pairs
   */
  final case class FreeShippingOrderPromotion(
    id: String,
    order: io.flow.experience.v0.models.ExpandableOrder,
    key: String,
    trigger: io.flow.experience.v0.models.OrderPromotionTrigger,
    max: _root_.scala.Option[io.flow.common.v0.models.Price] = None,
    attributes: Map[String, String]
  ) extends OrderPromotion

  /**
   * @param trigger Trigger used to calculate eligibility for free shipping, showing information
   *        necessary.
   * @param max Maximum value for this promotion. For example, a free shipping promo may be
   *        setup with a max of 10 CAD meaning we will apply free shipping up to a maximum
   *        value of 10 CAD.
   * @param attributes A set of key/value pairs
   */
  final case class FreeShippingOrderPromotionForm(
    trigger: io.flow.experience.v0.models.PromotionTriggerForm,
    max: _root_.scala.Option[io.flow.common.v0.models.PriceForm] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  ) extends OrderPromotionForm

  /**
   * Defines a fixed and percent margin to apply to items matching a query.
   *
   * @param q The query used to select items to which the margins are applied.
   * @param fixed A fixed amount to add to an item in the base currency, e.g 1.25.
   * @param percent A percent of the base cost to add, e.g. 2.25 would indicate 2.25%.
   */
  final case class ItemMargin(
    id: String,
    key: String,
    name: String,
    q: String,
    fixed: BigDecimal,
    percent: BigDecimal,
    position: Long,
    experience: _root_.scala.Option[io.flow.experience.v0.models.ExperienceReference] = None
  )

  /**
   * A percent and/or fixed margin to apply to items based on query.
   *
   * @param fixed A fixed amount to add to an item in the base currency, e.g 1.25.
   * @param percent A percent of the base cost to add, e.g. 2.25 would indicate 2.25%.
   * @param position Defaults to end of list
   */
  final case class ItemMarginPostForm(
    name: String,
    q: String,
    key: _root_.scala.Option[String] = None,
    fixed: _root_.scala.Option[BigDecimal] = None,
    percent: _root_.scala.Option[BigDecimal] = None,
    position: _root_.scala.Option[Long] = None
  )

  /**
   * A percent and/or fixed margin to apply to items based on query.
   *
   * @param fixed A fixed amount to add to an item in the base currency, e.g 1.25.
   * @param percent A percent of the base cost to add, e.g. 2.25 would indicate 2.25%.
   * @param position Defaults to end of list
   */
  final case class ItemMarginPutForm(
    name: String,
    q: String,
    fixed: _root_.scala.Option[BigDecimal] = None,
    percent: _root_.scala.Option[BigDecimal] = None,
    position: _root_.scala.Option[Long] = None
  )

  final case class ItemMarginVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    itemMargin: io.flow.experience.v0.models.ItemMargin
  )

  /**
   * Provides display data for a line item.
   *
   * @param id Unique identifier for this line. Introduced in Oct 2020 and thus optional.
   */
  final case class Line(
    id: _root_.scala.Option[String] = None,
    itemNumber: String,
    quantity: Long,
    price: io.flow.common.v0.models.PriceWithBase,
    total: io.flow.common.v0.models.PriceWithBase,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * Line items on the order, with localized pricing information
   *
   * @param id Unique identifier for this line. Introduced in Oct 2020 and thus optional.
   * @param name The item name associated to the number (e.g. Long Sleeve Dress).
   * @param center Optional center key associated with this item. Used for orders and quotes to
   *        specify where to ship an item from. If not specified, Flow will infer based on
   *        inventory setup.
   * @param price The price of this item for this order. If not specified, we will use the item
   *        price from the experience
   * @param discount The total discount, if any, to apply to this line item. Note that the discount
   *        is the total discount to apply regardless of the quantity.
   * @param discounts Discounts, if any, to apply to this line item. Note that the discounts apply to
   *        the total, regardless of the quantity.
   * @param attributes A set of key/value pairs that you can attach to the order. It can be useful for
   *        storing additional information about the charge in a structured format.
   * @param shipmentEstimate For items that may not immediately ship out from the origin because of different
   *        models of inventory (e.g. drop-ship, sell-first), this is a way for a client to
   *        communicate when the items can ship out. This will be used to calculate delivery
   *        option windows.
   * @param priceSource Indicates the source of the item price.
   */
  final case class LocalizedLineItem(
    id: _root_.scala.Option[String] = None,
    number: String,
    name: String,
    quantity: Long,
    center: _root_.scala.Option[String] = None,
    price: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    discount: _root_.scala.Option[io.flow.experience.v0.models.LocalizedLineItemDiscount] = None,
    discounts: _root_.scala.Option[Seq[io.flow.experience.v0.models.LocalizedLineItemDiscount]] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    local: io.flow.catalog.v0.models.Local,
    shipmentEstimate: _root_.scala.Option[io.flow.common.v0.models.DatetimeRange] = None,
    priceSource: _root_.scala.Option[io.flow.common.v0.models.PriceSource] = None
  )

  /**
   * Represents the requested, base, and localized amounts for a discount on a given
   * line item. It applies to the entire line regardless of quantity.
   *
   * @param amount The amount of the discount after being converted to the local currency.
   * @param currency ISO 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   * @param label The formatted label of the localized discount.
   * @param base The discount converted to the base currency in which your organization operates.
   * @param requested The requested discount amount.
   * @param discountLabel The discount pretty label (e.g. SPRING10) that is displayed to the customer.
   */
  final case class LocalizedLineItemDiscount(
    amount: Double,
    currency: String,
    label: _root_.scala.Option[String] = None,
    base: _root_.scala.Option[io.flow.common.v0.models.Price] = None,
    requested: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    discountLabel: _root_.scala.Option[String] = None
  )

  final case class LogisticsSettings(
    shippingConfiguration: io.flow.fulfillment.v0.models.ShippingConfigurationReference
  )

  /**
   * An order represents all of the information about a particular set of line items,
   * including pricing, currency rates, delivery options, etc. All information in an
   * order is guaranteed by Flow - if an order is submitted before its expiration.
   * The intended use case is to create an order as a consumer enters checkout, then
   * to submit that order as part of the user submitting their order. Note that Flow
   * will automatically mark an order submitted if we see payment authorization(s)
   * covering the full balance of an order.
   *
   * @param orderType Allowed values: standard or replacement
   * @param merchantOfRecord Once an order is fully paid, we record who the merchant of record for this order
   *        is.
   * @param experience Contains information on the experience on which this order was submitted.
   * @param customer The customer who is actually making the purchase
   * @param deliveredDuty Options returned will only use tiers with the matching delivered duty. This
   *        would also affect whether duties are included in the total or not. If not
   *        specified, defaults based on the experience default setting.
   * @param expiresAt The date and time on which this order will expire unless submitted. Used only
   *        when the order status is 'open'. New orders will expire 1 hour after creation.
   * @param selections The currently selected delivery option ids. These IDs represent the shipping
   *        tiers that the customer has chosen (e.g. standard or express) for each delivery.
   *        The shipping price is then based on these selections (and included in the prices
   *        array). You can update an order before it has been submitted to change the
   *        delivery options, getting back accurate pricing for the order.
   * @param attributes A set of key/value pairs that you can attach to the order. It can be useful for
   *        storing additional information about the charge in a structured format.
   * @param submittedAt The timestamp on which the order is submitted. Once submitted, production orders
   *        can no longer be deleted as they represent transactions in the real world
   * @param lines Provides display data for each of the line items belonging to this order.
   * @param identifiers Other identifiers which are used to identify this order, if available.
   * @param promotions The current available and applied promotions for this order
   * @param payments Represents the list of payments on an order. Each payment will be typed -
   *        supporting options like a $25 account credit applied to an order plus a balance
   *        paid by a card, paypal, cash on delivery, etc. The list of payments here is
   *        summary information only for display back to the user; each individual payment
   *        will have varying levels of detail based on the actual type of the payment
   * @param balance The remaining balance on this order. Will be marked required in a future version
   *        of the Flow API
   * @param rules Represents a summary of the rules related to this order.
   * @param taxRegistration Represents the tax registration on an order, if applicable.
   * @param geo If present, provides the geo ip related information for this order
   */
  final case class Order(
    override val id: String,
    override val number: String,
    orderType: io.flow.experience.v0.models.OrderType = io.flow.experience.v0.models.OrderType.Standard,
    merchantOfRecord: _root_.scala.Option[io.flow.common.v0.models.OrderMerchantOfRecord] = None,
    experience: _root_.scala.Option[io.flow.experience.v0.models.ExpandableExperience] = None,
    customer: io.flow.common.v0.models.OrderCustomer,
    deliveredDuty: io.flow.common.v0.models.DeliveredDuty,
    destination: io.flow.experience.v0.models.OrderAddress,
    expiresAt: _root_.org.joda.time.DateTime,
    items: Seq[io.flow.experience.v0.models.LocalizedLineItem],
    deliveries: Seq[io.flow.fulfillment.v0.models.Delivery],
    selections: Seq[String],
    prices: Seq[io.flow.order.price.v0.models.OrderPriceDetail],
    total: io.flow.catalog.v0.models.LocalizedTotal,
    attributes: Map[String, String],
    submittedAt: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    lines: _root_.scala.Option[Seq[io.flow.experience.v0.models.Line]] = None,
    identifiers: _root_.scala.Option[Seq[String]] = None,
    promotions: _root_.scala.Option[io.flow.experience.v0.models.Promotions] = None,
    payments: _root_.scala.Option[Seq[io.flow.experience.v0.models.OrderPayment]] = None,
    balance: _root_.scala.Option[io.flow.catalog.v0.models.LocalizedTotal] = None,
    rules: _root_.scala.Option[io.flow.experience.v0.models.OrderRulesSummary] = None,
    taxRegistration: _root_.scala.Option[io.flow.harmonization.v0.models.TaxRegistration] = None,
    geo: _root_.scala.Option[io.flow.experience.v0.models.OrderGeo] = None
  ) extends ExpandableOrder

  /**
   * @param text Full text version of address
   * @param streets Array for street line 1, street line 2, etc., in order
   * @param country The ISO 3166-3 country code. Case insensitive. See
   *        https://api.flow.io/reference/countries
   * @param contact Contact information of entity at the address
   */
  final case class OrderAddress(
    text: _root_.scala.Option[String] = None,
    streets: _root_.scala.Option[Seq[String]] = None,
    city: _root_.scala.Option[String] = None,
    province: _root_.scala.Option[String] = None,
    postal: _root_.scala.Option[String] = None,
    country: _root_.scala.Option[String] = None,
    latitude: _root_.scala.Option[String] = None,
    longitude: _root_.scala.Option[String] = None,
    contact: _root_.scala.Option[io.flow.common.v0.models.Contact] = None
  )

  /**
   * The Order Builder model is used to incrementally build up an order until it is
   * complete and can be submitted.
   *
   * @param order The order in its current state. Will always be present unless there is a global
   *        error (e.g. no experience defined) that makes it impossible to create an order
   * @param errors A list of order errors that must be resolved prior to submitted the order. If
   *        there are no errors in the model, than the order can be submitted.
   */
  final case class OrderBuilder(
    order: _root_.scala.Option[io.flow.experience.v0.models.Order] = None,
    errors: _root_.scala.Option[Seq[io.flow.experience.v0.models.OrderError]] = None
  )

  final case class OrderBuilderAttributesForm(
    attributes: Map[String, String]
  )

  /**
   * @param customer The customer who actually is making the purchase.
   */
  final case class OrderBuilderCustomerForm(
    customer: io.flow.common.v0.models.OrderCustomerForm
  )

  final case class OrderBuilderCustomerInvoiceAddressForm(
    address: io.flow.common.v0.models.BillingAddress
  )

  final case class OrderBuilderDeliveredDutyForm(
    deliveredDuty: io.flow.common.v0.models.DeliveredDuty
  )

  /**
   * @param country The ISO 3166-3 country code. Case insensitive. See
   *        https://api.flow.io/reference/countries
   */
  final case class OrderBuilderDestinationCountryForm(
    country: String
  )

  final case class OrderBuilderDestinationForm(
    destination: io.flow.experience.v0.models.OrderAddress
  )

  /**
   * @param selections Selected list of delivery options for this quote. The original order will
   *        contain one or more deliveries. Each delivery will contain one or more shipping
   *        options (e.g. standard or express).
   */
  final case class OrderBuilderSelectionsForm(
    selections: Seq[String]
  )

  /**
   * Purpose-built form specifically for only address-related changes to destination
   * on an order
   */
  final case class OrderDestinationPutForm(
    destination: io.flow.experience.v0.models.OrderAddress
  )

  /**
   * @param messages A summary of the errors
   * @param numbers A list of all of the item numbers that are not available
   * @param destinationCountry Destination country of the order, if available.
   * @param threshold When the order error is value_threshold_exceeded, we include the details on the
   *        threshold itself.
   */
  final case class OrderError(
    code: io.flow.experience.v0.models.OrderErrorCode,
    messages: Seq[String],
    numbers: _root_.scala.Option[Seq[String]] = None,
    destinationCountry: _root_.scala.Option[io.flow.reference.v0.models.Country] = None,
    threshold: _root_.scala.Option[io.flow.experience.v0.models.ValueThresholdExceededDetails] = None
  )

  /**
   * Lightweight estimate for a group of items without any customer-related
   * information. This will contain available estimates on shipping, taxes, and
   * duties.
   *
   * @param selections The currently selected delivery option ids. These IDs represent the shipping
   *        tiers that the customer has chosen (e.g. standard or express) for each delivery.
   *        The shipping price is then based on these selections (and included in the prices
   *        array). You can update an order before it has been submitted to change the
   *        delivery options, getting back accurate pricing for the order.
   * @param lines Provides display data for each of the line items belonging to this order
   *        estimate.
   * @param promotions The current available and applied promotions for this order
   */
  @deprecated("Estimates are deprecated. Please use orders with optional destination")
  final case class OrderEstimate(
    id: String,
    items: Seq[io.flow.experience.v0.models.LocalizedLineItem],
    destination: io.flow.experience.v0.models.OrderAddress,
    deliveries: Seq[io.flow.fulfillment.v0.models.Delivery],
    prices: Seq[io.flow.order.price.v0.models.OrderPriceDetail],
    selections: Seq[String],
    total: io.flow.catalog.v0.models.LocalizedTotal,
    lines: _root_.scala.Option[Seq[io.flow.experience.v0.models.Line]] = None,
    promotions: _root_.scala.Option[io.flow.experience.v0.models.Promotions] = None
  )

  /**
   * Form to get a lightweight estimate of an order.
   *
   * @param selections Selected list of delivery options for this quote. The original order will
   *        contain one or more deliveries. Each delivery will contain one or more shipping
   *        options (e.g. standard or express). We need to know which shipping options the
   *        user selected in order to provide accurate, local shipping pricing. You should
   *        only specify if you are explicitly changing the delivery options
   */
  @deprecated("Estimates are deprecated. Please use orders with optional destination")
  final case class OrderEstimateForm(
    items: Seq[io.flow.common.v0.models.LineItemForm],
    destination: _root_.scala.Option[io.flow.experience.v0.models.OrderAddress] = None,
    selections: _root_.scala.Option[Seq[String]] = None
  )

  /**
   * The order form is used to create an open order, providing the details on pricing
   * and delivery options for destination and items/quantities specified
   *
   * @param customer The customer who actually is making the purchase. We recommend providing as much
   *        information as you have, notably email address which can be used to increase
   *        acceptance rates if Flow is processing payment for this order. If you can also
   *        provide your customer number - we can link multiple orders for each customer in
   *        the Flow console.
   * @param deliveredDuty Options returned will only use tiers with the matching delivered duty. This
   *        would also affect whether duties are included in the total or not. If not
   *        specified, defaults based on the experience default setting.
   * @param number If not provided, will default to the generated unique order identifier.
   * @param discount An optional discount to apply to the entire order
   * @param discounts Optional discount(s) to apply to the entire order.
   * @param attributes A set of key/value pairs that you can attach to the order. It can be useful for
   *        storing additional information about the charge in a structured format.
   * @param authorizationKeys Sets the authorization keys to associate with this order. Each authorization, if
   *        valid, will then be added to the order.payments field.
   * @param options Optional behaviors to enable for this order
   */
  final case class OrderForm(
    customer: _root_.scala.Option[io.flow.common.v0.models.OrderCustomerForm] = None,
    items: Seq[io.flow.common.v0.models.LineItemForm],
    deliveredDuty: _root_.scala.Option[io.flow.common.v0.models.DeliveredDuty] = None,
    number: _root_.scala.Option[String] = None,
    destination: _root_.scala.Option[io.flow.experience.v0.models.OrderAddress] = None,
    discount: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    discounts: _root_.scala.Option[io.flow.common.v0.models.DiscountsForm] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    authorizationKeys: _root_.scala.Option[Seq[String]] = None,
    options: _root_.scala.Option[io.flow.experience.v0.models.OrderOptions] = None
  )

  /**
   * The geolocated information for an order
   *
   * @param country ISO 3166 3 currency code as defined in https://api.flow.io/reference/countries
   * @param currency ISO 4217 3 currency code as defined in https://api.flow.io/reference/currencies
   * @param language ISO 639 2 language code as defined in https://api.flow.io/reference/languages
   */
  final case class OrderGeo(
    ip: _root_.scala.Option[String] = None,
    country: String,
    currency: _root_.scala.Option[String] = None,
    language: _root_.scala.Option[String] = None
  )

  /**
   * Represents alternate identifiers that can be used to lookup an order. Common use
   * cases are to support attaching a primary identifier (e.g. a nice order number)
   * post order submission or attaching IDs that are used by the warehouse to ship
   * the orders.
   *
   * @param name The name of the identifier is used to identify where this identifier was set. It
   *        is informational only
   * @param primary An order can optionally have a single additional primary identifier. Common
   *        pattern here is using a random UUID in checkout sessions, then later assigning a
   *        human readable order number.
   */
  final case class OrderIdentifier(
    id: String,
    order: io.flow.experience.v0.models.OrderReference,
    name: String = "external",
    identifier: String,
    primary: Boolean,
    @deprecated("This field was renamed to 'identifier'") number: _root_.scala.Option[String] = None
  )

  /**
   * @param order The order number for which you are assigning this identifier
   * @param name The name of the identifier is used to identify where this identifier was set. It
   *        is informational only
   * @param primary If you set this to true, creates the order identifier and marks it as primary.
   *        If there already exists a prior primary identifier, that identifier will be
   *        updated to no longer by the primary
   */
  final case class OrderIdentifierForm(
    order: String,
    name: _root_.scala.Option[String] = None,
    identifier: _root_.scala.Option[String] = None,
    @deprecated("This field is deprecated. Please use the 'identifier' field") number: _root_.scala.Option[String] = None,
    primary: _root_.scala.Option[Boolean] = None
  )

  /**
   * @param order The order number for which you are assigning this identifier
   * @param name The name of the identifier is used to identify where this identifier was set. It
   *        is informational only
   * @param primary If you set this to true, creates the order identifier and marks it as primary.
   *        If there already exists a prior primary identifier, that identifier will be
   *        updated to no longer by the primary
   */
  final case class OrderIdentifierPutForm(
    order: String,
    name: _root_.scala.Option[String] = None,
    primary: _root_.scala.Option[Boolean] = None
  )

  final case class OrderIdentifierVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    orderIdentifier: io.flow.experience.v0.models.OrderIdentifier
  )

  final case class OrderNumberGeneratorDefaults(
    startsWith: Long = 1001L,
    minHexLength: Int = 6,
    minStartsWith: Long = 1L
  )

  final case class OrderNumberGeneratorFixedLength(
    length: Int,
    padding: String
  )

  /**
   * @param number Generated order number having used an organization's order number generator
   */
  final case class OrderNumberGeneratorGeneratedNumber(
    number: String
  )

  /**
   * Hexadecimal generator generates a random string, starting with a letter, of a
   * given length
   */
  final case class OrderNumberGeneratorHexadecimal(
    length: Int
  ) extends OrderNumberGenerator

  /**
   * Generator with an optional prefix, followed by an integer and an optional suffix
   *
   * @param fixedLength Optionally force a fixed length with padding. For example, an order number of
   *        F1234 with fixed length '6' and padding '0' would become 'F01234'
   */
  final case class OrderNumberGeneratorPrefixSuffix(
    prefix: _root_.scala.Option[String] = None,
    startsWith: _root_.scala.Option[Long] = None,
    suffix: _root_.scala.Option[String] = None,
    fixedLength: _root_.scala.Option[io.flow.experience.v0.models.OrderNumberGeneratorFixedLength] = None
  ) extends OrderNumberGenerator

  /**
   * Generates an order number based on a UUID (no dashes or other formatting). This
   * is the default for Flow orders (with order number prefixed by ord-)
   *
   * @param prefix Optional prefix to prepend to the UUID
   */
  final case class OrderNumberGeneratorUuid(
    prefix: String = "ord-"
  ) extends OrderNumberGenerator

  final case class OrderNumberReference(
    number: String
  )

  /**
   * Optional behaviors to enable for this order
   */
  final case class OrderOptions(
    storage: io.flow.experience.v0.models.OrderStorage = io.flow.experience.v0.models.OrderStorage.Persist
  )

  /**
   * An Order Payment represents an individual payment applied to an order. The type
   * of the payment can be used to further lookup transaction level detail
   *
   * @param reference The reference identifier for the details behind this order payment. For example,
   *        if this payment was a card payment, the reference will be the unique
   *        authorization key.
   * @param description Human understandable description of this payment method
   * @param address Billing address associated with this payment
   * @param attributes Integration-specific attributes of this payment.
   * @param method The 'id' of the payment method. See
   *        https://api.flow.io/reference/payment/methods
   */
  final case class OrderPayment(
    id: String,
    `type`: io.flow.experience.v0.models.OrderPaymentType,
    merchantOfRecord: io.flow.common.v0.models.MerchantOfRecord = io.flow.common.v0.models.MerchantOfRecord.Flow,
    reference: String,
    description: String,
    total: io.flow.common.v0.models.PriceWithBase,
    address: _root_.scala.Option[io.flow.common.v0.models.BillingAddress] = None,
    date: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    attributes: Map[String, String] = Map.empty,
    method: _root_.scala.Option[String] = None
  )

  /**
   * @param min Minimum amount to be eligible for the trigger
   */
  final case class OrderPromotionTrigger(
    `type`: io.flow.experience.v0.models.PromotionTriggerType,
    min: _root_.scala.Option[io.flow.common.v0.models.Price] = None
  )

  /**
   * The order put form is used to upsert an order, providing the details on pricing
   * and delivery options for destination and items/quantities specified.
   *
   * @param customer The customer who actually is making the purchase. We recommend providing as much
   *        information as you have, notably email address which can be used to increase
   *        acceptance rates if Flow is processing payment for this order. If you can also
   *        provide your customer number - we can link multiple orders for each customer in
   *        the Flow console.
   * @param deliveredDuty Options returned will only use tiers with the matching delivered duty. This
   *        would also affect whether duties are included in the total or not. If not
   *        specified, defaults based on the experience default setting.
   * @param selections Selected list of delivery options for this quote. The original order will
   *        contain one or more deliveries. Each delivery will contain one or more shipping
   *        options (e.g. standard or express). We need to know which shipping options the
   *        user selected in order to provide accurate, local shipping pricing. You should
   *        only specify if you are explicitly changing the delivery options
   * @param discount An optional discount to apply to the entire order
   * @param discounts Optional discount(s) to apply to the entire order.
   * @param attributes A set of key/value pairs that you can attach to the order. It can be useful for
   *        storing additional information about the charge in a structured format.
   * @param authorizationKeys Sets the authorization keys to associate with this order. Each authorization, if
   *        valid, will then be added to the order.payments field.
   * @param options Optional behaviors to enable for this order
   */
  final case class OrderPutForm(
    orderType: io.flow.experience.v0.models.OrderType = io.flow.experience.v0.models.OrderType.Standard,
    items: Seq[io.flow.common.v0.models.LineItemForm],
    customer: _root_.scala.Option[io.flow.common.v0.models.OrderCustomerForm] = None,
    deliveredDuty: _root_.scala.Option[io.flow.common.v0.models.DeliveredDuty] = None,
    selections: _root_.scala.Option[Seq[String]] = None,
    destination: _root_.scala.Option[io.flow.experience.v0.models.OrderAddress] = None,
    discount: _root_.scala.Option[io.flow.common.v0.models.Money] = None,
    discounts: _root_.scala.Option[io.flow.common.v0.models.DiscountsForm] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    authorizationKeys: _root_.scala.Option[Seq[String]] = None,
    options: _root_.scala.Option[io.flow.experience.v0.models.OrderOptions] = None
  )

  final case class OrderReference(
    override val id: String,
    override val number: String
  ) extends ExpandableOrder

  /**
   * For merchant of record authorizations, we provide a summary of refund
   * information primarily to support customer service workflow.
   *
   * @param currency The ISO 4217-3 code for the currency. Case insensitive. See
   *        https://api.flow.io/reference/currencies
   * @param amounts Suggested amounts to refund based on the most common use cases
   */
  final case class OrderRefundSummary(
    currency: String,
    amounts: io.flow.experience.v0.models.OrderRefundSummaryAmounts
  )

  /**
   * Detailed examples of amount to refund following common e-commerce use cases.
   *
   * @param balance The total amount of funds available to refund (sum of all captures minus all
   *        prior refunds).
   * @param itemSubtotal The item subtotal which is the sum of all subtotals for each item.
   * @param discount The discount, if any, that was applied on all items that are being refunded.
   *        This discount will be subtracted from the refund total.
   * @param refundTotal The refund total (sum of all prices of items that are being refunded and any
   *        options that are included such as vat, duties and/or shipping).
   * @param shipping The total amount of shipping on the order, if there was a shipping fee. We
   *        highlight this value separately to simplify use cases where a full refund minus
   *        shipping is used.
   * @param vat The total amount of vat on the order.
   * @param duty The total amount of duties on the order.
   */
  final case class OrderRefundSummaryAmounts(
    balance: BigDecimal,
    itemSubtotal: BigDecimal,
    discount: _root_.scala.Option[BigDecimal] = None,
    refundTotal: BigDecimal,
    shipping: BigDecimal,
    vat: BigDecimal,
    duty: BigDecimal
  )

  final case class OrderRefundSummaryFullForm(
    includes: Seq[io.flow.experience.v0.models.OrderRefundSummaryIncludes]
  ) extends OrderRefundSummaryForm

  final case class OrderRefundSummaryItem(
    number: String,
    quantityToRefund: Long
  )

  final case class OrderRefundSummaryPartialForm(
    includes: Seq[io.flow.experience.v0.models.OrderRefundSummaryPartialIncludes],
    items: Seq[io.flow.experience.v0.models.OrderRefundSummaryItem]
  ) extends OrderRefundSummaryForm

  final case class OrderRefundSummaryPartialIncludes(
    key: io.flow.experience.v0.models.OrderRefundSummaryIncludes,
    charged: io.flow.experience.v0.models.OrderRefundSummaryPartialCharged
  )

  /**
   * The order replacement details.
   *
   * @param parentOrder The parent order.
   * @param replacementOrder The replacement order.
   */
  final case class OrderReplacement(
    id: String,
    parentOrder: io.flow.experience.v0.models.Order,
    replacementOrder: io.flow.experience.v0.models.Order
  )

  /**
   * The order replacement form is used to create a replacement order.
   *
   * @param items If this is present, replace the items listed. If not present, then default to
   *        the original orders items.
   */
  final case class OrderReplacementForm(
    items: _root_.scala.Option[Seq[io.flow.common.v0.models.LineItemForm]] = None
  )

  final case class OrderRuleReference(
    id: String,
    key: String
  )

  final case class OrderRulesSummary(
    applied: Seq[io.flow.experience.v0.models.OrderRuleReference]
  )

  /**
   * Manual change for a shipping method used for an order. Currently only available
   * to orders with a single calculated delivery.
   */
  final case class OrderServiceChange(
    id: String,
    from: io.flow.reference.v0.models.CarrierService,
    to: io.flow.reference.v0.models.CarrierService
  )

  /**
   * Manual change for a shipping method used for an order. Currently only available
   * to orders with a single calculated delivery. To help with orders with multiple
   * deliveries, we will require verification of both the current service level
   * (from) and the new service level (to).
   *
   * @param fromServiceId Valid carrier service level ID of the order delivery to be changed.
   * @param toServiceId Valid carrier service level ID to use for the delivery.
   */
  final case class OrderServiceChangeForm(
    fromServiceId: String,
    toServiceId: String
  )

  final case class OrderServiceChangeRequestData(
    id: String,
    sourceUrl: String,
    filename: _root_.scala.Option[String] = None
  )

  /**
   * Optional data to be processed during order submission
   *
   * @param identifiers An optional list of order identifiers to associate with the order.
   */
  final case class OrderSubmissionForm(
    identifiers: Seq[io.flow.experience.v0.models.OrderSubmissionIdentifierForm] = Nil
  )

  /**
   * Defines the data needed to attach an identifier to each order created by a
   * checkout.
   *
   * @param name The name of the identifier is used to identify where this identifier was set. It
   *        is informational only
   * @param primary If you set this to true, creates the order identifier and marks it as primary.
   *        If there already exists a prior primary identifier, that identifier will be
   *        updated to no longer by the primary
   */
  final case class OrderSubmissionIdentifierForm(
    identifier: String,
    name: _root_.scala.Option[String] = None,
    primary: _root_.scala.Option[Boolean] = None
  )

  /**
   * The order summary is a view of the order summary object with the order prices
   * flattened to keys.
   *
   * @param number The order number
   * @param identifiers The identifiers object is a map where the key will be the name of the identifier
   *        and the value is the identifier itself. For example, if you have an identifer
   *        named external_id, you will have an object here with a key named external_id
   * @param attributes Returns a list of order attributes
   */
  final case class OrderSummary(
    number: String,
    subtotal: io.flow.experience.v0.models.OrderSummaryPriceDetail,
    shipping: _root_.scala.Option[io.flow.experience.v0.models.OrderSummaryPriceDetail] = None,
    tax: _root_.scala.Option[io.flow.experience.v0.models.OrderSummaryPriceDetail] = None,
    duty: _root_.scala.Option[io.flow.experience.v0.models.OrderSummaryPriceDetail] = None,
    insurance: _root_.scala.Option[io.flow.experience.v0.models.OrderSummaryPriceDetail] = None,
    discount: _root_.scala.Option[io.flow.experience.v0.models.OrderSummaryPriceDetail] = None,
    surcharges: _root_.scala.Option[io.flow.experience.v0.models.OrderSummaryPriceDetail] = None,
    adjustment: _root_.scala.Option[io.flow.experience.v0.models.OrderSummaryPriceDetail] = None,
    total: io.flow.experience.v0.models.OrderSummaryPriceDetail,
    lines: Seq[io.flow.experience.v0.models.OrderSummaryLineItem],
    identifiers: _root_.scala.Option[Map[String, String]] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * @param url The full URL to the image
   */
  final case class OrderSummaryImage(
    url: String
  )

  /**
   * @param attributes Returns a list of item attributes w/ intent 'checkout_content'
   * @param image Provides the primary image to use in checkout. This image will be selected by
   *        finding the item image with tag 'checkout', defaulting to another available
   *        image if there is one.
   * @param priceAttributes All attributes with intent price as keys of this map - with each of those
   *        attributes mapped to its value in the local currency. For example, given an
   *        attribute named 'msrp' with intent 'price', this map will contain a key named
   *        'msrp'
   */
  final case class OrderSummaryItem(
    number: String,
    name: String,
    description: _root_.scala.Option[String] = None,
    attributes: Seq[io.flow.experience.v0.models.CheckoutItemContentAttribute],
    image: _root_.scala.Option[io.flow.experience.v0.models.OrderSummaryImage] = None,
    price: io.flow.common.v0.models.Price,
    discount: _root_.scala.Option[io.flow.common.v0.models.Price] = None,
    tax: _root_.scala.Option[io.flow.experience.v0.models.OrderSummaryLevy] = None,
    duty: _root_.scala.Option[io.flow.experience.v0.models.OrderSummaryLevy] = None,
    priceAttributes: Map[String, io.flow.common.v0.models.Price]
  )

  /**
   * @param rateLabel Optional rate label for this order price detail if the key relates to a VAT or
   *        Duty in the format XX.XXX%
   */
  final case class OrderSummaryLevy(
    rate: BigDecimal,
    rateLabel: _root_.scala.Option[String] = None,
    value: io.flow.common.v0.models.Price
  )

  /**
   * @param id Unique identifier for this line. Introduced in Oct 2020 and thus optional.
   * @param total The total price of quantity 1 of the item in this line. Computed as price -
   *        discount + tax + duty
   * @param priceAttributes All attributes with intent price as keys of this map - with each of those
   *        attributes mapped to its value in the local currency. For example, given an
   *        attribute named 'msrp' with intent 'price', this map will contain a key named
   *        'msrp' which represents the line total of the msrp (e.g. item msrp * quantity)
   * @param attributes Returns a list of line item attributes
   */
  final case class OrderSummaryLineItem(
    id: _root_.scala.Option[String] = None,
    item: io.flow.experience.v0.models.OrderSummaryItem,
    quantity: Long,
    discount: _root_.scala.Option[io.flow.common.v0.models.Price] = None,
    tax: _root_.scala.Option[io.flow.experience.v0.models.OrderSummaryLevy] = None,
    duty: _root_.scala.Option[io.flow.experience.v0.models.OrderSummaryLevy] = None,
    total: io.flow.common.v0.models.Price,
    priceAttributes: Map[String, io.flow.common.v0.models.Price],
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * Summaries the io.flow.order.price.v0.models.order_price_detail, removing
   * components and accuracy which are not needed for summary views
   *
   * @param price The key indicating what this price detail represents.
   * @param name The display name for this order price detail if appropriate.
   * @param rate Optional rate for this order price detail if the key relates to a tax or Duty.
   * @param rateLabel Optional rate label for this order price detail if the key relates to a VAT or
   *        Duty in the format XX.XXX%
   */
  final case class OrderSummaryPriceDetail(
    price: io.flow.common.v0.models.Price,
    name: _root_.scala.Option[String] = None,
    rate: _root_.scala.Option[BigDecimal] = None,
    rateLabel: _root_.scala.Option[String] = None
  )

  final case class OrderVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    order: io.flow.experience.v0.models.Order
  )

  /**
   * @param discounts A list of discount codes to apply to the order.
   */
  final case class OrderWithDiscountsForm(
    order: io.flow.experience.v0.models.OrderForm,
    discounts: Seq[String] = Nil
  )

  /**
   * Model representing original and max values and currencies.
   */
  final case class OriginalPrices(
    value: io.flow.common.v0.models.Price,
    max: io.flow.common.v0.models.Price
  )

  final case class PaymentMethodIssuer(
    id: String,
    name: String
  )

  /**
   * @param tags A collection of active tags for this payment such as whether it is denied for an
   *        organization or to be displayed at checkout.
   * @param paymentMethod The payment method associated with this rule.
   * @param displayPosition The order in which payment methods will be displayed. Lower numbers will have
   *        priority.
   * @param content Contains content necessary to render the given payment method, such as
   *        instructions that explain how to pay.
   * @param issuers Certain payment methods, such as iDEAL, require the customer to select an
   *        issuing bank before they are redirected to submit payment details. If any
   *        issuers are present in this field, the customer must select one which will then
   *        be included in the call to get the redirect URL.
   * @param programs Deprecated - will always be provided and empty. Will be removed shortly.
   * @param q Query used to filter payment methods shown on the experience checkout. For
   *        example, only show PayPal for the canada experience when the order's destination
   *        is Canda and is below 1000 CAD
   */
  final case class PaymentMethodRule(
    tags: Seq[io.flow.experience.v0.models.PaymentMethodTag],
    paymentMethod: io.flow.reference.v0.models.PaymentMethod,
    displayPosition: Int,
    content: _root_.scala.Option[Seq[io.flow.experience.v0.models.PaymentMethodRuleContent]] = None,
    issuers: _root_.scala.Option[Seq[io.flow.experience.v0.models.PaymentMethodIssuer]] = None,
    programs: _root_.scala.Option[Seq[_root_.play.api.libs.json.JsObject]] = None,
    q: _root_.scala.Option[io.flow.query.builder.v0.models.Query] = None
  )

  /**
   * @param key The key identifying the value of this content.
   * @param value The value of this content.
   */
  final case class PaymentMethodRuleContent(
    key: io.flow.experience.v0.models.PaymentMethodRuleContentKey,
    value: String
  )

  /**
   * @param editable Indicates whether the pricing display settings may be edited.
   * @param defaultTaxDisplay Default tax display setting.
   * @param defaultDutyDisplay Default duty display setting.
   */
  final case class PricingSettings(
    editable: Boolean,
    defaultTaxDisplay: io.flow.price.v0.models.PricingLevySetting,
    defaultDutyDisplay: io.flow.price.v0.models.PricingLevySetting
  )

  final case class PricingVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.common.v0.models.ChangeType,
    pricing: io.flow.price.v0.models.Pricing
  )

  /**
   * @param min Minimum amount to be eligible for the trigger
   * @param remaining Remaining value necessary to apply the trigger
   */
  final case class PromotionTrigger(
    `type`: io.flow.experience.v0.models.PromotionTriggerType,
    min: io.flow.common.v0.models.Price,
    remaining: io.flow.common.v0.models.Price
  )

  /**
   * @param min Minimum amount to be eligible for the trigger
   */
  final case class PromotionTriggerForm(
    `type`: io.flow.experience.v0.models.PromotionTriggerType,
    min: _root_.scala.Option[io.flow.common.v0.models.PriceForm] = None
  )

  /**
   * @param applied List of promotions that have been applied to this order. For example, free
   *        shipping promotion is applied to the shipping price.
   * @param available List of available promotions that are applicable for this order. If a promotion
   *        is here, the promo is not yet applied to the order, but the order can become
   *        eligible for it given some criteria.
   */
  final case class Promotions(
    applied: Seq[io.flow.experience.v0.models.Promotion],
    available: Seq[io.flow.experience.v0.models.Promotion]
  )

  final case class RegionReference(
    id: String
  )

  /**
   * @param local The actual limit in the local currency of the order
   * @param original The actual limit in the original currency in which the rule was defined. For
   *        example, Canada may restrict exports over CA$2000 - this value would be set to
   *        2000
   */
  final case class ValueThresholdExceededDetails(
    local: io.flow.common.v0.models.Price,
    original: io.flow.common.v0.models.Price
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union AllocationComponent, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class AllocationComponentUndefinedType(
    description: String
  ) extends AllocationComponent {
    override def key: io.flow.order.price.v0.models.OrderPriceDetailComponentKey = ???
    override def total: io.flow.common.v0.models.PriceWithBase = ???
    override def price: _root_.scala.Option[io.flow.common.v0.models.PriceWithBase] = ???
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union AllocationDetail, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class AllocationDetailUndefinedType(
    description: String
  ) extends AllocationDetail {
    override def key: io.flow.order.price.v0.models.OrderPriceDetailKey = ???
    override def total: io.flow.common.v0.models.PriceWithBase = ???
    override def included: Seq[io.flow.experience.v0.models.AllocationComponent] = ???
    override def notIncluded: Seq[io.flow.experience.v0.models.AllocationComponent] = ???
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union DiscountRuleEntitlement, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class DiscountRuleEntitlementUndefinedType(
    description: String
  ) extends DiscountRuleEntitlement

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableExperience, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class ExpandableExperienceUndefinedType(
    description: String
  ) extends ExpandableExperience {
    override def key: String = ???
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableOrder, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class ExpandableOrderUndefinedType(
    description: String
  ) extends ExpandableOrder {
    override def id: String = ???
    override def number: String = ???
  }

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union OrderNumberGenerator, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class OrderNumberGeneratorUndefinedType(
    description: String
  ) extends OrderNumberGenerator

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union OrderPromotion, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class OrderPromotionUndefinedType(
    description: String
  ) extends OrderPromotion

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union OrderPromotionForm, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class OrderPromotionFormUndefinedType(
    description: String
  ) extends OrderPromotionForm

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union OrderRefundSummaryForm, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class OrderRefundSummaryFormUndefinedType(
    description: String
  ) extends OrderRefundSummaryForm

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union PaymentMethodTag, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class PaymentMethodTagUndefinedType(
    description: String
  ) extends PaymentMethodTag

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union Promotion, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   *
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class PromotionUndefinedType(
    description: String
  ) extends Promotion
  /**
   * Address field names refer to those applicable on a customer entered destination
   * address
   */
  sealed trait AddressFieldName extends _root_.scala.Product with _root_.scala.Serializable

  object AddressFieldName {

    case object FirstName extends AddressFieldName { override def toString = "first_name" }
    case object LastName extends AddressFieldName { override def toString = "last_name" }
    case object Street1 extends AddressFieldName { override def toString = "street_1" }
    case object Street2 extends AddressFieldName { override def toString = "street_2" }
    case object City extends AddressFieldName { override def toString = "city" }
    case object Province extends AddressFieldName { override def toString = "province" }
    case object Postal extends AddressFieldName { override def toString = "postal" }
    case object Country extends AddressFieldName { override def toString = "country" }
    case object Phone extends AddressFieldName { override def toString = "phone" }
    case object Company extends AddressFieldName { override def toString = "company" }
    case object VatRegistrationNumber extends AddressFieldName { override def toString = "vat_registration_number" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends AddressFieldName

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AddressFieldName] = scala.List(FirstName, LastName, Street1, Street2, City, Province, Postal, Country, Phone, Company, VatRegistrationNumber)

    private[this]
    val byName: Map[String, AddressFieldName] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AddressFieldName = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AddressFieldName] = byName.get(value.toLowerCase)

  }

  sealed trait CreditPaymentErrorCode extends _root_.scala.Product with _root_.scala.Serializable

  object CreditPaymentErrorCode {

    case object GenericError extends CreditPaymentErrorCode { override def toString = "generic_error" }
    /**
     * Indicates the specified order does not exist
     */
    case object InvalidOrderNumber extends CreditPaymentErrorCode { override def toString = "invalid_order_number" }
    /**
     * Indicates that the specified currency code is not valid
     */
    case object InvalidCurrency extends CreditPaymentErrorCode { override def toString = "invalid_currency" }
    /**
     * Indicates that the description is invalid (must be non-empty)
     */
    case object InvalidDescription extends CreditPaymentErrorCode { override def toString = "invalid_description" }
    /**
     * Indicates that a credit payment with the specified key already exists
     */
    case object Duplicate extends CreditPaymentErrorCode { override def toString = "duplicate" }
    /**
     * Indicates the provided credit amount was <= 0
     */
    case object AmountMustBePositive extends CreditPaymentErrorCode { override def toString = "amount_must_be_positive" }
    /**
     * Indicates the provided credit amount exceeds the remaining balance on the order
     */
    case object AmountExceedsBalance extends CreditPaymentErrorCode { override def toString = "amount_exceeds_balance" }
    /**
     * Indicates the provided credit amount exceeds the maximum amount of applicable
     * credit
     */
    case object InsufficientAmount extends CreditPaymentErrorCode { override def toString = "insufficient_amount" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends CreditPaymentErrorCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[CreditPaymentErrorCode] = scala.List(GenericError, InvalidOrderNumber, InvalidCurrency, InvalidDescription, Duplicate, AmountMustBePositive, AmountExceedsBalance, InsufficientAmount)

    private[this]
    val byName: Map[String, CreditPaymentErrorCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CreditPaymentErrorCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CreditPaymentErrorCode] = byName.get(value.toLowerCase)

  }

  sealed trait DeliveredDutyDisplayType extends _root_.scala.Product with _root_.scala.Serializable

  object DeliveredDutyDisplayType {

    /**
     * Displays all available options to the customer.
     */
    case object All extends DeliveredDutyDisplayType { override def toString = "all" }
    /**
     * Displays a single option (either DDU or DDP), while the other can be displayed
     * by changing duties and tax preferences at checkout.
     */
    case object Single extends DeliveredDutyDisplayType { override def toString = "single" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends DeliveredDutyDisplayType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[DeliveredDutyDisplayType] = scala.List(All, Single)

    private[this]
    val byName: Map[String, DeliveredDutyDisplayType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DeliveredDutyDisplayType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DeliveredDutyDisplayType] = byName.get(value.toLowerCase)

  }

  sealed trait DiscountRuleStatus extends _root_.scala.Product with _root_.scala.Serializable

  object DiscountRuleStatus {

    case object Active extends DiscountRuleStatus { override def toString = "active" }
    case object Scheduled extends DiscountRuleStatus { override def toString = "scheduled" }
    case object Expired extends DiscountRuleStatus { override def toString = "expired" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends DiscountRuleStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[DiscountRuleStatus] = scala.List(Active, Scheduled, Expired)

    private[this]
    val byName: Map[String, DiscountRuleStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DiscountRuleStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DiscountRuleStatus] = byName.get(value.toLowerCase)

  }

  sealed trait DiscountRuleSubsidyTarget extends _root_.scala.Product with _root_.scala.Serializable

  object DiscountRuleSubsidyTarget {

    /**
     * VAT subsidy
     */
    case object Vat extends DiscountRuleSubsidyTarget { override def toString = "vat" }
    /**
     * Duty subsidy
     */
    case object Duty extends DiscountRuleSubsidyTarget { override def toString = "duty" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends DiscountRuleSubsidyTarget

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[DiscountRuleSubsidyTarget] = scala.List(Vat, Duty)

    private[this]
    val byName: Map[String, DiscountRuleSubsidyTarget] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DiscountRuleSubsidyTarget = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DiscountRuleSubsidyTarget] = byName.get(value.toLowerCase)

  }

  sealed trait ExperienceCloneStatus extends _root_.scala.Product with _root_.scala.Serializable

  object ExperienceCloneStatus {

    case object Pending extends ExperienceCloneStatus { override def toString = "pending" }
    case object Updating extends ExperienceCloneStatus { override def toString = "updating" }
    case object Completed extends ExperienceCloneStatus { override def toString = "completed" }
    case object Failed extends ExperienceCloneStatus { override def toString = "failed" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ExperienceCloneStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ExperienceCloneStatus] = scala.List(Pending, Updating, Completed, Failed)

    private[this]
    val byName: Map[String, ExperienceCloneStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExperienceCloneStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExperienceCloneStatus] = byName.get(value.toLowerCase)

  }

  sealed trait ExperienceCountryStatus extends _root_.scala.Product with _root_.scala.Serializable

  object ExperienceCountryStatus {

    case object Enabled extends ExperienceCountryStatus { override def toString = "enabled" }
    case object Disabled extends ExperienceCountryStatus { override def toString = "disabled" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ExperienceCountryStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ExperienceCountryStatus] = scala.List(Enabled, Disabled)

    private[this]
    val byName: Map[String, ExperienceCountryStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExperienceCountryStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExperienceCountryStatus] = byName.get(value.toLowerCase)

  }

  sealed trait ExperiencePaymentMethodTag extends PaymentMethodTag

  object ExperiencePaymentMethodTag {

    /**
     * A displayed payment method will be highlighted during the checkout process for
     * an experience.
     */
    case object Display extends ExperiencePaymentMethodTag { override def toString = "display" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ExperiencePaymentMethodTag

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ExperiencePaymentMethodTag] = scala.List(Display)

    private[this]
    val byName: Map[String, ExperiencePaymentMethodTag] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExperiencePaymentMethodTag = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExperiencePaymentMethodTag] = byName.get(value.toLowerCase)

  }

  sealed trait ExperienceStatus extends _root_.scala.Product with _root_.scala.Serializable

  object ExperienceStatus {

    case object Draft extends ExperienceStatus { override def toString = "draft" }
    case object Active extends ExperienceStatus { override def toString = "active" }
    /**
     * Archiving indicates an experience has been archived. We allow some time for
     * sessions to expire before fully marking the experience archived.
     */
    case object Archiving extends ExperienceStatus { override def toString = "archiving" }
    case object Archived extends ExperienceStatus { override def toString = "archived" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ExperienceStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ExperienceStatus] = scala.List(Draft, Active, Archiving, Archived)

    private[this]
    val byName: Map[String, ExperienceStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExperienceStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExperienceStatus] = byName.get(value.toLowerCase)

  }

  sealed trait OrderErrorCode extends _root_.scala.Product with _root_.scala.Serializable

  object OrderErrorCode {

    case object GenericError extends OrderErrorCode { override def toString = "generic_error" }
    /**
     * When creating an order, if a particular item is not available in the country /
     * destination (either because it was restricted or excluded from that country), we
     * return this error code and list the specific item numbers which are not
     * available in the 'numbers' field.
     */
    case object OrderItemNotAvailable extends OrderErrorCode { override def toString = "order_item_not_available" }
    /**
     * Indicates that there is no order with the specified number (nor an order for
     * which an order identifier with that number has been created)
     */
    case object OrderIdentifierError extends OrderErrorCode { override def toString = "order_identifier_error" }
    /**
     * The authorization key specified is invalid - either because it does not exist or
     * is not associated with this order
     */
    case object AuthorizationInvalid extends OrderErrorCode { override def toString = "authorization_invalid" }
    /**
     * Indicates that an order was created for a country for one of your domicile
     * countries and you have asked Flow not to accept orders for this country.
     */
    case object DomesticShippingUnavailable extends OrderErrorCode { override def toString = "domestic_shipping_unavailable" }
    /**
     * Indicates that an order was created for a country to which you have asked Flow
     * not to ship.
     */
    case object ShippingUnavailable extends OrderErrorCode { override def toString = "shipping_unavailable" }
    /**
     * Indicates the order value exceeds the value threshold for destination and cannot
     * be shipped. When specified, the order will also populate the threshold
     * attribute.
     */
    case object ValueThresholdExceeded extends OrderErrorCode { override def toString = "value_threshold_exceeded" }
    /**
     * Indicates that the specified currency code is not valid
     */
    case object InvalidCurrency extends OrderErrorCode { override def toString = "invalid_currency" }
    /**
     * Indicates that the specified country code is not valid
     */
    case object InvalidCountry extends OrderErrorCode { override def toString = "invalid_country" }
    /**
     * Indicates that the specified region code is not valid
     */
    case object InvalidRegion extends OrderErrorCode { override def toString = "invalid_region" }
    /**
     * Indicates that the specified language code is not valid
     */
    case object InvalidLanguage extends OrderErrorCode { override def toString = "invalid_language" }
    /**
     * Indicates that one or more ordered items is marked as out-of-stock or otherwise
     * cannot be reserved. We will list the specific out-of-stock items in the numbers
     * field
     */
    case object ItemOutOfStock extends OrderErrorCode { override def toString = "item_out_of_stock" }
    /**
     * Indicates a failure to charge a gift card. Error message will indicate when
     * retries are possible.
     */
    case object GiftCardNotAccepted extends OrderErrorCode { override def toString = "gift_card_not_accepted" }
    /**
     * Indicates that the order total has changed, likely due to pricebook update or
     * rate change. This is not an error but the consumer should be shown the new price
     * before continuing checkout.
     */
    case object TotalChanged extends OrderErrorCode { override def toString = "total_changed" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OrderErrorCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderErrorCode] = scala.List(GenericError, OrderItemNotAvailable, OrderIdentifierError, AuthorizationInvalid, DomesticShippingUnavailable, ShippingUnavailable, ValueThresholdExceeded, InvalidCurrency, InvalidCountry, InvalidRegion, InvalidLanguage, ItemOutOfStock, GiftCardNotAccepted, TotalChanged)

    private[this]
    val byName: Map[String, OrderErrorCode] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderErrorCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderErrorCode] = byName.get(value.toLowerCase)

  }

  /**
   * The order payment type identified the different ways a consumer may have paid
   * for an order. The primary purpose is in displaying summary level payment
   * information to the user; the type can then be used to know how to request
   * additional details for each payment.
   */
  sealed trait OrderPaymentType extends _root_.scala.Product with _root_.scala.Serializable

  object OrderPaymentType {

    /**
     * Represents a payment in the form of a credit or debit card
     */
    case object Card extends OrderPaymentType { override def toString = "card" }
    /**
     * Represents an online payment (e.g. paypal, alipay, etc)
     */
    case object Online extends OrderPaymentType { override def toString = "online" }
    /**
     * A payment in the form of a credit of some type (e.g. a store credit, gift card)
     * applied to an order
     */
    case object Credit extends OrderPaymentType { override def toString = "credit" }
    /**
     * An installment plan payment represents that the user has elected an installment
     * plan to pay for this order. For the purposes of the order, the balance will
     * reflect fully paid for the total value of the installment plan, even though
     * individual installments may be created in the future. Note this feature was
     * deprecated in early 2020.
     */
    case object InstallmentPlan extends OrderPaymentType { override def toString = "installment_plan" }
    /**
     * Request to pay the balance with cash on delivery. Offered only when the final
     * mile carriers support cash on delivery.
     */
    case object CashOnDelivery extends OrderPaymentType { override def toString = "cash_on_delivery" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OrderPaymentType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderPaymentType] = scala.List(Card, Online, Credit, InstallmentPlan, CashOnDelivery)

    private[this]
    val byName: Map[String, OrderPaymentType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderPaymentType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderPaymentType] = byName.get(value.toLowerCase)

  }

  sealed trait OrderRefundSummaryIncludes extends _root_.scala.Product with _root_.scala.Serializable

  object OrderRefundSummaryIncludes {

    case object Duties extends OrderRefundSummaryIncludes { override def toString = "duties" }
    case object Vat extends OrderRefundSummaryIncludes { override def toString = "vat" }
    case object Shipping extends OrderRefundSummaryIncludes { override def toString = "shipping" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OrderRefundSummaryIncludes

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderRefundSummaryIncludes] = scala.List(Duties, Vat, Shipping)

    private[this]
    val byName: Map[String, OrderRefundSummaryIncludes] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderRefundSummaryIncludes = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderRefundSummaryIncludes] = byName.get(value.toLowerCase)

  }

  sealed trait OrderRefundSummaryPartialCharged extends _root_.scala.Product with _root_.scala.Serializable

  object OrderRefundSummaryPartialCharged {

    case object PerItem extends OrderRefundSummaryPartialCharged { override def toString = "per_item" }
    case object ForOrder extends OrderRefundSummaryPartialCharged { override def toString = "for_order" }
    case object ByValuePercentage extends OrderRefundSummaryPartialCharged { override def toString = "by_value_percentage" }
    case object ByQuantityPercentage extends OrderRefundSummaryPartialCharged { override def toString = "by_quantity_percentage" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OrderRefundSummaryPartialCharged

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderRefundSummaryPartialCharged] = scala.List(PerItem, ForOrder, ByValuePercentage, ByQuantityPercentage)

    private[this]
    val byName: Map[String, OrderRefundSummaryPartialCharged] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderRefundSummaryPartialCharged = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderRefundSummaryPartialCharged] = byName.get(value.toLowerCase)

  }

  /**
   * Indicates an order's status
   */
  sealed trait OrderStatus extends _root_.scala.Product with _root_.scala.Serializable

  object OrderStatus {

    case object Open extends OrderStatus { override def toString = "open" }
    case object Submitted extends OrderStatus { override def toString = "submitted" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OrderStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderStatus] = scala.List(Open, Submitted)

    private[this]
    val byName: Map[String, OrderStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderStatus] = byName.get(value.toLowerCase)

  }

  sealed trait OrderStorage extends _root_.scala.Product with _root_.scala.Serializable

  object OrderStorage {

    /**
     * Indicates to not persist the order.
     */
    case object DoNotPersist extends OrderStorage { override def toString = "do_not_persist" }
    /**
     * Indicates to persist the order.
     */
    case object Persist extends OrderStorage { override def toString = "persist" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OrderStorage

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderStorage] = scala.List(DoNotPersist, Persist)

    private[this]
    val byName: Map[String, OrderStorage] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderStorage = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderStorage] = byName.get(value.toLowerCase)

  }

  /**
   * The type of the order i.e A standard order or replacement order.
   */
  sealed trait OrderType extends _root_.scala.Product with _root_.scala.Serializable

  object OrderType {

    case object Standard extends OrderType { override def toString = "standard" }
    case object Replacement extends OrderType { override def toString = "replacement" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OrderType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrderType] = scala.List(Standard, Replacement)

    private[this]
    val byName: Map[String, OrderType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrderType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrderType] = byName.get(value.toLowerCase)

  }

  sealed trait OrganizationPaymentMethodTag extends PaymentMethodTag

  object OrganizationPaymentMethodTag {

    /**
     * A denied payment method cannot be used for an organization in any experience.
     */
    case object Deny extends OrganizationPaymentMethodTag { override def toString = "deny" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OrganizationPaymentMethodTag

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OrganizationPaymentMethodTag] = scala.List(Deny)

    private[this]
    val byName: Map[String, OrganizationPaymentMethodTag] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OrganizationPaymentMethodTag = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OrganizationPaymentMethodTag] = byName.get(value.toLowerCase)

  }

  /**
   * Indicates the intent of a given instance of payment method rule content.
   */
  sealed trait PaymentMethodRuleContentKey extends _root_.scala.Product with _root_.scala.Serializable

  object PaymentMethodRuleContentKey {

    case object Description extends PaymentMethodRuleContentKey { override def toString = "description" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends PaymentMethodRuleContentKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[PaymentMethodRuleContentKey] = scala.List(Description)

    private[this]
    val byName: Map[String, PaymentMethodRuleContentKey] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PaymentMethodRuleContentKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PaymentMethodRuleContentKey] = byName.get(value.toLowerCase)

  }

  sealed trait PriceFacetBoundary extends _root_.scala.Product with _root_.scala.Serializable

  object PriceFacetBoundary {

    case object Min extends PriceFacetBoundary { override def toString = "min" }
    case object Max extends PriceFacetBoundary { override def toString = "max" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends PriceFacetBoundary

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[PriceFacetBoundary] = scala.List(Min, Max)

    private[this]
    val byName: Map[String, PriceFacetBoundary] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PriceFacetBoundary = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PriceFacetBoundary] = byName.get(value.toLowerCase)

  }

  /**
   * The Promotion Trigger Type defines the conditions we evaluate when deciding if a
   * particular promotion should be applied to an order.
   */
  sealed trait PromotionTriggerType extends _root_.scala.Product with _root_.scala.Serializable

  object PromotionTriggerType {

    /**
     * Automatic indicates the the promotion will be automatically applied to the order
     */
    case object Automatic extends PromotionTriggerType { override def toString = "automatic" }
    /**
     * Order subtotal sets a minimum value - orders whose subtotal is greater than the
     * minimum will have the promotion applied. A common use case is to offer free
     * shipping to orders about 150 CAD.
     */
    case object OrderSubtotal extends PromotionTriggerType { override def toString = "order_subtotal" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends PromotionTriggerType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[PromotionTriggerType] = scala.List(Automatic, OrderSubtotal)

    private[this]
    val byName: Map[String, PromotionTriggerType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PromotionTriggerType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PromotionTriggerType] = byName.get(value.toLowerCase)

  }

}

package io.flow.experience.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.catalog.v0.models.json._
    import io.flow.common.v0.models.json._
    import io.flow.error.v0.models.json._
    import io.flow.experience.v0.models.json._
    import io.flow.field.validation.v0.models.json._
    import io.flow.fulfillment.v0.models.json._
    import io.flow.harmonization.v0.models.json._
    import io.flow.inventory.v0.models.json._
    import io.flow.item.v0.models.json._
    import io.flow.order.price.v0.models.json._
    import io.flow.payment.v0.models.json._
    import io.flow.permission.v0.models.json._
    import io.flow.price.v0.models.json._
    import io.flow.query.builder.v0.models.json._
    import io.flow.reference.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map { str =>
      _root_.java.util.UUID.fromString(str)
    }

    private[v0] implicit val jsonWritesUUID = new Writes[_root_.java.util.UUID] {
      def writes(x: _root_.java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[_root_.org.joda.time.DateTime] {
      def writes(x: _root_.org.joda.time.DateTime) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x))
      }
    }

    private[v0] implicit val jsonReadsJodaLocalDate = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(str)
    }

    private[v0] implicit val jsonWritesJodaLocalDate = new Writes[_root_.org.joda.time.LocalDate] {
      def writes(x: _root_.org.joda.time.LocalDate) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.date.print(x))
      }
    }

    implicit val jsonReadsExperienceAddressFieldName = new play.api.libs.json.Reads[io.flow.experience.v0.models.AddressFieldName] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.AddressFieldName] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.AddressFieldName(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.AddressFieldName(v))
              case err: play.api.libs.json.JsError =>
                (js \ "address_field_name").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.AddressFieldName(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperienceAddressFieldName(obj: io.flow.experience.v0.models.AddressFieldName) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAddressFieldName(obj: io.flow.experience.v0.models.AddressFieldName) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceAddressFieldName: play.api.libs.json.Writes[AddressFieldName] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AddressFieldName] {
        def writes(obj: io.flow.experience.v0.models.AddressFieldName) = {
          jsonWritesExperienceAddressFieldName(obj)
        }
      }
    }

    implicit val jsonReadsExperienceCreditPaymentErrorCode = new play.api.libs.json.Reads[io.flow.experience.v0.models.CreditPaymentErrorCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.CreditPaymentErrorCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.CreditPaymentErrorCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.CreditPaymentErrorCode(v))
              case err: play.api.libs.json.JsError =>
                (js \ "credit_payment_error_code").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.CreditPaymentErrorCode(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperienceCreditPaymentErrorCode(obj: io.flow.experience.v0.models.CreditPaymentErrorCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCreditPaymentErrorCode(obj: io.flow.experience.v0.models.CreditPaymentErrorCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceCreditPaymentErrorCode: play.api.libs.json.Writes[CreditPaymentErrorCode] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CreditPaymentErrorCode] {
        def writes(obj: io.flow.experience.v0.models.CreditPaymentErrorCode) = {
          jsonWritesExperienceCreditPaymentErrorCode(obj)
        }
      }
    }

    implicit val jsonReadsExperienceDeliveredDutyDisplayType = new play.api.libs.json.Reads[io.flow.experience.v0.models.DeliveredDutyDisplayType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.DeliveredDutyDisplayType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.DeliveredDutyDisplayType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.DeliveredDutyDisplayType(v))
              case err: play.api.libs.json.JsError =>
                (js \ "delivered_duty_display_type").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.DeliveredDutyDisplayType(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperienceDeliveredDutyDisplayType(obj: io.flow.experience.v0.models.DeliveredDutyDisplayType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectDeliveredDutyDisplayType(obj: io.flow.experience.v0.models.DeliveredDutyDisplayType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceDeliveredDutyDisplayType: play.api.libs.json.Writes[DeliveredDutyDisplayType] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.DeliveredDutyDisplayType] {
        def writes(obj: io.flow.experience.v0.models.DeliveredDutyDisplayType) = {
          jsonWritesExperienceDeliveredDutyDisplayType(obj)
        }
      }
    }

    implicit val jsonReadsExperienceDiscountRuleStatus = new play.api.libs.json.Reads[io.flow.experience.v0.models.DiscountRuleStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.DiscountRuleStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.DiscountRuleStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.DiscountRuleStatus(v))
              case err: play.api.libs.json.JsError =>
                (js \ "discount_rule_status").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.DiscountRuleStatus(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperienceDiscountRuleStatus(obj: io.flow.experience.v0.models.DiscountRuleStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectDiscountRuleStatus(obj: io.flow.experience.v0.models.DiscountRuleStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceDiscountRuleStatus: play.api.libs.json.Writes[DiscountRuleStatus] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.DiscountRuleStatus] {
        def writes(obj: io.flow.experience.v0.models.DiscountRuleStatus) = {
          jsonWritesExperienceDiscountRuleStatus(obj)
        }
      }
    }

    implicit val jsonReadsExperienceDiscountRuleSubsidyTarget = new play.api.libs.json.Reads[io.flow.experience.v0.models.DiscountRuleSubsidyTarget] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.DiscountRuleSubsidyTarget] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.DiscountRuleSubsidyTarget(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.DiscountRuleSubsidyTarget(v))
              case err: play.api.libs.json.JsError =>
                (js \ "discount_rule_subsidy_target").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.DiscountRuleSubsidyTarget(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperienceDiscountRuleSubsidyTarget(obj: io.flow.experience.v0.models.DiscountRuleSubsidyTarget) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectDiscountRuleSubsidyTarget(obj: io.flow.experience.v0.models.DiscountRuleSubsidyTarget) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceDiscountRuleSubsidyTarget: play.api.libs.json.Writes[DiscountRuleSubsidyTarget] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.DiscountRuleSubsidyTarget] {
        def writes(obj: io.flow.experience.v0.models.DiscountRuleSubsidyTarget) = {
          jsonWritesExperienceDiscountRuleSubsidyTarget(obj)
        }
      }
    }

    implicit val jsonReadsExperienceExperienceCloneStatus = new play.api.libs.json.Reads[io.flow.experience.v0.models.ExperienceCloneStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.ExperienceCloneStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperienceCloneStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperienceCloneStatus(v))
              case err: play.api.libs.json.JsError =>
                (js \ "experience_clone_status").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperienceCloneStatus(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperienceExperienceCloneStatus(obj: io.flow.experience.v0.models.ExperienceCloneStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectExperienceCloneStatus(obj: io.flow.experience.v0.models.ExperienceCloneStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceExperienceCloneStatus: play.api.libs.json.Writes[ExperienceCloneStatus] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceCloneStatus] {
        def writes(obj: io.flow.experience.v0.models.ExperienceCloneStatus) = {
          jsonWritesExperienceExperienceCloneStatus(obj)
        }
      }
    }

    implicit val jsonReadsExperienceExperienceCountryStatus = new play.api.libs.json.Reads[io.flow.experience.v0.models.ExperienceCountryStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.ExperienceCountryStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperienceCountryStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperienceCountryStatus(v))
              case err: play.api.libs.json.JsError =>
                (js \ "experience_country_status").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperienceCountryStatus(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperienceExperienceCountryStatus(obj: io.flow.experience.v0.models.ExperienceCountryStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectExperienceCountryStatus(obj: io.flow.experience.v0.models.ExperienceCountryStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceExperienceCountryStatus: play.api.libs.json.Writes[ExperienceCountryStatus] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceCountryStatus] {
        def writes(obj: io.flow.experience.v0.models.ExperienceCountryStatus) = {
          jsonWritesExperienceExperienceCountryStatus(obj)
        }
      }
    }

    implicit val jsonReadsExperienceExperiencePaymentMethodTag = new play.api.libs.json.Reads[io.flow.experience.v0.models.ExperiencePaymentMethodTag] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.ExperiencePaymentMethodTag] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperiencePaymentMethodTag(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperiencePaymentMethodTag(v))
              case err: play.api.libs.json.JsError =>
                (js \ "experience_payment_method_tag").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperiencePaymentMethodTag(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperienceExperiencePaymentMethodTag(obj: io.flow.experience.v0.models.ExperiencePaymentMethodTag) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectExperiencePaymentMethodTag(obj: io.flow.experience.v0.models.ExperiencePaymentMethodTag) = {
      play.api.libs.json.Json.obj("discriminator" -> "experience_payment_method_tag", "value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceExperiencePaymentMethodTag: play.api.libs.json.Writes[ExperiencePaymentMethodTag] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePaymentMethodTag] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePaymentMethodTag) = {
          jsObjectExperiencePaymentMethodTag(obj)
        }
      }
    }

    implicit val jsonReadsExperienceExperienceStatus = new play.api.libs.json.Reads[io.flow.experience.v0.models.ExperienceStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.ExperienceStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperienceStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperienceStatus(v))
              case err: play.api.libs.json.JsError =>
                (js \ "experience_status").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExperienceStatus(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperienceExperienceStatus(obj: io.flow.experience.v0.models.ExperienceStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectExperienceStatus(obj: io.flow.experience.v0.models.ExperienceStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceExperienceStatus: play.api.libs.json.Writes[ExperienceStatus] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceStatus] {
        def writes(obj: io.flow.experience.v0.models.ExperienceStatus) = {
          jsonWritesExperienceExperienceStatus(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrderErrorCode = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrderErrorCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrderErrorCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderErrorCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderErrorCode(v))
              case err: play.api.libs.json.JsError =>
                (js \ "order_error_code").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderErrorCode(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrderErrorCode(obj: io.flow.experience.v0.models.OrderErrorCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrderErrorCode(obj: io.flow.experience.v0.models.OrderErrorCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrderErrorCode: play.api.libs.json.Writes[OrderErrorCode] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderErrorCode] {
        def writes(obj: io.flow.experience.v0.models.OrderErrorCode) = {
          jsonWritesExperienceOrderErrorCode(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrderPaymentType = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrderPaymentType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrderPaymentType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPaymentType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPaymentType(v))
              case err: play.api.libs.json.JsError =>
                (js \ "order_payment_type").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPaymentType(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrderPaymentType(obj: io.flow.experience.v0.models.OrderPaymentType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrderPaymentType(obj: io.flow.experience.v0.models.OrderPaymentType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrderPaymentType: play.api.libs.json.Writes[OrderPaymentType] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPaymentType] {
        def writes(obj: io.flow.experience.v0.models.OrderPaymentType) = {
          jsonWritesExperienceOrderPaymentType(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrderRefundSummaryIncludes = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrderRefundSummaryIncludes] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrderRefundSummaryIncludes] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderRefundSummaryIncludes(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderRefundSummaryIncludes(v))
              case err: play.api.libs.json.JsError =>
                (js \ "order_refund_summary_includes").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderRefundSummaryIncludes(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrderRefundSummaryIncludes(obj: io.flow.experience.v0.models.OrderRefundSummaryIncludes) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrderRefundSummaryIncludes(obj: io.flow.experience.v0.models.OrderRefundSummaryIncludes) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrderRefundSummaryIncludes: play.api.libs.json.Writes[OrderRefundSummaryIncludes] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderRefundSummaryIncludes] {
        def writes(obj: io.flow.experience.v0.models.OrderRefundSummaryIncludes) = {
          jsonWritesExperienceOrderRefundSummaryIncludes(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrderRefundSummaryPartialCharged = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrderRefundSummaryPartialCharged] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrderRefundSummaryPartialCharged] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderRefundSummaryPartialCharged(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderRefundSummaryPartialCharged(v))
              case err: play.api.libs.json.JsError =>
                (js \ "order_refund_summary_partial_charged").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderRefundSummaryPartialCharged(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrderRefundSummaryPartialCharged(obj: io.flow.experience.v0.models.OrderRefundSummaryPartialCharged) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrderRefundSummaryPartialCharged(obj: io.flow.experience.v0.models.OrderRefundSummaryPartialCharged) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrderRefundSummaryPartialCharged: play.api.libs.json.Writes[OrderRefundSummaryPartialCharged] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderRefundSummaryPartialCharged] {
        def writes(obj: io.flow.experience.v0.models.OrderRefundSummaryPartialCharged) = {
          jsonWritesExperienceOrderRefundSummaryPartialCharged(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrderStatus = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrderStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrderStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderStatus(v))
              case err: play.api.libs.json.JsError =>
                (js \ "order_status").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderStatus(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrderStatus(obj: io.flow.experience.v0.models.OrderStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrderStatus(obj: io.flow.experience.v0.models.OrderStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrderStatus: play.api.libs.json.Writes[OrderStatus] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderStatus] {
        def writes(obj: io.flow.experience.v0.models.OrderStatus) = {
          jsonWritesExperienceOrderStatus(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrderStorage = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrderStorage] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrderStorage] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderStorage(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderStorage(v))
              case err: play.api.libs.json.JsError =>
                (js \ "order_storage").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderStorage(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrderStorage(obj: io.flow.experience.v0.models.OrderStorage) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrderStorage(obj: io.flow.experience.v0.models.OrderStorage) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrderStorage: play.api.libs.json.Writes[OrderStorage] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderStorage] {
        def writes(obj: io.flow.experience.v0.models.OrderStorage) = {
          jsonWritesExperienceOrderStorage(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrderType = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrderType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrderType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderType(v))
              case err: play.api.libs.json.JsError =>
                (js \ "order_type").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderType(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrderType(obj: io.flow.experience.v0.models.OrderType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrderType(obj: io.flow.experience.v0.models.OrderType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrderType: play.api.libs.json.Writes[OrderType] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderType] {
        def writes(obj: io.flow.experience.v0.models.OrderType) = {
          jsonWritesExperienceOrderType(obj)
        }
      }
    }

    implicit val jsonReadsExperienceOrganizationPaymentMethodTag = new play.api.libs.json.Reads[io.flow.experience.v0.models.OrganizationPaymentMethodTag] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.OrganizationPaymentMethodTag] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrganizationPaymentMethodTag(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrganizationPaymentMethodTag(v))
              case err: play.api.libs.json.JsError =>
                (js \ "organization_payment_method_tag").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrganizationPaymentMethodTag(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperienceOrganizationPaymentMethodTag(obj: io.flow.experience.v0.models.OrganizationPaymentMethodTag) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOrganizationPaymentMethodTag(obj: io.flow.experience.v0.models.OrganizationPaymentMethodTag) = {
      play.api.libs.json.Json.obj("discriminator" -> "organization_payment_method_tag", "value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperienceOrganizationPaymentMethodTag: play.api.libs.json.Writes[OrganizationPaymentMethodTag] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrganizationPaymentMethodTag] {
        def writes(obj: io.flow.experience.v0.models.OrganizationPaymentMethodTag) = {
          jsObjectOrganizationPaymentMethodTag(obj)
        }
      }
    }

    implicit val jsonReadsExperiencePaymentMethodRuleContentKey = new play.api.libs.json.Reads[io.flow.experience.v0.models.PaymentMethodRuleContentKey] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.PaymentMethodRuleContentKey] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PaymentMethodRuleContentKey(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PaymentMethodRuleContentKey(v))
              case err: play.api.libs.json.JsError =>
                (js \ "payment_method_rule_content_key").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PaymentMethodRuleContentKey(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperiencePaymentMethodRuleContentKey(obj: io.flow.experience.v0.models.PaymentMethodRuleContentKey) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPaymentMethodRuleContentKey(obj: io.flow.experience.v0.models.PaymentMethodRuleContentKey) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperiencePaymentMethodRuleContentKey: play.api.libs.json.Writes[PaymentMethodRuleContentKey] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PaymentMethodRuleContentKey] {
        def writes(obj: io.flow.experience.v0.models.PaymentMethodRuleContentKey) = {
          jsonWritesExperiencePaymentMethodRuleContentKey(obj)
        }
      }
    }

    implicit val jsonReadsExperiencePriceFacetBoundary = new play.api.libs.json.Reads[io.flow.experience.v0.models.PriceFacetBoundary] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.PriceFacetBoundary] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PriceFacetBoundary(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PriceFacetBoundary(v))
              case err: play.api.libs.json.JsError =>
                (js \ "price_facet_boundary").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PriceFacetBoundary(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperiencePriceFacetBoundary(obj: io.flow.experience.v0.models.PriceFacetBoundary) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPriceFacetBoundary(obj: io.flow.experience.v0.models.PriceFacetBoundary) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperiencePriceFacetBoundary: play.api.libs.json.Writes[PriceFacetBoundary] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PriceFacetBoundary] {
        def writes(obj: io.flow.experience.v0.models.PriceFacetBoundary) = {
          jsonWritesExperiencePriceFacetBoundary(obj)
        }
      }
    }

    implicit val jsonReadsExperiencePromotionTriggerType = new play.api.libs.json.Reads[io.flow.experience.v0.models.PromotionTriggerType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.experience.v0.models.PromotionTriggerType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PromotionTriggerType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PromotionTriggerType(v))
              case err: play.api.libs.json.JsError =>
                (js \ "promotion_trigger_type").validate[String] match {
                  case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PromotionTriggerType(v))
                  case err: play.api.libs.json.JsError => err
                }
            }
          }
        }
      }
    }

    def jsonWritesExperiencePromotionTriggerType(obj: io.flow.experience.v0.models.PromotionTriggerType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPromotionTriggerType(obj: io.flow.experience.v0.models.PromotionTriggerType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesExperiencePromotionTriggerType: play.api.libs.json.Writes[PromotionTriggerType] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PromotionTriggerType] {
        def writes(obj: io.flow.experience.v0.models.PromotionTriggerType) = {
          jsonWritesExperiencePromotionTriggerType(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAddressConfiguration: play.api.libs.json.Reads[AddressConfiguration] = {
      for {
        country <- (__ \ "country").read[String]
        fieldValidation <- (__ \ "field_validation").read[io.flow.experience.v0.models.AddressFieldValidation]
        provinces <- (__ \ "provinces").read[Seq[io.flow.experience.v0.models.AddressConfigurationProvince]]
        formats <- (__ \ "formats").readWithDefault[Seq[io.flow.experience.v0.models.AddressConfigurationFormat]](Nil)
        provinceType <- (__ \ "province_type").readNullable[io.flow.reference.v0.models.ProvinceType]
        postalType <- (__ \ "postal_type").readNullable[io.flow.reference.v0.models.PostalType]
      } yield AddressConfiguration(country, fieldValidation, provinces, formats, provinceType, postalType)
    }

    def jsObjectAddressConfiguration(obj: io.flow.experience.v0.models.AddressConfiguration): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "country" -> play.api.libs.json.JsString(obj.country),
        "field_validation" -> jsObjectAddressFieldValidation(obj.fieldValidation),
        "provinces" -> play.api.libs.json.Json.toJson(obj.provinces),
        "formats" -> play.api.libs.json.Json.toJson(obj.formats)
      ) ++ (obj.provinceType match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("province_type" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.postalType match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("postal_type" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesExperienceAddressConfiguration: play.api.libs.json.Writes[AddressConfiguration] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AddressConfiguration] {
        def writes(obj: io.flow.experience.v0.models.AddressConfiguration) = {
          jsObjectAddressConfiguration(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAddressConfigurationFieldPlacement: play.api.libs.json.Reads[AddressConfigurationFieldPlacement] = {
      (__ \ "name").read[io.flow.experience.v0.models.AddressFieldName].map { x => new AddressConfigurationFieldPlacement(name = x) }
    }

    def jsObjectAddressConfigurationFieldPlacement(obj: io.flow.experience.v0.models.AddressConfigurationFieldPlacement): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name.toString)
      )
    }

    implicit def jsonWritesExperienceAddressConfigurationFieldPlacement: play.api.libs.json.Writes[AddressConfigurationFieldPlacement] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AddressConfigurationFieldPlacement] {
        def writes(obj: io.flow.experience.v0.models.AddressConfigurationFieldPlacement) = {
          jsObjectAddressConfigurationFieldPlacement(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAddressConfigurationFormat: play.api.libs.json.Reads[AddressConfigurationFormat] = {
      (__ \ "placements").read[Seq[io.flow.experience.v0.models.AddressConfigurationFieldPlacement]].map { x => new AddressConfigurationFormat(placements = x) }
    }

    def jsObjectAddressConfigurationFormat(obj: io.flow.experience.v0.models.AddressConfigurationFormat): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "placements" -> play.api.libs.json.Json.toJson(obj.placements)
      )
    }

    implicit def jsonWritesExperienceAddressConfigurationFormat: play.api.libs.json.Writes[AddressConfigurationFormat] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AddressConfigurationFormat] {
        def writes(obj: io.flow.experience.v0.models.AddressConfigurationFormat) = {
          jsObjectAddressConfigurationFormat(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAddressConfigurationProvince: play.api.libs.json.Reads[AddressConfigurationProvince] = {
      for {
        value <- (__ \ "value").read[String]
        name <- (__ \ "name").read[String]
        translations <- (__ \ "translations").readNullable[Seq[io.flow.experience.v0.models.AddressConfigurationProvinceTranslation]]
      } yield AddressConfigurationProvince(value, name, translations)
    }

    def jsObjectAddressConfigurationProvince(obj: io.flow.experience.v0.models.AddressConfigurationProvince): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "value" -> play.api.libs.json.JsString(obj.value),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.translations match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("translations" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceAddressConfigurationProvince: play.api.libs.json.Writes[AddressConfigurationProvince] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AddressConfigurationProvince] {
        def writes(obj: io.flow.experience.v0.models.AddressConfigurationProvince) = {
          jsObjectAddressConfigurationProvince(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAddressConfigurationProvinceTranslation: play.api.libs.json.Reads[AddressConfigurationProvinceTranslation] = {
      for {
        locale <- (__ \ "locale").read[io.flow.experience.v0.models.AddressConfigurationProvinceTranslationLocale]
        name <- (__ \ "name").read[String]
      } yield AddressConfigurationProvinceTranslation(locale, name)
    }

    def jsObjectAddressConfigurationProvinceTranslation(obj: io.flow.experience.v0.models.AddressConfigurationProvinceTranslation): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "locale" -> jsObjectAddressConfigurationProvinceTranslationLocale(obj.locale),
        "name" -> play.api.libs.json.JsString(obj.name)
      )
    }

    implicit def jsonWritesExperienceAddressConfigurationProvinceTranslation: play.api.libs.json.Writes[AddressConfigurationProvinceTranslation] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AddressConfigurationProvinceTranslation] {
        def writes(obj: io.flow.experience.v0.models.AddressConfigurationProvinceTranslation) = {
          jsObjectAddressConfigurationProvinceTranslation(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAddressConfigurationProvinceTranslationLocale: play.api.libs.json.Reads[AddressConfigurationProvinceTranslationLocale] = {
      for {
        id <- (__ \ "id").read[String]
        name <- (__ \ "name").read[String]
        language <- (__ \ "language").read[String]
      } yield AddressConfigurationProvinceTranslationLocale(id, name, language)
    }

    def jsObjectAddressConfigurationProvinceTranslationLocale(obj: io.flow.experience.v0.models.AddressConfigurationProvinceTranslationLocale): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "name" -> play.api.libs.json.JsString(obj.name),
        "language" -> play.api.libs.json.JsString(obj.language)
      )
    }

    implicit def jsonWritesExperienceAddressConfigurationProvinceTranslationLocale: play.api.libs.json.Writes[AddressConfigurationProvinceTranslationLocale] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AddressConfigurationProvinceTranslationLocale] {
        def writes(obj: io.flow.experience.v0.models.AddressConfigurationProvinceTranslationLocale) = {
          jsObjectAddressConfigurationProvinceTranslationLocale(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAddressFieldValidation: play.api.libs.json.Reads[AddressFieldValidation] = {
      for {
        firstName <- (__ \ "first_name").read[Seq[io.flow.field.validation.v0.models.FieldValidationRule]]
        lastName <- (__ \ "last_name").read[Seq[io.flow.field.validation.v0.models.FieldValidationRule]]
        street1 <- (__ \ "street_1").read[Seq[io.flow.field.validation.v0.models.FieldValidationRule]]
        street2 <- (__ \ "street_2").read[Seq[io.flow.field.validation.v0.models.FieldValidationRule]]
        city <- (__ \ "city").read[Seq[io.flow.field.validation.v0.models.FieldValidationRule]]
        province <- (__ \ "province").read[Seq[io.flow.field.validation.v0.models.FieldValidationRule]]
        postal <- (__ \ "postal").read[Seq[io.flow.field.validation.v0.models.FieldValidationRule]]
        phone <- (__ \ "phone").read[Seq[io.flow.field.validation.v0.models.FieldValidationRule]]
        vatRegistrationNumber <- (__ \ "vat_registration_number").read[Seq[io.flow.field.validation.v0.models.FieldValidationRule]]
      } yield AddressFieldValidation(firstName, lastName, street1, street2, city, province, postal, phone, vatRegistrationNumber)
    }

    def jsObjectAddressFieldValidation(obj: io.flow.experience.v0.models.AddressFieldValidation): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "first_name" -> play.api.libs.json.Json.toJson(obj.firstName),
        "last_name" -> play.api.libs.json.Json.toJson(obj.lastName),
        "street_1" -> play.api.libs.json.Json.toJson(obj.street1),
        "street_2" -> play.api.libs.json.Json.toJson(obj.street2),
        "city" -> play.api.libs.json.Json.toJson(obj.city),
        "province" -> play.api.libs.json.Json.toJson(obj.province),
        "postal" -> play.api.libs.json.Json.toJson(obj.postal),
        "phone" -> play.api.libs.json.Json.toJson(obj.phone),
        "vat_registration_number" -> play.api.libs.json.Json.toJson(obj.vatRegistrationNumber)
      )
    }

    implicit def jsonWritesExperienceAddressFieldValidation: play.api.libs.json.Writes[AddressFieldValidation] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AddressFieldValidation] {
        def writes(obj: io.flow.experience.v0.models.AddressFieldValidation) = {
          jsObjectAddressFieldValidation(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocation: play.api.libs.json.Reads[Allocation] = {
      for {
        order <- (__ \ "order").read[io.flow.experience.v0.models.AllocationOrderSummary]
        details <- (__ \ "details").read[Seq[io.flow.experience.v0.models.AllocationDetail]]
      } yield Allocation(order, details)
    }

    def jsObjectAllocation(obj: io.flow.experience.v0.models.Allocation): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "order" -> jsObjectAllocationOrderSummary(obj.order),
        "details" -> play.api.libs.json.Json.toJson(obj.details)
      )
    }

    implicit def jsonWritesExperienceAllocation: play.api.libs.json.Writes[Allocation] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.Allocation] {
        def writes(obj: io.flow.experience.v0.models.Allocation) = {
          jsObjectAllocation(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationDetailComponent: play.api.libs.json.Reads[AllocationDetailComponent] = {
      for {
        key <- (__ \ "key").read[io.flow.order.price.v0.models.OrderPriceDetailComponentKey]
        total <- (__ \ "total").read[io.flow.common.v0.models.PriceWithBase]
        price <- (__ \ "price").readNullable[io.flow.common.v0.models.PriceWithBase]
      } yield AllocationDetailComponent(key, total, price)
    }

    def jsObjectAllocationDetailComponent(obj: io.flow.experience.v0.models.AllocationDetailComponent): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total)
      ) ++ (obj.price match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("price" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "allocation_detail_component")
    }

    implicit def jsonWritesExperienceAllocationDetailComponent: play.api.libs.json.Writes[AllocationDetailComponent] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AllocationDetailComponent] {
        def writes(obj: io.flow.experience.v0.models.AllocationDetailComponent) = {
          jsObjectAllocationDetailComponent(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationLevyComponent: play.api.libs.json.Reads[AllocationLevyComponent] = {
      for {
        key <- (__ \ "key").read[io.flow.order.price.v0.models.OrderPriceDetailComponentKey]
        total <- (__ \ "total").read[io.flow.common.v0.models.PriceWithBase]
        rate <- (__ \ "rate").read[BigDecimal]
        name <- (__ \ "name").read[String]
        price <- (__ \ "price").readNullable[io.flow.common.v0.models.PriceWithBase]
        accuracy <- (__ \ "accuracy").readWithDefault[io.flow.price.v0.models.PriceAccuracy](io.flow.price.v0.models.PriceAccuracy.Calculated)
        basis <- (__ \ "basis").readNullable[io.flow.common.v0.models.MoneyWithBase]
      } yield AllocationLevyComponent(key, total, rate, name, price, accuracy, basis)
    }

    def jsObjectAllocationLevyComponent(obj: io.flow.experience.v0.models.AllocationLevyComponent): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total),
        "rate" -> play.api.libs.json.JsNumber(obj.rate),
        "name" -> play.api.libs.json.JsString(obj.name),
        "accuracy" -> play.api.libs.json.JsString(obj.accuracy.toString)
      ) ++ (obj.price match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("price" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(x))
      }) ++
      (obj.basis match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("basis" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "allocation_levy_component")
    }

    implicit def jsonWritesExperienceAllocationLevyComponent: play.api.libs.json.Writes[AllocationLevyComponent] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AllocationLevyComponent] {
        def writes(obj: io.flow.experience.v0.models.AllocationLevyComponent) = {
          jsObjectAllocationLevyComponent(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationLineDetail: play.api.libs.json.Reads[AllocationLineDetail] = {
      for {
        id <- (__ \ "id").readNullable[String]
        number <- (__ \ "number").read[String]
        quantity <- (__ \ "quantity").read[Long]
        key <- (__ \ "key").read[io.flow.order.price.v0.models.OrderPriceDetailKey]
        price <- (__ \ "price").read[io.flow.common.v0.models.PriceWithBase]
        total <- (__ \ "total").read[io.flow.common.v0.models.PriceWithBase]
        included <- (__ \ "included").read[Seq[io.flow.experience.v0.models.AllocationComponent]]
        notIncluded <- (__ \ "not_included").read[Seq[io.flow.experience.v0.models.AllocationComponent]]
      } yield AllocationLineDetail(id, number, quantity, key, price, total, included, notIncluded)
    }

    def jsObjectAllocationLineDetail(obj: io.flow.experience.v0.models.AllocationLineDetail): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "price" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.price),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total),
        "included" -> play.api.libs.json.Json.toJson(obj.included),
        "not_included" -> play.api.libs.json.Json.toJson(obj.notIncluded)
      ) ++ (obj.id match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("id" -> play.api.libs.json.JsString(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "allocation_line_detail")
    }

    implicit def jsonWritesExperienceAllocationLineDetail: play.api.libs.json.Writes[AllocationLineDetail] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AllocationLineDetail] {
        def writes(obj: io.flow.experience.v0.models.AllocationLineDetail) = {
          jsObjectAllocationLineDetail(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationLineSummary: play.api.libs.json.Reads[AllocationLineSummary] = {
      for {
        lineItems <- (__ \ "line_items").read[Seq[io.flow.experience.v0.models.AllocationLineSummaryLineItem]]
        shipping <- (__ \ "shipping").read[io.flow.experience.v0.models.AllocationLineSummaryShipping]
        subtotal <- (__ \ "subtotal").read[io.flow.common.v0.models.MoneyWithBase]
        discount <- (__ \ "discount").read[io.flow.common.v0.models.MoneyWithBase]
        duties <- (__ \ "duties").read[io.flow.common.v0.models.MoneyWithBase]
        tax <- (__ \ "tax").read[io.flow.common.v0.models.MoneyWithBase]
        taxSubsidy <- (__ \ "tax_subsidy").read[io.flow.common.v0.models.MoneyWithBase]
        dutiesSubsidy <- (__ \ "duties_subsidy").read[io.flow.common.v0.models.MoneyWithBase]
        total <- (__ \ "total").read[io.flow.common.v0.models.MoneyWithBase]
      } yield AllocationLineSummary(lineItems, shipping, subtotal, discount, duties, tax, taxSubsidy, dutiesSubsidy, total)
    }

    def jsObjectAllocationLineSummary(obj: io.flow.experience.v0.models.AllocationLineSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "line_items" -> play.api.libs.json.Json.toJson(obj.lineItems),
        "shipping" -> jsObjectAllocationLineSummaryShipping(obj.shipping),
        "subtotal" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.subtotal),
        "discount" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.discount),
        "duties" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.duties),
        "tax" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.tax),
        "tax_subsidy" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.taxSubsidy),
        "duties_subsidy" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.dutiesSubsidy),
        "total" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.total)
      )
    }

    implicit def jsonWritesExperienceAllocationLineSummary: play.api.libs.json.Writes[AllocationLineSummary] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AllocationLineSummary] {
        def writes(obj: io.flow.experience.v0.models.AllocationLineSummary) = {
          jsObjectAllocationLineSummary(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationLineSummaryLineItem: play.api.libs.json.Reads[AllocationLineSummaryLineItem] = {
      for {
        itemNumber <- (__ \ "item_number").read[String]
        lineNumber <- (__ \ "line_number").readNullable[String]
        subtotal <- (__ \ "subtotal").read[io.flow.common.v0.models.MoneyWithBase]
        discount <- (__ \ "discount").read[io.flow.common.v0.models.MoneyWithBase]
        duties <- (__ \ "duties").read[io.flow.common.v0.models.MoneyWithBase]
        tax <- (__ \ "tax").read[io.flow.common.v0.models.MoneyWithBase]
        taxSubsidy <- (__ \ "tax_subsidy").read[io.flow.common.v0.models.MoneyWithBase]
        dutiesSubsidy <- (__ \ "duties_subsidy").read[io.flow.common.v0.models.MoneyWithBase]
        total <- (__ \ "total").read[io.flow.common.v0.models.MoneyWithBase]
      } yield AllocationLineSummaryLineItem(itemNumber, lineNumber, subtotal, discount, duties, tax, taxSubsidy, dutiesSubsidy, total)
    }

    def jsObjectAllocationLineSummaryLineItem(obj: io.flow.experience.v0.models.AllocationLineSummaryLineItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "item_number" -> play.api.libs.json.JsString(obj.itemNumber),
        "subtotal" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.subtotal),
        "discount" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.discount),
        "duties" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.duties),
        "tax" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.tax),
        "tax_subsidy" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.taxSubsidy),
        "duties_subsidy" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.dutiesSubsidy),
        "total" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.total)
      ) ++ (obj.lineNumber match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("line_number" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceAllocationLineSummaryLineItem: play.api.libs.json.Writes[AllocationLineSummaryLineItem] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AllocationLineSummaryLineItem] {
        def writes(obj: io.flow.experience.v0.models.AllocationLineSummaryLineItem) = {
          jsObjectAllocationLineSummaryLineItem(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationLineSummaryShipping: play.api.libs.json.Reads[AllocationLineSummaryShipping] = {
      for {
        subtotal <- (__ \ "subtotal").read[io.flow.common.v0.models.MoneyWithBase]
        discount <- (__ \ "discount").read[io.flow.common.v0.models.MoneyWithBase]
        duties <- (__ \ "duties").read[io.flow.common.v0.models.MoneyWithBase]
        tax <- (__ \ "tax").read[io.flow.common.v0.models.MoneyWithBase]
        taxSubsidy <- (__ \ "tax_subsidy").read[io.flow.common.v0.models.MoneyWithBase]
        dutiesSubsidy <- (__ \ "duties_subsidy").read[io.flow.common.v0.models.MoneyWithBase]
        total <- (__ \ "total").read[io.flow.common.v0.models.MoneyWithBase]
      } yield AllocationLineSummaryShipping(subtotal, discount, duties, tax, taxSubsidy, dutiesSubsidy, total)
    }

    def jsObjectAllocationLineSummaryShipping(obj: io.flow.experience.v0.models.AllocationLineSummaryShipping): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "subtotal" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.subtotal),
        "discount" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.discount),
        "duties" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.duties),
        "tax" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.tax),
        "tax_subsidy" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.taxSubsidy),
        "duties_subsidy" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.dutiesSubsidy),
        "total" -> io.flow.common.v0.models.json.jsObjectMoneyWithBase(obj.total)
      )
    }

    implicit def jsonWritesExperienceAllocationLineSummaryShipping: play.api.libs.json.Writes[AllocationLineSummaryShipping] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AllocationLineSummaryShipping] {
        def writes(obj: io.flow.experience.v0.models.AllocationLineSummaryShipping) = {
          jsObjectAllocationLineSummaryShipping(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationOrderDetail: play.api.libs.json.Reads[AllocationOrderDetail] = {
      for {
        key <- (__ \ "key").read[io.flow.order.price.v0.models.OrderPriceDetailKey]
        total <- (__ \ "total").read[io.flow.common.v0.models.PriceWithBase]
        included <- (__ \ "included").read[Seq[io.flow.experience.v0.models.AllocationComponent]]
        notIncluded <- (__ \ "not_included").read[Seq[io.flow.experience.v0.models.AllocationComponent]]
      } yield AllocationOrderDetail(key, total, included, notIncluded)
    }

    def jsObjectAllocationOrderDetail(obj: io.flow.experience.v0.models.AllocationOrderDetail): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total),
        "included" -> play.api.libs.json.Json.toJson(obj.included),
        "not_included" -> play.api.libs.json.Json.toJson(obj.notIncluded)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "allocation_order_detail")
    }

    implicit def jsonWritesExperienceAllocationOrderDetail: play.api.libs.json.Writes[AllocationOrderDetail] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AllocationOrderDetail] {
        def writes(obj: io.flow.experience.v0.models.AllocationOrderDetail) = {
          jsObjectAllocationOrderDetail(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationOrderSummary: play.api.libs.json.Reads[AllocationOrderSummary] = {
      for {
        id <- (__ \ "id").read[String]
        number <- (__ \ "number").read[String]
        submittedAt <- (__ \ "submitted_at").readNullable[_root_.org.joda.time.DateTime]
      } yield AllocationOrderSummary(id, number, submittedAt)
    }

    def jsObjectAllocationOrderSummary(obj: io.flow.experience.v0.models.AllocationOrderSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number)
      ) ++ (obj.submittedAt match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("submitted_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      })
    }

    implicit def jsonWritesExperienceAllocationOrderSummary: play.api.libs.json.Writes[AllocationOrderSummary] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AllocationOrderSummary] {
        def writes(obj: io.flow.experience.v0.models.AllocationOrderSummary) = {
          jsObjectAllocationOrderSummary(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationV2: play.api.libs.json.Reads[AllocationV2] = {
      for {
        id <- (__ \ "id").read[String]
        order <- (__ \ "order").read[io.flow.experience.v0.models.AllocationOrderSummary]
        details <- (__ \ "details").read[Seq[io.flow.experience.v0.models.AllocationDetail]]
        total <- (__ \ "total").read[io.flow.catalog.v0.models.LocalizedTotal]
      } yield AllocationV2(id, order, details, total)
    }

    def jsObjectAllocationV2(obj: io.flow.experience.v0.models.AllocationV2): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "order" -> jsObjectAllocationOrderSummary(obj.order),
        "details" -> play.api.libs.json.Json.toJson(obj.details),
        "total" -> io.flow.catalog.v0.models.json.jsObjectLocalizedTotal(obj.total)
      )
    }

    implicit def jsonWritesExperienceAllocationV2: play.api.libs.json.Writes[AllocationV2] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AllocationV2] {
        def writes(obj: io.flow.experience.v0.models.AllocationV2) = {
          jsObjectAllocationV2(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAvailablePromotion: play.api.libs.json.Reads[AvailablePromotion] = {
      for {
        id <- (__ \ "id").read[String]
        shippingConfiguration <- (__ \ "shipping_configuration").read[io.flow.fulfillment.v0.models.ShippingConfigurationReference]
        region <- (__ \ "region").read[io.flow.experience.v0.models.RegionReference]
        promotions <- (__ \ "promotions").read[Seq[io.flow.experience.v0.models.Promotion]]
      } yield AvailablePromotion(id, shippingConfiguration, region, promotions)
    }

    def jsObjectAvailablePromotion(obj: io.flow.experience.v0.models.AvailablePromotion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "shipping_configuration" -> io.flow.fulfillment.v0.models.json.jsObjectShippingConfigurationReference(obj.shippingConfiguration),
        "region" -> jsObjectRegionReference(obj.region),
        "promotions" -> play.api.libs.json.Json.toJson(obj.promotions)
      )
    }

    implicit def jsonWritesExperienceAvailablePromotion: play.api.libs.json.Writes[AvailablePromotion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AvailablePromotion] {
        def writes(obj: io.flow.experience.v0.models.AvailablePromotion) = {
          jsObjectAvailablePromotion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCheckoutAttribute: play.api.libs.json.Reads[CheckoutAttribute] = {
      for {
        id <- (__ \ "id").read[String]
        experience <- (__ \ "experience").read[io.flow.experience.v0.models.ExperienceReference]
        key <- (__ \ "key").read[String]
        name <- (__ \ "name").read[String]
        attributeKeys <- (__ \ "attribute_keys").read[Seq[String]]
        position <- (__ \ "position").read[Long]
      } yield CheckoutAttribute(id, experience, key, name, attributeKeys, position)
    }

    def jsObjectCheckoutAttribute(obj: io.flow.experience.v0.models.CheckoutAttribute): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "experience" -> jsObjectExperienceReference(obj.experience),
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name),
        "attribute_keys" -> play.api.libs.json.Json.toJson(obj.attributeKeys),
        "position" -> play.api.libs.json.JsNumber(obj.position)
      )
    }

    implicit def jsonWritesExperienceCheckoutAttribute: play.api.libs.json.Writes[CheckoutAttribute] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CheckoutAttribute] {
        def writes(obj: io.flow.experience.v0.models.CheckoutAttribute) = {
          jsObjectCheckoutAttribute(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCheckoutAttributeForm: play.api.libs.json.Reads[CheckoutAttributeForm] = {
      for {
        key <- (__ \ "key").read[String]
        name <- (__ \ "name").readNullable[String]
        experienceKey <- (__ \ "experience_key").read[String]
        attributeKeys <- (__ \ "attribute_keys").read[Seq[String]]
        position <- (__ \ "position").readNullable[Long]
      } yield CheckoutAttributeForm(key, name, experienceKey, attributeKeys, position)
    }

    def jsObjectCheckoutAttributeForm(obj: io.flow.experience.v0.models.CheckoutAttributeForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "experience_key" -> play.api.libs.json.JsString(obj.experienceKey),
        "attribute_keys" -> play.api.libs.json.Json.toJson(obj.attributeKeys)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesExperienceCheckoutAttributeForm: play.api.libs.json.Writes[CheckoutAttributeForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CheckoutAttributeForm] {
        def writes(obj: io.flow.experience.v0.models.CheckoutAttributeForm) = {
          jsObjectCheckoutAttributeForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCheckoutItemContent: play.api.libs.json.Reads[CheckoutItemContent] = {
      for {
        item <- (__ \ "item").read[io.flow.catalog.v0.models.Item]
        name <- (__ \ "name").read[String]
        description <- (__ \ "description").readNullable[String]
        attributes <- (__ \ "attributes").read[Seq[io.flow.experience.v0.models.CheckoutItemContentAttribute]]
        image <- (__ \ "image").readNullable[io.flow.catalog.v0.models.Image]
      } yield CheckoutItemContent(item, name, description, attributes, image)
    }

    def jsObjectCheckoutItemContent(obj: io.flow.experience.v0.models.CheckoutItemContent): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "item" -> io.flow.catalog.v0.models.json.jsObjectItem(obj.item),
        "name" -> play.api.libs.json.JsString(obj.name),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.image match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("image" -> io.flow.catalog.v0.models.json.jsObjectImage(x))
      })
    }

    implicit def jsonWritesExperienceCheckoutItemContent: play.api.libs.json.Writes[CheckoutItemContent] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CheckoutItemContent] {
        def writes(obj: io.flow.experience.v0.models.CheckoutItemContent) = {
          jsObjectCheckoutItemContent(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCheckoutItemContentAttribute: play.api.libs.json.Reads[CheckoutItemContentAttribute] = {
      for {
        key <- (__ \ "key").read[String]
        name <- (__ \ "name").read[String]
        value <- (__ \ "value").read[String]
      } yield CheckoutItemContentAttribute(key, name, value)
    }

    def jsObjectCheckoutItemContentAttribute(obj: io.flow.experience.v0.models.CheckoutItemContentAttribute): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name),
        "value" -> play.api.libs.json.JsString(obj.value)
      )
    }

    implicit def jsonWritesExperienceCheckoutItemContentAttribute: play.api.libs.json.Writes[CheckoutItemContentAttribute] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CheckoutItemContentAttribute] {
        def writes(obj: io.flow.experience.v0.models.CheckoutItemContentAttribute) = {
          jsObjectCheckoutItemContentAttribute(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCountryStatus: play.api.libs.json.Reads[CountryStatus] = {
      for {
        id <- (__ \ "id").read[String]
        country <- (__ \ "country").read[String]
        status <- (__ \ "status").read[io.flow.experience.v0.models.ExperienceCountryStatus]
      } yield CountryStatus(id, country, status)
    }

    def jsObjectCountryStatus(obj: io.flow.experience.v0.models.CountryStatus): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "country" -> play.api.libs.json.JsString(obj.country),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      )
    }

    implicit def jsonWritesExperienceCountryStatus: play.api.libs.json.Writes[CountryStatus] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CountryStatus] {
        def writes(obj: io.flow.experience.v0.models.CountryStatus) = {
          jsObjectCountryStatus(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCountryStatusForm: play.api.libs.json.Reads[CountryStatusForm] = {
      (__ \ "status").read[io.flow.experience.v0.models.ExperienceCountryStatus].map { x => new CountryStatusForm(status = x) }
    }

    def jsObjectCountryStatusForm(obj: io.flow.experience.v0.models.CountryStatusForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      )
    }

    implicit def jsonWritesExperienceCountryStatusForm: play.api.libs.json.Writes[CountryStatusForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CountryStatusForm] {
        def writes(obj: io.flow.experience.v0.models.CountryStatusForm) = {
          jsObjectCountryStatusForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCreditPayment: play.api.libs.json.Reads[CreditPayment] = {
      for {
        id <- (__ \ "id").read[String]
        order <- (__ \ "order").read[io.flow.experience.v0.models.ExpandableOrder]
        key <- (__ \ "key").read[String]
        description <- (__ \ "description").read[String]
        value <- (__ \ "value").read[io.flow.common.v0.models.PriceWithBase]
        original <- (__ \ "original").read[io.flow.experience.v0.models.OriginalPrices]
        attributes <- (__ \ "attributes").read[Map[String, String]]
      } yield CreditPayment(id, order, key, description, value, original, attributes)
    }

    def jsObjectCreditPayment(obj: io.flow.experience.v0.models.CreditPayment): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "order" -> jsObjectExpandableOrder(obj.order),
        "key" -> play.api.libs.json.JsString(obj.key),
        "description" -> play.api.libs.json.JsString(obj.description),
        "value" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.value),
        "original" -> jsObjectOriginalPrices(obj.original),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      )
    }

    implicit def jsonWritesExperienceCreditPayment: play.api.libs.json.Writes[CreditPayment] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CreditPayment] {
        def writes(obj: io.flow.experience.v0.models.CreditPayment) = {
          jsObjectCreditPayment(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCreditPaymentError: play.api.libs.json.Reads[CreditPaymentError] = {
      for {
        code <- (__ \ "code").read[io.flow.experience.v0.models.CreditPaymentErrorCode]
        messages <- (__ \ "messages").read[Seq[String]]
        codes <- (__ \ "codes").read[Seq[io.flow.experience.v0.models.CreditPaymentErrorCode]]
      } yield CreditPaymentError(code, messages, codes)
    }

    def jsObjectCreditPaymentError(obj: io.flow.experience.v0.models.CreditPaymentError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages),
        "codes" -> play.api.libs.json.Json.toJson(obj.codes)
      )
    }

    implicit def jsonWritesExperienceCreditPaymentError: play.api.libs.json.Writes[CreditPaymentError] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CreditPaymentError] {
        def writes(obj: io.flow.experience.v0.models.CreditPaymentError) = {
          jsObjectCreditPaymentError(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCreditPaymentForm: play.api.libs.json.Reads[CreditPaymentForm] = {
      for {
        orderNumber <- (__ \ "order_number").read[String]
        description <- (__ \ "description").read[String]
        amount <- (__ \ "amount").read[BigDecimal]
        max <- (__ \ "max").read[BigDecimal]
        currency <- (__ \ "currency").read[String]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield CreditPaymentForm(orderNumber, description, amount, max, currency, attributes)
    }

    def jsObjectCreditPaymentForm(obj: io.flow.experience.v0.models.CreditPaymentForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "order_number" -> play.api.libs.json.JsString(obj.orderNumber),
        "description" -> play.api.libs.json.JsString(obj.description),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "max" -> play.api.libs.json.JsNumber(obj.max),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceCreditPaymentForm: play.api.libs.json.Writes[CreditPaymentForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CreditPaymentForm] {
        def writes(obj: io.flow.experience.v0.models.CreditPaymentForm) = {
          jsObjectCreditPaymentForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceCreditPaymentVersion: play.api.libs.json.Reads[CreditPaymentVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        creditPayment <- (__ \ "credit_payment").read[io.flow.experience.v0.models.CreditPayment]
      } yield CreditPaymentVersion(id, timestamp, `type`, creditPayment)
    }

    def jsObjectCreditPaymentVersion(obj: io.flow.experience.v0.models.CreditPaymentVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "credit_payment" -> jsObjectCreditPayment(obj.creditPayment)
      )
    }

    implicit def jsonWritesExperienceCreditPaymentVersion: play.api.libs.json.Writes[CreditPaymentVersion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.CreditPaymentVersion] {
        def writes(obj: io.flow.experience.v0.models.CreditPaymentVersion) = {
          jsObjectCreditPaymentVersion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceDatetimeWithTimezone: play.api.libs.json.Reads[DatetimeWithTimezone] = {
      for {
        datetime <- (__ \ "datetime").read[_root_.org.joda.time.DateTime]
        timezone <- (__ \ "timezone").read[String]
      } yield DatetimeWithTimezone(datetime, timezone)
    }

    def jsObjectDatetimeWithTimezone(obj: io.flow.experience.v0.models.DatetimeWithTimezone): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "datetime" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.datetime)),
        "timezone" -> play.api.libs.json.JsString(obj.timezone)
      )
    }

    implicit def jsonWritesExperienceDatetimeWithTimezone: play.api.libs.json.Writes[DatetimeWithTimezone] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.DatetimeWithTimezone] {
        def writes(obj: io.flow.experience.v0.models.DatetimeWithTimezone) = {
          jsObjectDatetimeWithTimezone(obj)
        }
      }
    }

    implicit def jsonReadsExperienceDeliveredDutySetting: play.api.libs.json.Reads[DeliveredDutySetting] = {
      for {
        default <- (__ \ "default").read[io.flow.common.v0.models.DeliveredDuty]
        available <- (__ \ "available").read[Seq[io.flow.common.v0.models.DeliveredDuty]]
        display <- (__ \ "display").readNullable[io.flow.experience.v0.models.DeliveredDutyDisplayType]
      } yield DeliveredDutySetting(default, available, display)
    }

    def jsObjectDeliveredDutySetting(obj: io.flow.experience.v0.models.DeliveredDutySetting): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "default" -> play.api.libs.json.JsString(obj.default.toString),
        "available" -> play.api.libs.json.Json.toJson(obj.available)
      ) ++ (obj.display match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("display" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesExperienceDeliveredDutySetting: play.api.libs.json.Writes[DeliveredDutySetting] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.DeliveredDutySetting] {
        def writes(obj: io.flow.experience.v0.models.DeliveredDutySetting) = {
          jsObjectDeliveredDutySetting(obj)
        }
      }
    }

    implicit def jsonReadsExperienceDiscount: play.api.libs.json.Reads[Discount] = {
      for {
        id <- (__ \ "id").read[String]
        code <- (__ \ "code").readNullable[String]
        label <- (__ \ "label").read[String]
        price <- (__ \ "price").read[io.flow.common.v0.models.PriceWithBase]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield Discount(id, code, label, price, attributes)
    }

    def jsObjectDiscount(obj: io.flow.experience.v0.models.Discount): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "label" -> play.api.libs.json.JsString(obj.label),
        "price" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.price)
      ) ++ (obj.code match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("code" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "discount")
    }

    implicit def jsonWritesExperienceDiscount: play.api.libs.json.Writes[Discount] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.Discount] {
        def writes(obj: io.flow.experience.v0.models.Discount) = {
          jsObjectDiscount(obj)
        }
      }
    }

    implicit def jsonReadsExperienceDiscountRule: play.api.libs.json.Reads[DiscountRule] = {
      (__ \ "offers").read[Seq[io.flow.experience.v0.models.DiscountRuleOffer]].map { x => new DiscountRule(offers = x) }
    }

    def jsObjectDiscountRule(obj: io.flow.experience.v0.models.DiscountRule): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "offers" -> play.api.libs.json.Json.toJson(obj.offers)
      )
    }

    implicit def jsonWritesExperienceDiscountRule: play.api.libs.json.Writes[DiscountRule] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.DiscountRule] {
        def writes(obj: io.flow.experience.v0.models.DiscountRule) = {
          jsObjectDiscountRule(obj)
        }
      }
    }

    implicit def jsonReadsExperienceDiscountRuleOffer: play.api.libs.json.Reads[DiscountRuleOffer] = {
      for {
        discount <- (__ \ "discount").read[io.flow.common.v0.models.DiscountOffer]
        entitlement <- (__ \ "entitlement").read[io.flow.experience.v0.models.DiscountRuleEntitlement]
      } yield DiscountRuleOffer(discount, entitlement)
    }

    def jsObjectDiscountRuleOffer(obj: io.flow.experience.v0.models.DiscountRuleOffer): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "discount" -> io.flow.common.v0.models.json.jsObjectDiscountOffer(obj.discount),
        "entitlement" -> jsObjectDiscountRuleEntitlement(obj.entitlement)
      )
    }

    implicit def jsonWritesExperienceDiscountRuleOffer: play.api.libs.json.Writes[DiscountRuleOffer] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.DiscountRuleOffer] {
        def writes(obj: io.flow.experience.v0.models.DiscountRuleOffer) = {
          jsObjectDiscountRuleOffer(obj)
        }
      }
    }

    implicit def jsonReadsExperienceDiscountRuleSettings: play.api.libs.json.Reads[DiscountRuleSettings] = {
      for {
        id <- (__ \ "id").read[String]
        name <- (__ \ "name").read[String]
        fromWithTz <- (__ \ "from_with_tz").read[io.flow.experience.v0.models.DatetimeWithTimezone]
        toWithTz <- (__ \ "to_with_tz").readNullable[io.flow.experience.v0.models.DatetimeWithTimezone]
        status <- (__ \ "status").read[io.flow.experience.v0.models.DiscountRuleStatus]
        experienceKeys <- (__ \ "experience_keys").read[Seq[String]]
        rule <- (__ \ "rule").read[io.flow.experience.v0.models.DiscountRule]
      } yield DiscountRuleSettings(id, name, fromWithTz, toWithTz, status, experienceKeys, rule)
    }

    def jsObjectDiscountRuleSettings(obj: io.flow.experience.v0.models.DiscountRuleSettings): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "name" -> play.api.libs.json.JsString(obj.name),
        "from_with_tz" -> jsObjectDatetimeWithTimezone(obj.fromWithTz),
        "status" -> play.api.libs.json.JsString(obj.status.toString),
        "experience_keys" -> play.api.libs.json.Json.toJson(obj.experienceKeys),
        "rule" -> jsObjectDiscountRule(obj.rule)
      ) ++ (obj.toWithTz match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("to_with_tz" -> jsObjectDatetimeWithTimezone(x))
      })
    }

    implicit def jsonWritesExperienceDiscountRuleSettings: play.api.libs.json.Writes[DiscountRuleSettings] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.DiscountRuleSettings] {
        def writes(obj: io.flow.experience.v0.models.DiscountRuleSettings) = {
          jsObjectDiscountRuleSettings(obj)
        }
      }
    }

    implicit def jsonReadsExperienceDiscountRuleSettingsForm: play.api.libs.json.Reads[DiscountRuleSettingsForm] = {
      for {
        name <- (__ \ "name").read[String]
        fromWithTz <- (__ \ "from_with_tz").read[io.flow.experience.v0.models.DatetimeWithTimezone]
        toWithTz <- (__ \ "to_with_tz").readNullable[io.flow.experience.v0.models.DatetimeWithTimezone]
        experienceKeys <- (__ \ "experience_keys").read[Seq[String]]
        rule <- (__ \ "rule").read[io.flow.experience.v0.models.DiscountRule]
      } yield DiscountRuleSettingsForm(name, fromWithTz, toWithTz, experienceKeys, rule)
    }

    def jsObjectDiscountRuleSettingsForm(obj: io.flow.experience.v0.models.DiscountRuleSettingsForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "from_with_tz" -> jsObjectDatetimeWithTimezone(obj.fromWithTz),
        "experience_keys" -> play.api.libs.json.Json.toJson(obj.experienceKeys),
        "rule" -> jsObjectDiscountRule(obj.rule)
      ) ++ (obj.toWithTz match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("to_with_tz" -> jsObjectDatetimeWithTimezone(x))
      })
    }

    implicit def jsonWritesExperienceDiscountRuleSettingsForm: play.api.libs.json.Writes[DiscountRuleSettingsForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.DiscountRuleSettingsForm] {
        def writes(obj: io.flow.experience.v0.models.DiscountRuleSettingsForm) = {
          jsObjectDiscountRuleSettingsForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceDiscountRuleSubsidyEntitlement: play.api.libs.json.Reads[DiscountRuleSubsidyEntitlement] = {
      (__ \ "targets").read[Seq[io.flow.experience.v0.models.DiscountRuleSubsidyTarget]].map { x => new DiscountRuleSubsidyEntitlement(targets = x) }
    }

    def jsObjectDiscountRuleSubsidyEntitlement(obj: io.flow.experience.v0.models.DiscountRuleSubsidyEntitlement): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "targets" -> play.api.libs.json.Json.toJson(obj.targets)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "subsidy")
    }

    implicit def jsonWritesExperienceDiscountRuleSubsidyEntitlement: play.api.libs.json.Writes[DiscountRuleSubsidyEntitlement] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.DiscountRuleSubsidyEntitlement] {
        def writes(obj: io.flow.experience.v0.models.DiscountRuleSubsidyEntitlement) = {
          jsObjectDiscountRuleSubsidyEntitlement(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperience: play.api.libs.json.Reads[Experience] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        name <- (__ \ "name").read[String]
        deliveredDuty <- (__ \ "delivered_duty").read[io.flow.common.v0.models.DeliveredDuty]
        region <- (__ \ "region").read[io.flow.experience.v0.models.RegionReference]
        country <- (__ \ "country").read[String]
        currency <- (__ \ "currency").read[String]
        language <- (__ \ "language").read[String]
        measurementSystem <- (__ \ "measurement_system").read[io.flow.common.v0.models.MeasurementSystem]
        subcatalog <- (__ \ "subcatalog").read[io.flow.catalog.v0.models.SubcatalogReference]
        position <- (__ \ "position").read[Long]
        settings <- (__ \ "settings").read[io.flow.experience.v0.models.ExperienceSettings]
        status <- (__ \ "status").readNullable[io.flow.experience.v0.models.ExperienceStatus]
      } yield Experience(id, key, name, deliveredDuty, region, country, currency, language, measurementSystem, subcatalog, position, settings, status)
    }

    def jsObjectExperience(obj: io.flow.experience.v0.models.Experience): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name),
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString),
        "region" -> jsObjectRegionReference(obj.region),
        "country" -> play.api.libs.json.JsString(obj.country),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "language" -> play.api.libs.json.JsString(obj.language),
        "measurement_system" -> play.api.libs.json.JsString(obj.measurementSystem.toString),
        "subcatalog" -> io.flow.catalog.v0.models.json.jsObjectSubcatalogReference(obj.subcatalog),
        "position" -> play.api.libs.json.JsNumber(obj.position),
        "settings" -> jsObjectExperienceSettings(obj.settings)
      ) ++ (obj.status match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("status" -> play.api.libs.json.JsString(x.toString))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "experience")
    }

    implicit def jsonWritesExperienceExperience: play.api.libs.json.Writes[Experience] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.Experience] {
        def writes(obj: io.flow.experience.v0.models.Experience) = {
          jsObjectExperience(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceCheckoutConfigurationSettings: play.api.libs.json.Reads[ExperienceCheckoutConfigurationSettings] = {
      (__ \ "configuration").read[io.flow.experience.v0.models.ExperienceConfigurationReference].map { x => new ExperienceCheckoutConfigurationSettings(configuration = x) }
    }

    def jsObjectExperienceCheckoutConfigurationSettings(obj: io.flow.experience.v0.models.ExperienceCheckoutConfigurationSettings): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "configuration" -> jsObjectExperienceConfigurationReference(obj.configuration)
      )
    }

    implicit def jsonWritesExperienceExperienceCheckoutConfigurationSettings: play.api.libs.json.Writes[ExperienceCheckoutConfigurationSettings] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceCheckoutConfigurationSettings] {
        def writes(obj: io.flow.experience.v0.models.ExperienceCheckoutConfigurationSettings) = {
          jsObjectExperienceCheckoutConfigurationSettings(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceCheckoutSettings: play.api.libs.json.Reads[ExperienceCheckoutSettings] = {
      for {
        id <- (__ \ "id").read[String]
        experience <- (__ \ "experience").read[io.flow.experience.v0.models.ExperienceOverview]
        checkoutConfiguration <- (__ \ "checkout_configuration").read[io.flow.experience.v0.models.ExperienceConfigurationReference]
      } yield ExperienceCheckoutSettings(id, experience, checkoutConfiguration)
    }

    def jsObjectExperienceCheckoutSettings(obj: io.flow.experience.v0.models.ExperienceCheckoutSettings): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "experience" -> jsObjectExperienceOverview(obj.experience),
        "checkout_configuration" -> jsObjectExperienceConfigurationReference(obj.checkoutConfiguration)
      )
    }

    implicit def jsonWritesExperienceExperienceCheckoutSettings: play.api.libs.json.Writes[ExperienceCheckoutSettings] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceCheckoutSettings] {
        def writes(obj: io.flow.experience.v0.models.ExperienceCheckoutSettings) = {
          jsObjectExperienceCheckoutSettings(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceCheckoutSettingsForm: play.api.libs.json.Reads[ExperienceCheckoutSettingsForm] = {
      (__ \ "checkout_configuration_id").read[String].map { x => new ExperienceCheckoutSettingsForm(checkoutConfigurationId = x) }
    }

    def jsObjectExperienceCheckoutSettingsForm(obj: io.flow.experience.v0.models.ExperienceCheckoutSettingsForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "checkout_configuration_id" -> play.api.libs.json.JsString(obj.checkoutConfigurationId)
      )
    }

    implicit def jsonWritesExperienceExperienceCheckoutSettingsForm: play.api.libs.json.Writes[ExperienceCheckoutSettingsForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceCheckoutSettingsForm] {
        def writes(obj: io.flow.experience.v0.models.ExperienceCheckoutSettingsForm) = {
          jsObjectExperienceCheckoutSettingsForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceClone: play.api.libs.json.Reads[ExperienceClone] = {
      for {
        id <- (__ \ "id").read[String]
        sourceExperience <- (__ \ "source_experience").read[io.flow.experience.v0.models.ExperienceReference]
        clonedExperience <- (__ \ "cloned_experience").readNullable[io.flow.experience.v0.models.ExperienceReference]
        status <- (__ \ "status").read[io.flow.experience.v0.models.ExperienceCloneStatus]
      } yield ExperienceClone(id, sourceExperience, clonedExperience, status)
    }

    def jsObjectExperienceClone(obj: io.flow.experience.v0.models.ExperienceClone): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "source_experience" -> jsObjectExperienceReference(obj.sourceExperience),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.clonedExperience match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cloned_experience" -> jsObjectExperienceReference(x))
      })
    }

    implicit def jsonWritesExperienceExperienceClone: play.api.libs.json.Writes[ExperienceClone] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceClone] {
        def writes(obj: io.flow.experience.v0.models.ExperienceClone) = {
          jsObjectExperienceClone(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceCloneForm: play.api.libs.json.Reads[ExperienceCloneForm] = {
      (__ \ "name").readNullable[String].map { x => new ExperienceCloneForm(name = x) }
    }

    def jsObjectExperienceCloneForm(obj: io.flow.experience.v0.models.ExperienceCloneForm): play.api.libs.json.JsObject = {
      (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceExperienceCloneForm: play.api.libs.json.Writes[ExperienceCloneForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceCloneForm] {
        def writes(obj: io.flow.experience.v0.models.ExperienceCloneForm) = {
          jsObjectExperienceCloneForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceConfigurationReference: play.api.libs.json.Reads[ExperienceConfigurationReference] = {
      (__ \ "id").read[String].map { x => new ExperienceConfigurationReference(id = x) }
    }

    def jsObjectExperienceConfigurationReference(obj: io.flow.experience.v0.models.ExperienceConfigurationReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesExperienceExperienceConfigurationReference: play.api.libs.json.Writes[ExperienceConfigurationReference] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceConfigurationReference] {
        def writes(obj: io.flow.experience.v0.models.ExperienceConfigurationReference) = {
          jsObjectExperienceConfigurationReference(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceCurrencyFormat: play.api.libs.json.Reads[ExperienceCurrencyFormat] = {
      for {
        symbol <- (__ \ "symbol").read[io.flow.common.v0.models.CurrencySymbolFormat]
        labelFormatters <- (__ \ "label_formatters").read[Seq[io.flow.common.v0.models.CurrencyLabelFormatter]]
      } yield ExperienceCurrencyFormat(symbol, labelFormatters)
    }

    def jsObjectExperienceCurrencyFormat(obj: io.flow.experience.v0.models.ExperienceCurrencyFormat): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "symbol" -> play.api.libs.json.JsString(obj.symbol.toString),
        "label_formatters" -> play.api.libs.json.Json.toJson(obj.labelFormatters)
      )
    }

    implicit def jsonWritesExperienceExperienceCurrencyFormat: play.api.libs.json.Writes[ExperienceCurrencyFormat] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceCurrencyFormat] {
        def writes(obj: io.flow.experience.v0.models.ExperienceCurrencyFormat) = {
          jsObjectExperienceCurrencyFormat(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceCurrencyFormatForm: play.api.libs.json.Reads[ExperienceCurrencyFormatForm] = {
      for {
        symbol <- (__ \ "symbol").read[io.flow.common.v0.models.CurrencySymbolFormat]
        labelFormatters <- (__ \ "label_formatters").read[Seq[io.flow.common.v0.models.CurrencyLabelFormatter]]
      } yield ExperienceCurrencyFormatForm(symbol, labelFormatters)
    }

    def jsObjectExperienceCurrencyFormatForm(obj: io.flow.experience.v0.models.ExperienceCurrencyFormatForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "symbol" -> play.api.libs.json.JsString(obj.symbol.toString),
        "label_formatters" -> play.api.libs.json.Json.toJson(obj.labelFormatters)
      )
    }

    implicit def jsonWritesExperienceExperienceCurrencyFormatForm: play.api.libs.json.Writes[ExperienceCurrencyFormatForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceCurrencyFormatForm] {
        def writes(obj: io.flow.experience.v0.models.ExperienceCurrencyFormatForm) = {
          jsObjectExperienceCurrencyFormatForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceDefaults: play.api.libs.json.Reads[ExperienceDefaults] = {
      for {
        key <- (__ \ "key").read[String]
        name <- (__ \ "name").read[String]
        deliveredDuty <- (__ \ "delivered_duty").read[io.flow.common.v0.models.DeliveredDuty]
        country <- (__ \ "country").read[String]
        currency <- (__ \ "currency").read[String]
        language <- (__ \ "language").read[String]
        measurementSystem <- (__ \ "measurement_system").read[io.flow.common.v0.models.MeasurementSystem]
      } yield ExperienceDefaults(key, name, deliveredDuty, country, currency, language, measurementSystem)
    }

    def jsObjectExperienceDefaults(obj: io.flow.experience.v0.models.ExperienceDefaults): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name),
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString),
        "country" -> play.api.libs.json.JsString(obj.country),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "language" -> play.api.libs.json.JsString(obj.language),
        "measurement_system" -> play.api.libs.json.JsString(obj.measurementSystem.toString)
      )
    }

    implicit def jsonWritesExperienceExperienceDefaults: play.api.libs.json.Writes[ExperienceDefaults] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceDefaults] {
        def writes(obj: io.flow.experience.v0.models.ExperienceDefaults) = {
          jsObjectExperienceDefaults(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceForm: play.api.libs.json.Reads[ExperienceForm] = {
      for {
        regionId <- (__ \ "region_id").read[String]
        name <- (__ \ "name").read[String]
        deliveredDuty <- (__ \ "delivered_duty").readNullable[io.flow.common.v0.models.DeliveredDuty]
        country <- (__ \ "country").readNullable[String]
        currency <- (__ \ "currency").readNullable[String]
        language <- (__ \ "language").readNullable[String]
        key <- (__ \ "key").readNullable[String]
        position <- (__ \ "position").readNullable[Long]
        measurementSystem <- (__ \ "measurement_system").readNullable[io.flow.common.v0.models.MeasurementSystem]
        subcatalogId <- (__ \ "subcatalog_id").readNullable[String]
      } yield ExperienceForm(regionId, name, deliveredDuty, country, currency, language, key, position, measurementSystem, subcatalogId)
    }

    def jsObjectExperienceForm(obj: io.flow.experience.v0.models.ExperienceForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "region_id" -> play.api.libs.json.JsString(obj.regionId),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.deliveredDuty match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("delivered_duty" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.country match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("country" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.language match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("language" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.measurementSystem match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("measurement_system" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.subcatalogId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("subcatalog_id" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceExperienceForm: play.api.libs.json.Writes[ExperienceForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceForm] {
        def writes(obj: io.flow.experience.v0.models.ExperienceForm) = {
          jsObjectExperienceForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceGeo: play.api.libs.json.Reads[ExperienceGeo] = {
      for {
        key <- (__ \ "key").read[String]
        name <- (__ \ "name").read[String]
        region <- (__ \ "region").read[io.flow.experience.v0.models.RegionReference]
        country <- (__ \ "country").read[String]
        currency <- (__ \ "currency").read[String]
        language <- (__ \ "language").read[String]
        measurementSystem <- (__ \ "measurement_system").read[io.flow.common.v0.models.MeasurementSystem]
      } yield ExperienceGeo(key, name, region, country, currency, language, measurementSystem)
    }

    def jsObjectExperienceGeo(obj: io.flow.experience.v0.models.ExperienceGeo): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name),
        "region" -> jsObjectRegionReference(obj.region),
        "country" -> play.api.libs.json.JsString(obj.country),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "language" -> play.api.libs.json.JsString(obj.language),
        "measurement_system" -> play.api.libs.json.JsString(obj.measurementSystem.toString)
      )
    }

    implicit def jsonWritesExperienceExperienceGeo: play.api.libs.json.Writes[ExperienceGeo] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceGeo] {
        def writes(obj: io.flow.experience.v0.models.ExperienceGeo) = {
          jsObjectExperienceGeo(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceLogisticsSettings: play.api.libs.json.Reads[ExperienceLogisticsSettings] = {
      for {
        id <- (__ \ "id").read[String]
        experience <- (__ \ "experience").read[io.flow.experience.v0.models.ExperienceOverview]
        shippingConfiguration <- (__ \ "shipping_configuration").read[io.flow.fulfillment.v0.models.ShippingConfigurationReference]
      } yield ExperienceLogisticsSettings(id, experience, shippingConfiguration)
    }

    def jsObjectExperienceLogisticsSettings(obj: io.flow.experience.v0.models.ExperienceLogisticsSettings): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "experience" -> jsObjectExperienceOverview(obj.experience),
        "shipping_configuration" -> io.flow.fulfillment.v0.models.json.jsObjectShippingConfigurationReference(obj.shippingConfiguration)
      )
    }

    implicit def jsonWritesExperienceExperienceLogisticsSettings: play.api.libs.json.Writes[ExperienceLogisticsSettings] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceLogisticsSettings] {
        def writes(obj: io.flow.experience.v0.models.ExperienceLogisticsSettings) = {
          jsObjectExperienceLogisticsSettings(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceLogisticsSettingsPutForm: play.api.libs.json.Reads[ExperienceLogisticsSettingsPutForm] = {
      (__ \ "shipping_configuration_key").read[String].map { x => new ExperienceLogisticsSettingsPutForm(shippingConfigurationKey = x) }
    }

    def jsObjectExperienceLogisticsSettingsPutForm(obj: io.flow.experience.v0.models.ExperienceLogisticsSettingsPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "shipping_configuration_key" -> play.api.libs.json.JsString(obj.shippingConfigurationKey)
      )
    }

    implicit def jsonWritesExperienceExperienceLogisticsSettingsPutForm: play.api.libs.json.Writes[ExperienceLogisticsSettingsPutForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceLogisticsSettingsPutForm] {
        def writes(obj: io.flow.experience.v0.models.ExperienceLogisticsSettingsPutForm) = {
          jsObjectExperienceLogisticsSettingsPutForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceLogisticsSummary: play.api.libs.json.Reads[ExperienceLogisticsSummary] = {
      for {
        outbound <- (__ \ "outbound").readNullable[io.flow.experience.v0.models.ExperienceLogisticsTierSummary]
        `return` <- (__ \ "return").readNullable[io.flow.experience.v0.models.ExperienceLogisticsTierSummary]
      } yield ExperienceLogisticsSummary(outbound, `return`)
    }

    def jsObjectExperienceLogisticsSummary(obj: io.flow.experience.v0.models.ExperienceLogisticsSummary): play.api.libs.json.JsObject = {
      (obj.outbound match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("outbound" -> jsObjectExperienceLogisticsTierSummary(x))
      }) ++
      (obj.`return` match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("return" -> jsObjectExperienceLogisticsTierSummary(x))
      })
    }

    implicit def jsonWritesExperienceExperienceLogisticsSummary: play.api.libs.json.Writes[ExperienceLogisticsSummary] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceLogisticsSummary] {
        def writes(obj: io.flow.experience.v0.models.ExperienceLogisticsSummary) = {
          jsObjectExperienceLogisticsSummary(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceLogisticsTierSummary: play.api.libs.json.Reads[ExperienceLogisticsTierSummary] = {
      (__ \ "prices").read[io.flow.experience.v0.models.ExperienceLogisticsTierSummaryPrices].map { x => new ExperienceLogisticsTierSummary(prices = x) }
    }

    def jsObjectExperienceLogisticsTierSummary(obj: io.flow.experience.v0.models.ExperienceLogisticsTierSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "prices" -> jsObjectExperienceLogisticsTierSummaryPrices(obj.prices)
      )
    }

    implicit def jsonWritesExperienceExperienceLogisticsTierSummary: play.api.libs.json.Writes[ExperienceLogisticsTierSummary] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceLogisticsTierSummary] {
        def writes(obj: io.flow.experience.v0.models.ExperienceLogisticsTierSummary) = {
          jsObjectExperienceLogisticsTierSummary(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceLogisticsTierSummaryPrices: play.api.libs.json.Reads[ExperienceLogisticsTierSummaryPrices] = {
      (__ \ "minimum").read[io.flow.common.v0.models.Price].map { x => new ExperienceLogisticsTierSummaryPrices(minimum = x) }
    }

    def jsObjectExperienceLogisticsTierSummaryPrices(obj: io.flow.experience.v0.models.ExperienceLogisticsTierSummaryPrices): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "minimum" -> io.flow.common.v0.models.json.jsObjectPrice(obj.minimum)
      )
    }

    implicit def jsonWritesExperienceExperienceLogisticsTierSummaryPrices: play.api.libs.json.Writes[ExperienceLogisticsTierSummaryPrices] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceLogisticsTierSummaryPrices] {
        def writes(obj: io.flow.experience.v0.models.ExperienceLogisticsTierSummaryPrices) = {
          jsObjectExperienceLogisticsTierSummaryPrices(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceOverview: play.api.libs.json.Reads[ExperienceOverview] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
      } yield ExperienceOverview(id, key)
    }

    def jsObjectExperienceOverview(obj: io.flow.experience.v0.models.ExperienceOverview): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonWritesExperienceExperienceOverview: play.api.libs.json.Writes[ExperienceOverview] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceOverview] {
        def writes(obj: io.flow.experience.v0.models.ExperienceOverview) = {
          jsObjectExperienceOverview(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperiencePaymentMethodRule: play.api.libs.json.Reads[ExperiencePaymentMethodRule] = {
      for {
        experienceKey <- (__ \ "experience_key").read[String]
        paymentMethodRules <- (__ \ "payment_method_rules").read[Seq[io.flow.experience.v0.models.PaymentMethodRule]]
      } yield ExperiencePaymentMethodRule(experienceKey, paymentMethodRules)
    }

    def jsObjectExperiencePaymentMethodRule(obj: io.flow.experience.v0.models.ExperiencePaymentMethodRule): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "experience_key" -> play.api.libs.json.JsString(obj.experienceKey),
        "payment_method_rules" -> play.api.libs.json.Json.toJson(obj.paymentMethodRules)
      )
    }

    implicit def jsonWritesExperienceExperiencePaymentMethodRule: play.api.libs.json.Writes[ExperiencePaymentMethodRule] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePaymentMethodRule] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePaymentMethodRule) = {
          jsObjectExperiencePaymentMethodRule(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperiencePaymentMethodRuleForm: play.api.libs.json.Reads[ExperiencePaymentMethodRuleForm] = {
      for {
        paymentMethodId <- (__ \ "payment_method_id").read[String]
        tags <- (__ \ "tags").read[Seq[io.flow.experience.v0.models.ExperiencePaymentMethodTag]]
        q <- (__ \ "q").readNullable[String]
      } yield ExperiencePaymentMethodRuleForm(paymentMethodId, tags, q)
    }

    def jsObjectExperiencePaymentMethodRuleForm(obj: io.flow.experience.v0.models.ExperiencePaymentMethodRuleForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "payment_method_id" -> play.api.libs.json.JsString(obj.paymentMethodId),
        "tags" -> play.api.libs.json.Json.toJson(obj.tags)
      ) ++ (obj.q match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("q" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceExperiencePaymentMethodRuleForm: play.api.libs.json.Writes[ExperiencePaymentMethodRuleForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePaymentMethodRuleForm] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePaymentMethodRuleForm) = {
          jsObjectExperiencePaymentMethodRuleForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperiencePriceBookMapping: play.api.libs.json.Reads[ExperiencePriceBookMapping] = {
      for {
        id <- (__ \ "id").read[String]
        experience <- (__ \ "experience").read[io.flow.experience.v0.models.ExperienceReference]
        priceBook <- (__ \ "price_book").read[io.flow.price.v0.models.PriceBookReference]
        position <- (__ \ "position").read[Long]
      } yield ExperiencePriceBookMapping(id, experience, priceBook, position)
    }

    def jsObjectExperiencePriceBookMapping(obj: io.flow.experience.v0.models.ExperiencePriceBookMapping): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "experience" -> jsObjectExperienceReference(obj.experience),
        "price_book" -> io.flow.price.v0.models.json.jsObjectPriceBookReference(obj.priceBook),
        "position" -> play.api.libs.json.JsNumber(obj.position)
      )
    }

    implicit def jsonWritesExperienceExperiencePriceBookMapping: play.api.libs.json.Writes[ExperiencePriceBookMapping] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePriceBookMapping] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePriceBookMapping) = {
          jsObjectExperiencePriceBookMapping(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperiencePriceBookMappingForm: play.api.libs.json.Reads[ExperiencePriceBookMappingForm] = {
      for {
        priceBookKey <- (__ \ "price_book_key").read[String]
        position <- (__ \ "position").readNullable[Long]
      } yield ExperiencePriceBookMappingForm(priceBookKey, position)
    }

    def jsObjectExperiencePriceBookMappingForm(obj: io.flow.experience.v0.models.ExperiencePriceBookMappingForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "price_book_key" -> play.api.libs.json.JsString(obj.priceBookKey)
      ) ++ (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesExperienceExperiencePriceBookMappingForm: play.api.libs.json.Writes[ExperiencePriceBookMappingForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePriceBookMappingForm] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePriceBookMappingForm) = {
          jsObjectExperiencePriceBookMappingForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperiencePriceBookMappingPutForm: play.api.libs.json.Reads[ExperiencePriceBookMappingPutForm] = {
      (__ \ "price_books").read[Seq[io.flow.experience.v0.models.ExperiencePriceBookMappingForm]].map { x => new ExperiencePriceBookMappingPutForm(priceBooks = x) }
    }

    def jsObjectExperiencePriceBookMappingPutForm(obj: io.flow.experience.v0.models.ExperiencePriceBookMappingPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "price_books" -> play.api.libs.json.Json.toJson(obj.priceBooks)
      )
    }

    implicit def jsonWritesExperienceExperiencePriceBookMappingPutForm: play.api.libs.json.Writes[ExperiencePriceBookMappingPutForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePriceBookMappingPutForm] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePriceBookMappingPutForm) = {
          jsObjectExperiencePriceBookMappingPutForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperiencePriceConversion: play.api.libs.json.Reads[ExperiencePriceConversion] = {
      for {
        request <- (__ \ "request").read[io.flow.experience.v0.models.ExperiencePriceConversionRequest]
        price <- (__ \ "price").read[io.flow.common.v0.models.PriceWithBase]
      } yield ExperiencePriceConversion(request, price)
    }

    def jsObjectExperiencePriceConversion(obj: io.flow.experience.v0.models.ExperiencePriceConversion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "request" -> jsObjectExperiencePriceConversionRequest(obj.request),
        "price" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.price)
      )
    }

    implicit def jsonWritesExperienceExperiencePriceConversion: play.api.libs.json.Writes[ExperiencePriceConversion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePriceConversion] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePriceConversion) = {
          jsObjectExperiencePriceConversion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperiencePriceConversionRequest: play.api.libs.json.Reads[ExperiencePriceConversionRequest] = {
      for {
        value <- (__ \ "value").read[BigDecimal]
        base <- (__ \ "base").read[String]
        local <- (__ \ "local").read[String]
      } yield ExperiencePriceConversionRequest(value, base, local)
    }

    def jsObjectExperiencePriceConversionRequest(obj: io.flow.experience.v0.models.ExperiencePriceConversionRequest): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "value" -> play.api.libs.json.JsNumber(obj.value),
        "base" -> play.api.libs.json.JsString(obj.base),
        "local" -> play.api.libs.json.JsString(obj.local)
      )
    }

    implicit def jsonWritesExperienceExperiencePriceConversionRequest: play.api.libs.json.Writes[ExperiencePriceConversionRequest] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePriceConversionRequest] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePriceConversionRequest) = {
          jsObjectExperiencePriceConversionRequest(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperiencePriceConversionResponse: play.api.libs.json.Reads[ExperiencePriceConversionResponse] = {
      (__ \ "prices").read[Seq[io.flow.experience.v0.models.ExperiencePriceConversion]].map { x => new ExperiencePriceConversionResponse(prices = x) }
    }

    def jsObjectExperiencePriceConversionResponse(obj: io.flow.experience.v0.models.ExperiencePriceConversionResponse): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "prices" -> play.api.libs.json.Json.toJson(obj.prices)
      )
    }

    implicit def jsonWritesExperienceExperiencePriceConversionResponse: play.api.libs.json.Writes[ExperiencePriceConversionResponse] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePriceConversionResponse] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePriceConversionResponse) = {
          jsObjectExperiencePriceConversionResponse(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperiencePriceFacetConversion: play.api.libs.json.Reads[ExperiencePriceFacetConversion] = {
      for {
        request <- (__ \ "request").read[io.flow.experience.v0.models.ExperiencePriceFacetConversionRequest]
        price <- (__ \ "price").read[io.flow.common.v0.models.PriceWithBase]
      } yield ExperiencePriceFacetConversion(request, price)
    }

    def jsObjectExperiencePriceFacetConversion(obj: io.flow.experience.v0.models.ExperiencePriceFacetConversion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "request" -> jsObjectExperiencePriceFacetConversionRequest(obj.request),
        "price" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.price)
      )
    }

    implicit def jsonWritesExperienceExperiencePriceFacetConversion: play.api.libs.json.Writes[ExperiencePriceFacetConversion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePriceFacetConversion] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePriceFacetConversion) = {
          jsObjectExperiencePriceFacetConversion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperiencePriceFacetConversionRequest: play.api.libs.json.Reads[ExperiencePriceFacetConversionRequest] = {
      for {
        boundary <- (__ \ "boundary").read[io.flow.experience.v0.models.PriceFacetBoundary]
        value <- (__ \ "value").read[BigDecimal]
        base <- (__ \ "base").read[String]
        local <- (__ \ "local").read[String]
      } yield ExperiencePriceFacetConversionRequest(boundary, value, base, local)
    }

    def jsObjectExperiencePriceFacetConversionRequest(obj: io.flow.experience.v0.models.ExperiencePriceFacetConversionRequest): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "boundary" -> play.api.libs.json.JsString(obj.boundary.toString),
        "value" -> play.api.libs.json.JsNumber(obj.value),
        "base" -> play.api.libs.json.JsString(obj.base),
        "local" -> play.api.libs.json.JsString(obj.local)
      )
    }

    implicit def jsonWritesExperienceExperiencePriceFacetConversionRequest: play.api.libs.json.Writes[ExperiencePriceFacetConversionRequest] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePriceFacetConversionRequest] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePriceFacetConversionRequest) = {
          jsObjectExperiencePriceFacetConversionRequest(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperiencePriceFacetConversionResponse: play.api.libs.json.Reads[ExperiencePriceFacetConversionResponse] = {
      (__ \ "facets").read[Seq[io.flow.experience.v0.models.ExperiencePriceFacetConversion]].map { x => new ExperiencePriceFacetConversionResponse(facets = x) }
    }

    def jsObjectExperiencePriceFacetConversionResponse(obj: io.flow.experience.v0.models.ExperiencePriceFacetConversionResponse): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "facets" -> play.api.libs.json.Json.toJson(obj.facets)
      )
    }

    implicit def jsonWritesExperienceExperiencePriceFacetConversionResponse: play.api.libs.json.Writes[ExperiencePriceFacetConversionResponse] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperiencePriceFacetConversionResponse] {
        def writes(obj: io.flow.experience.v0.models.ExperiencePriceFacetConversionResponse) = {
          jsObjectExperiencePriceFacetConversionResponse(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceReference: play.api.libs.json.Reads[ExperienceReference] = {
      (__ \ "key").read[String].map { x => new ExperienceReference(key = x) }
    }

    def jsObjectExperienceReference(obj: io.flow.experience.v0.models.ExperienceReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "experience_reference")
    }

    implicit def jsonWritesExperienceExperienceReference: play.api.libs.json.Writes[ExperienceReference] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceReference] {
        def writes(obj: io.flow.experience.v0.models.ExperienceReference) = {
          jsObjectExperienceReference(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceSettings: play.api.libs.json.Reads[ExperienceSettings] = {
      for {
        deliveredDuty <- (__ \ "delivered_duty").read[io.flow.experience.v0.models.DeliveredDutySetting]
        pricingSettings <- (__ \ "pricing_settings").readNullable[io.flow.experience.v0.models.PricingSettings]
        logisticsSettings <- (__ \ "logistics_settings").readNullable[io.flow.experience.v0.models.LogisticsSettings]
        checkoutSettings <- (__ \ "checkout_settings").readNullable[io.flow.experience.v0.models.ExperienceCheckoutConfigurationSettings]
      } yield ExperienceSettings(deliveredDuty, pricingSettings, logisticsSettings, checkoutSettings)
    }

    def jsObjectExperienceSettings(obj: io.flow.experience.v0.models.ExperienceSettings): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "delivered_duty" -> jsObjectDeliveredDutySetting(obj.deliveredDuty)
      ) ++ (obj.pricingSettings match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("pricing_settings" -> jsObjectPricingSettings(x))
      }) ++
      (obj.logisticsSettings match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("logistics_settings" -> jsObjectLogisticsSettings(x))
      }) ++
      (obj.checkoutSettings match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("checkout_settings" -> jsObjectExperienceCheckoutConfigurationSettings(x))
      })
    }

    implicit def jsonWritesExperienceExperienceSettings: play.api.libs.json.Writes[ExperienceSettings] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceSettings] {
        def writes(obj: io.flow.experience.v0.models.ExperienceSettings) = {
          jsObjectExperienceSettings(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceStatusForm: play.api.libs.json.Reads[ExperienceStatusForm] = {
      (__ \ "status").read[io.flow.experience.v0.models.ExperienceStatus].map { x => new ExperienceStatusForm(status = x) }
    }

    def jsObjectExperienceStatusForm(obj: io.flow.experience.v0.models.ExperienceStatusForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      )
    }

    implicit def jsonWritesExperienceExperienceStatusForm: play.api.libs.json.Writes[ExperienceStatusForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceStatusForm] {
        def writes(obj: io.flow.experience.v0.models.ExperienceStatusForm) = {
          jsObjectExperienceStatusForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExperienceVersion: play.api.libs.json.Reads[ExperienceVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        experience <- (__ \ "experience").read[io.flow.experience.v0.models.Experience]
      } yield ExperienceVersion(id, timestamp, `type`, experience)
    }

    def jsObjectExperienceVersion(obj: io.flow.experience.v0.models.ExperienceVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "experience" -> jsObjectExperience(obj.experience)
      )
    }

    implicit def jsonWritesExperienceExperienceVersion: play.api.libs.json.Writes[ExperienceVersion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExperienceVersion] {
        def writes(obj: io.flow.experience.v0.models.ExperienceVersion) = {
          jsObjectExperienceVersion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceFreeShipping: play.api.libs.json.Reads[FreeShipping] = {
      for {
        trigger <- (__ \ "trigger").read[io.flow.experience.v0.models.PromotionTrigger]
        max <- (__ \ "max").readNullable[io.flow.common.v0.models.Price]
      } yield FreeShipping(trigger, max)
    }

    def jsObjectFreeShipping(obj: io.flow.experience.v0.models.FreeShipping): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "trigger" -> jsObjectPromotionTrigger(obj.trigger)
      ) ++ (obj.max match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("max" -> io.flow.common.v0.models.json.jsObjectPrice(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "free_shipping")
    }

    implicit def jsonWritesExperienceFreeShipping: play.api.libs.json.Writes[FreeShipping] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.FreeShipping] {
        def writes(obj: io.flow.experience.v0.models.FreeShipping) = {
          jsObjectFreeShipping(obj)
        }
      }
    }

    implicit def jsonReadsExperienceFreeShippingOrderPromotion: play.api.libs.json.Reads[FreeShippingOrderPromotion] = {
      for {
        id <- (__ \ "id").read[String]
        order <- (__ \ "order").read[io.flow.experience.v0.models.ExpandableOrder]
        key <- (__ \ "key").read[String]
        trigger <- (__ \ "trigger").read[io.flow.experience.v0.models.OrderPromotionTrigger]
        max <- (__ \ "max").readNullable[io.flow.common.v0.models.Price]
        attributes <- (__ \ "attributes").read[Map[String, String]]
      } yield FreeShippingOrderPromotion(id, order, key, trigger, max, attributes)
    }

    def jsObjectFreeShippingOrderPromotion(obj: io.flow.experience.v0.models.FreeShippingOrderPromotion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "order" -> jsObjectExpandableOrder(obj.order),
        "key" -> play.api.libs.json.JsString(obj.key),
        "trigger" -> jsObjectOrderPromotionTrigger(obj.trigger),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      ) ++ (obj.max match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("max" -> io.flow.common.v0.models.json.jsObjectPrice(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "free_shipping_order_promotion")
    }

    implicit def jsonWritesExperienceFreeShippingOrderPromotion: play.api.libs.json.Writes[FreeShippingOrderPromotion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.FreeShippingOrderPromotion] {
        def writes(obj: io.flow.experience.v0.models.FreeShippingOrderPromotion) = {
          jsObjectFreeShippingOrderPromotion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceFreeShippingOrderPromotionForm: play.api.libs.json.Reads[FreeShippingOrderPromotionForm] = {
      for {
        trigger <- (__ \ "trigger").read[io.flow.experience.v0.models.PromotionTriggerForm]
        max <- (__ \ "max").readNullable[io.flow.common.v0.models.PriceForm]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield FreeShippingOrderPromotionForm(trigger, max, attributes)
    }

    def jsObjectFreeShippingOrderPromotionForm(obj: io.flow.experience.v0.models.FreeShippingOrderPromotionForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "trigger" -> jsObjectPromotionTriggerForm(obj.trigger)
      ) ++ (obj.max match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("max" -> io.flow.common.v0.models.json.jsObjectPriceForm(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "free_shipping_order_promotion_form")
    }

    implicit def jsonWritesExperienceFreeShippingOrderPromotionForm: play.api.libs.json.Writes[FreeShippingOrderPromotionForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.FreeShippingOrderPromotionForm] {
        def writes(obj: io.flow.experience.v0.models.FreeShippingOrderPromotionForm) = {
          jsObjectFreeShippingOrderPromotionForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceItemMargin: play.api.libs.json.Reads[ItemMargin] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
        name <- (__ \ "name").read[String]
        q <- (__ \ "q").read[String]
        fixed <- (__ \ "fixed").read[BigDecimal]
        percent <- (__ \ "percent").read[BigDecimal]
        position <- (__ \ "position").read[Long]
        experience <- (__ \ "experience").readNullable[io.flow.experience.v0.models.ExperienceReference]
      } yield ItemMargin(id, key, name, q, fixed, percent, position, experience)
    }

    def jsObjectItemMargin(obj: io.flow.experience.v0.models.ItemMargin): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name),
        "q" -> play.api.libs.json.JsString(obj.q),
        "fixed" -> play.api.libs.json.JsNumber(obj.fixed),
        "percent" -> play.api.libs.json.JsNumber(obj.percent),
        "position" -> play.api.libs.json.JsNumber(obj.position)
      ) ++ (obj.experience match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("experience" -> jsObjectExperienceReference(x))
      })
    }

    implicit def jsonWritesExperienceItemMargin: play.api.libs.json.Writes[ItemMargin] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ItemMargin] {
        def writes(obj: io.flow.experience.v0.models.ItemMargin) = {
          jsObjectItemMargin(obj)
        }
      }
    }

    implicit def jsonReadsExperienceItemMarginPostForm: play.api.libs.json.Reads[ItemMarginPostForm] = {
      for {
        name <- (__ \ "name").read[String]
        q <- (__ \ "q").read[String]
        key <- (__ \ "key").readNullable[String]
        fixed <- (__ \ "fixed").readNullable[BigDecimal]
        percent <- (__ \ "percent").readNullable[BigDecimal]
        position <- (__ \ "position").readNullable[Long]
      } yield ItemMarginPostForm(name, q, key, fixed, percent, position)
    }

    def jsObjectItemMarginPostForm(obj: io.flow.experience.v0.models.ItemMarginPostForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "q" -> play.api.libs.json.JsString(obj.q)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.fixed match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("fixed" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.percent match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("percent" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesExperienceItemMarginPostForm: play.api.libs.json.Writes[ItemMarginPostForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ItemMarginPostForm] {
        def writes(obj: io.flow.experience.v0.models.ItemMarginPostForm) = {
          jsObjectItemMarginPostForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceItemMarginPutForm: play.api.libs.json.Reads[ItemMarginPutForm] = {
      for {
        name <- (__ \ "name").read[String]
        q <- (__ \ "q").read[String]
        fixed <- (__ \ "fixed").readNullable[BigDecimal]
        percent <- (__ \ "percent").readNullable[BigDecimal]
        position <- (__ \ "position").readNullable[Long]
      } yield ItemMarginPutForm(name, q, fixed, percent, position)
    }

    def jsObjectItemMarginPutForm(obj: io.flow.experience.v0.models.ItemMarginPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "q" -> play.api.libs.json.JsString(obj.q)
      ) ++ (obj.fixed match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("fixed" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.percent match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("percent" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesExperienceItemMarginPutForm: play.api.libs.json.Writes[ItemMarginPutForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ItemMarginPutForm] {
        def writes(obj: io.flow.experience.v0.models.ItemMarginPutForm) = {
          jsObjectItemMarginPutForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceItemMarginVersion: play.api.libs.json.Reads[ItemMarginVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        itemMargin <- (__ \ "item_margin").read[io.flow.experience.v0.models.ItemMargin]
      } yield ItemMarginVersion(id, timestamp, `type`, itemMargin)
    }

    def jsObjectItemMarginVersion(obj: io.flow.experience.v0.models.ItemMarginVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "item_margin" -> jsObjectItemMargin(obj.itemMargin)
      )
    }

    implicit def jsonWritesExperienceItemMarginVersion: play.api.libs.json.Writes[ItemMarginVersion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ItemMarginVersion] {
        def writes(obj: io.flow.experience.v0.models.ItemMarginVersion) = {
          jsObjectItemMarginVersion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceLine: play.api.libs.json.Reads[Line] = {
      for {
        id <- (__ \ "id").readNullable[String]
        itemNumber <- (__ \ "item_number").read[String]
        quantity <- (__ \ "quantity").read[Long]
        price <- (__ \ "price").read[io.flow.common.v0.models.PriceWithBase]
        total <- (__ \ "total").read[io.flow.common.v0.models.PriceWithBase]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield Line(id, itemNumber, quantity, price, total, attributes)
    }

    def jsObjectLine(obj: io.flow.experience.v0.models.Line): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "item_number" -> play.api.libs.json.JsString(obj.itemNumber),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "price" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.price),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total)
      ) ++ (obj.id match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceLine: play.api.libs.json.Writes[Line] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.Line] {
        def writes(obj: io.flow.experience.v0.models.Line) = {
          jsObjectLine(obj)
        }
      }
    }

    implicit def jsonReadsExperienceLocalizedLineItem: play.api.libs.json.Reads[LocalizedLineItem] = {
      for {
        id <- (__ \ "id").readNullable[String]
        number <- (__ \ "number").read[String]
        name <- (__ \ "name").read[String]
        quantity <- (__ \ "quantity").read[Long]
        center <- (__ \ "center").readNullable[String]
        price <- (__ \ "price").readNullable[io.flow.common.v0.models.Money]
        discount <- (__ \ "discount").readNullable[io.flow.experience.v0.models.LocalizedLineItemDiscount]
        discounts <- (__ \ "discounts").readNullable[Seq[io.flow.experience.v0.models.LocalizedLineItemDiscount]]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        local <- (__ \ "local").read[io.flow.catalog.v0.models.Local]
        shipmentEstimate <- (__ \ "shipment_estimate").readNullable[io.flow.common.v0.models.DatetimeRange]
        priceSource <- (__ \ "price_source").readNullable[io.flow.common.v0.models.PriceSource]
      } yield LocalizedLineItem(id, number, name, quantity, center, price, discount, discounts, attributes, local, shipmentEstimate, priceSource)
    }

    def jsObjectLocalizedLineItem(obj: io.flow.experience.v0.models.LocalizedLineItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "name" -> play.api.libs.json.JsString(obj.name),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "local" -> io.flow.catalog.v0.models.json.jsObjectLocal(obj.local)
      ) ++ (obj.id match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.center match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("center" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.price match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("price" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> jsObjectLocalizedLineItemDiscount(x))
      }) ++
      (obj.discounts match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discounts" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.shipmentEstimate match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("shipment_estimate" -> io.flow.common.v0.models.json.jsObjectDatetimeRange(x))
      }) ++
      (obj.priceSource match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("price_source" -> io.flow.common.v0.models.json.jsObjectPriceSource(x))
      })
    }

    implicit def jsonWritesExperienceLocalizedLineItem: play.api.libs.json.Writes[LocalizedLineItem] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.LocalizedLineItem] {
        def writes(obj: io.flow.experience.v0.models.LocalizedLineItem) = {
          jsObjectLocalizedLineItem(obj)
        }
      }
    }

    implicit def jsonReadsExperienceLocalizedLineItemDiscount: play.api.libs.json.Reads[LocalizedLineItemDiscount] = {
      for {
        amount <- (__ \ "amount").read[Double]
        currency <- (__ \ "currency").read[String]
        label <- (__ \ "label").readNullable[String]
        base <- (__ \ "base").readNullable[io.flow.common.v0.models.Price]
        requested <- (__ \ "requested").readNullable[io.flow.common.v0.models.Money]
        discountLabel <- (__ \ "discount_label").readNullable[String]
      } yield LocalizedLineItemDiscount(amount, currency, label, base, requested, discountLabel)
    }

    def jsObjectLocalizedLineItemDiscount(obj: io.flow.experience.v0.models.LocalizedLineItemDiscount): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      ) ++ (obj.label match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("label" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.base match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("base" -> io.flow.common.v0.models.json.jsObjectPrice(x))
      }) ++
      (obj.requested match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("requested" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.discountLabel match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount_label" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceLocalizedLineItemDiscount: play.api.libs.json.Writes[LocalizedLineItemDiscount] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.LocalizedLineItemDiscount] {
        def writes(obj: io.flow.experience.v0.models.LocalizedLineItemDiscount) = {
          jsObjectLocalizedLineItemDiscount(obj)
        }
      }
    }

    implicit def jsonReadsExperienceLogisticsSettings: play.api.libs.json.Reads[LogisticsSettings] = {
      (__ \ "shipping_configuration").read[io.flow.fulfillment.v0.models.ShippingConfigurationReference].map { x => new LogisticsSettings(shippingConfiguration = x) }
    }

    def jsObjectLogisticsSettings(obj: io.flow.experience.v0.models.LogisticsSettings): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "shipping_configuration" -> io.flow.fulfillment.v0.models.json.jsObjectShippingConfigurationReference(obj.shippingConfiguration)
      )
    }

    implicit def jsonWritesExperienceLogisticsSettings: play.api.libs.json.Writes[LogisticsSettings] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.LogisticsSettings] {
        def writes(obj: io.flow.experience.v0.models.LogisticsSettings) = {
          jsObjectLogisticsSettings(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrder: play.api.libs.json.Reads[Order] = {
      for {
        id <- (__ \ "id").read[String]
        number <- (__ \ "number").read[String]
        orderType <- (__ \ "order_type").readWithDefault[io.flow.experience.v0.models.OrderType](io.flow.experience.v0.models.OrderType.Standard)
        merchantOfRecord <- (__ \ "merchant_of_record").readNullable[io.flow.common.v0.models.OrderMerchantOfRecord]
        experience <- (__ \ "experience").readNullable[io.flow.experience.v0.models.ExpandableExperience]
        customer <- (__ \ "customer").read[io.flow.common.v0.models.OrderCustomer]
        deliveredDuty <- (__ \ "delivered_duty").read[io.flow.common.v0.models.DeliveredDuty]
        destination <- (__ \ "destination").read[io.flow.experience.v0.models.OrderAddress]
        expiresAt <- (__ \ "expires_at").read[_root_.org.joda.time.DateTime]
        items <- (__ \ "items").read[Seq[io.flow.experience.v0.models.LocalizedLineItem]]
        deliveries <- (__ \ "deliveries").read[Seq[io.flow.fulfillment.v0.models.Delivery]]
        selections <- (__ \ "selections").read[Seq[String]]
        prices <- (__ \ "prices").read[Seq[io.flow.order.price.v0.models.OrderPriceDetail]]
        total <- (__ \ "total").read[io.flow.catalog.v0.models.LocalizedTotal]
        attributes <- (__ \ "attributes").read[Map[String, String]]
        submittedAt <- (__ \ "submitted_at").readNullable[_root_.org.joda.time.DateTime]
        lines <- (__ \ "lines").readNullable[Seq[io.flow.experience.v0.models.Line]]
        identifiers <- (__ \ "identifiers").readNullable[Seq[String]]
        promotions <- (__ \ "promotions").readNullable[io.flow.experience.v0.models.Promotions]
        payments <- (__ \ "payments").readNullable[Seq[io.flow.experience.v0.models.OrderPayment]]
        balance <- (__ \ "balance").readNullable[io.flow.catalog.v0.models.LocalizedTotal]
        rules <- (__ \ "rules").readNullable[io.flow.experience.v0.models.OrderRulesSummary]
        taxRegistration <- (__ \ "tax_registration").readNullable[io.flow.harmonization.v0.models.TaxRegistration]
        geo <- (__ \ "geo").readNullable[io.flow.experience.v0.models.OrderGeo]
      } yield Order(id, number, orderType, merchantOfRecord, experience, customer, deliveredDuty, destination, expiresAt, items, deliveries, selections, prices, total, attributes, submittedAt, lines, identifiers, promotions, payments, balance, rules, taxRegistration, geo)
    }

    def jsObjectOrder(obj: io.flow.experience.v0.models.Order): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number),
        "order_type" -> play.api.libs.json.JsString(obj.orderType.toString),
        "customer" -> io.flow.common.v0.models.json.jsObjectOrderCustomer(obj.customer),
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString),
        "destination" -> jsObjectOrderAddress(obj.destination),
        "expires_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.expiresAt)),
        "items" -> play.api.libs.json.Json.toJson(obj.items),
        "deliveries" -> play.api.libs.json.Json.toJson(obj.deliveries),
        "selections" -> play.api.libs.json.Json.toJson(obj.selections),
        "prices" -> play.api.libs.json.Json.toJson(obj.prices),
        "total" -> io.flow.catalog.v0.models.json.jsObjectLocalizedTotal(obj.total),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      ) ++ (obj.merchantOfRecord match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("merchant_of_record" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.experience match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("experience" -> jsObjectExpandableExperience(x))
      }) ++
      (obj.submittedAt match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("submitted_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      }) ++
      (obj.lines match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("lines" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.identifiers match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("identifiers" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.promotions match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("promotions" -> jsObjectPromotions(x))
      }) ++
      (obj.payments match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("payments" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.balance match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("balance" -> io.flow.catalog.v0.models.json.jsObjectLocalizedTotal(x))
      }) ++
      (obj.rules match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("rules" -> jsObjectOrderRulesSummary(x))
      }) ++
      (obj.taxRegistration match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tax_registration" -> io.flow.harmonization.v0.models.json.jsObjectTaxRegistration(x))
      }) ++
      (obj.geo match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("geo" -> jsObjectOrderGeo(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "order")
    }

    implicit def jsonWritesExperienceOrder: play.api.libs.json.Writes[Order] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.Order] {
        def writes(obj: io.flow.experience.v0.models.Order) = {
          jsObjectOrder(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderAddress: play.api.libs.json.Reads[OrderAddress] = {
      for {
        text <- (__ \ "text").readNullable[String]
        streets <- (__ \ "streets").readNullable[Seq[String]]
        city <- (__ \ "city").readNullable[String]
        province <- (__ \ "province").readNullable[String]
        postal <- (__ \ "postal").readNullable[String]
        country <- (__ \ "country").readNullable[String]
        latitude <- (__ \ "latitude").readNullable[String]
        longitude <- (__ \ "longitude").readNullable[String]
        contact <- (__ \ "contact").readNullable[io.flow.common.v0.models.Contact]
      } yield OrderAddress(text, streets, city, province, postal, country, latitude, longitude, contact)
    }

    def jsObjectOrderAddress(obj: io.flow.experience.v0.models.OrderAddress): play.api.libs.json.JsObject = {
      (obj.text match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("text" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.streets match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("streets" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.city match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("city" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.province match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("province" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.postal match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("postal" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.country match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("country" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.latitude match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("latitude" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.longitude match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("longitude" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.contact match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("contact" -> io.flow.common.v0.models.json.jsObjectContact(x))
      })
    }

    implicit def jsonWritesExperienceOrderAddress: play.api.libs.json.Writes[OrderAddress] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderAddress] {
        def writes(obj: io.flow.experience.v0.models.OrderAddress) = {
          jsObjectOrderAddress(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderBuilder: play.api.libs.json.Reads[OrderBuilder] = {
      for {
        order <- (__ \ "order").readNullable[io.flow.experience.v0.models.Order]
        errors <- (__ \ "errors").readNullable[Seq[io.flow.experience.v0.models.OrderError]]
      } yield OrderBuilder(order, errors)
    }

    def jsObjectOrderBuilder(obj: io.flow.experience.v0.models.OrderBuilder): play.api.libs.json.JsObject = {
      (obj.order match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("order" -> jsObjectOrder(x))
      }) ++
      (obj.errors match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("errors" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceOrderBuilder: play.api.libs.json.Writes[OrderBuilder] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderBuilder] {
        def writes(obj: io.flow.experience.v0.models.OrderBuilder) = {
          jsObjectOrderBuilder(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderBuilderAttributesForm: play.api.libs.json.Reads[OrderBuilderAttributesForm] = {
      (__ \ "attributes").read[Map[String, String]].map { x => new OrderBuilderAttributesForm(attributes = x) }
    }

    def jsObjectOrderBuilderAttributesForm(obj: io.flow.experience.v0.models.OrderBuilderAttributesForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      )
    }

    implicit def jsonWritesExperienceOrderBuilderAttributesForm: play.api.libs.json.Writes[OrderBuilderAttributesForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderBuilderAttributesForm] {
        def writes(obj: io.flow.experience.v0.models.OrderBuilderAttributesForm) = {
          jsObjectOrderBuilderAttributesForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderBuilderCustomerForm: play.api.libs.json.Reads[OrderBuilderCustomerForm] = {
      (__ \ "customer").read[io.flow.common.v0.models.OrderCustomerForm].map { x => new OrderBuilderCustomerForm(customer = x) }
    }

    def jsObjectOrderBuilderCustomerForm(obj: io.flow.experience.v0.models.OrderBuilderCustomerForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "customer" -> io.flow.common.v0.models.json.jsObjectOrderCustomerForm(obj.customer)
      )
    }

    implicit def jsonWritesExperienceOrderBuilderCustomerForm: play.api.libs.json.Writes[OrderBuilderCustomerForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderBuilderCustomerForm] {
        def writes(obj: io.flow.experience.v0.models.OrderBuilderCustomerForm) = {
          jsObjectOrderBuilderCustomerForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderBuilderCustomerInvoiceAddressForm: play.api.libs.json.Reads[OrderBuilderCustomerInvoiceAddressForm] = {
      (__ \ "address").read[io.flow.common.v0.models.BillingAddress].map { x => new OrderBuilderCustomerInvoiceAddressForm(address = x) }
    }

    def jsObjectOrderBuilderCustomerInvoiceAddressForm(obj: io.flow.experience.v0.models.OrderBuilderCustomerInvoiceAddressForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(obj.address)
      )
    }

    implicit def jsonWritesExperienceOrderBuilderCustomerInvoiceAddressForm: play.api.libs.json.Writes[OrderBuilderCustomerInvoiceAddressForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderBuilderCustomerInvoiceAddressForm] {
        def writes(obj: io.flow.experience.v0.models.OrderBuilderCustomerInvoiceAddressForm) = {
          jsObjectOrderBuilderCustomerInvoiceAddressForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderBuilderDeliveredDutyForm: play.api.libs.json.Reads[OrderBuilderDeliveredDutyForm] = {
      (__ \ "delivered_duty").read[io.flow.common.v0.models.DeliveredDuty].map { x => new OrderBuilderDeliveredDutyForm(deliveredDuty = x) }
    }

    def jsObjectOrderBuilderDeliveredDutyForm(obj: io.flow.experience.v0.models.OrderBuilderDeliveredDutyForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString)
      )
    }

    implicit def jsonWritesExperienceOrderBuilderDeliveredDutyForm: play.api.libs.json.Writes[OrderBuilderDeliveredDutyForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderBuilderDeliveredDutyForm] {
        def writes(obj: io.flow.experience.v0.models.OrderBuilderDeliveredDutyForm) = {
          jsObjectOrderBuilderDeliveredDutyForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderBuilderDestinationCountryForm: play.api.libs.json.Reads[OrderBuilderDestinationCountryForm] = {
      (__ \ "country").read[String].map { x => new OrderBuilderDestinationCountryForm(country = x) }
    }

    def jsObjectOrderBuilderDestinationCountryForm(obj: io.flow.experience.v0.models.OrderBuilderDestinationCountryForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "country" -> play.api.libs.json.JsString(obj.country)
      )
    }

    implicit def jsonWritesExperienceOrderBuilderDestinationCountryForm: play.api.libs.json.Writes[OrderBuilderDestinationCountryForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderBuilderDestinationCountryForm] {
        def writes(obj: io.flow.experience.v0.models.OrderBuilderDestinationCountryForm) = {
          jsObjectOrderBuilderDestinationCountryForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderBuilderDestinationForm: play.api.libs.json.Reads[OrderBuilderDestinationForm] = {
      (__ \ "destination").read[io.flow.experience.v0.models.OrderAddress].map { x => new OrderBuilderDestinationForm(destination = x) }
    }

    def jsObjectOrderBuilderDestinationForm(obj: io.flow.experience.v0.models.OrderBuilderDestinationForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "destination" -> jsObjectOrderAddress(obj.destination)
      )
    }

    implicit def jsonWritesExperienceOrderBuilderDestinationForm: play.api.libs.json.Writes[OrderBuilderDestinationForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderBuilderDestinationForm] {
        def writes(obj: io.flow.experience.v0.models.OrderBuilderDestinationForm) = {
          jsObjectOrderBuilderDestinationForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderBuilderSelectionsForm: play.api.libs.json.Reads[OrderBuilderSelectionsForm] = {
      (__ \ "selections").read[Seq[String]].map { x => new OrderBuilderSelectionsForm(selections = x) }
    }

    def jsObjectOrderBuilderSelectionsForm(obj: io.flow.experience.v0.models.OrderBuilderSelectionsForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "selections" -> play.api.libs.json.Json.toJson(obj.selections)
      )
    }

    implicit def jsonWritesExperienceOrderBuilderSelectionsForm: play.api.libs.json.Writes[OrderBuilderSelectionsForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderBuilderSelectionsForm] {
        def writes(obj: io.flow.experience.v0.models.OrderBuilderSelectionsForm) = {
          jsObjectOrderBuilderSelectionsForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderDestinationPutForm: play.api.libs.json.Reads[OrderDestinationPutForm] = {
      (__ \ "destination").read[io.flow.experience.v0.models.OrderAddress].map { x => new OrderDestinationPutForm(destination = x) }
    }

    def jsObjectOrderDestinationPutForm(obj: io.flow.experience.v0.models.OrderDestinationPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "destination" -> jsObjectOrderAddress(obj.destination)
      )
    }

    implicit def jsonWritesExperienceOrderDestinationPutForm: play.api.libs.json.Writes[OrderDestinationPutForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderDestinationPutForm] {
        def writes(obj: io.flow.experience.v0.models.OrderDestinationPutForm) = {
          jsObjectOrderDestinationPutForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderError: play.api.libs.json.Reads[OrderError] = {
      for {
        code <- (__ \ "code").read[io.flow.experience.v0.models.OrderErrorCode]
        messages <- (__ \ "messages").read[Seq[String]]
        numbers <- (__ \ "numbers").readNullable[Seq[String]]
        destinationCountry <- (__ \ "destination_country").readNullable[io.flow.reference.v0.models.Country]
        threshold <- (__ \ "threshold").readNullable[io.flow.experience.v0.models.ValueThresholdExceededDetails]
      } yield OrderError(code, messages, numbers, destinationCountry, threshold)
    }

    def jsObjectOrderError(obj: io.flow.experience.v0.models.OrderError): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString),
        "messages" -> play.api.libs.json.Json.toJson(obj.messages)
      ) ++ (obj.numbers match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("numbers" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.destinationCountry match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination_country" -> io.flow.reference.v0.models.json.jsObjectCountry(x))
      }) ++
      (obj.threshold match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("threshold" -> jsObjectValueThresholdExceededDetails(x))
      })
    }

    implicit def jsonWritesExperienceOrderError: play.api.libs.json.Writes[OrderError] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderError] {
        def writes(obj: io.flow.experience.v0.models.OrderError) = {
          jsObjectOrderError(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderEstimate: play.api.libs.json.Reads[OrderEstimate] = {
      for {
        id <- (__ \ "id").read[String]
        items <- (__ \ "items").read[Seq[io.flow.experience.v0.models.LocalizedLineItem]]
        destination <- (__ \ "destination").read[io.flow.experience.v0.models.OrderAddress]
        deliveries <- (__ \ "deliveries").read[Seq[io.flow.fulfillment.v0.models.Delivery]]
        prices <- (__ \ "prices").read[Seq[io.flow.order.price.v0.models.OrderPriceDetail]]
        selections <- (__ \ "selections").read[Seq[String]]
        total <- (__ \ "total").read[io.flow.catalog.v0.models.LocalizedTotal]
        lines <- (__ \ "lines").readNullable[Seq[io.flow.experience.v0.models.Line]]
        promotions <- (__ \ "promotions").readNullable[io.flow.experience.v0.models.Promotions]
      } yield OrderEstimate(id, items, destination, deliveries, prices, selections, total, lines, promotions)
    }

    def jsObjectOrderEstimate(obj: io.flow.experience.v0.models.OrderEstimate): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "items" -> play.api.libs.json.Json.toJson(obj.items),
        "destination" -> jsObjectOrderAddress(obj.destination),
        "deliveries" -> play.api.libs.json.Json.toJson(obj.deliveries),
        "prices" -> play.api.libs.json.Json.toJson(obj.prices),
        "selections" -> play.api.libs.json.Json.toJson(obj.selections),
        "total" -> io.flow.catalog.v0.models.json.jsObjectLocalizedTotal(obj.total)
      ) ++ (obj.lines match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("lines" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.promotions match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("promotions" -> jsObjectPromotions(x))
      })
    }

    implicit def jsonWritesExperienceOrderEstimate: play.api.libs.json.Writes[OrderEstimate] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderEstimate] {
        def writes(obj: io.flow.experience.v0.models.OrderEstimate) = {
          jsObjectOrderEstimate(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderEstimateForm: play.api.libs.json.Reads[OrderEstimateForm] = {
      for {
        items <- (__ \ "items").read[Seq[io.flow.common.v0.models.LineItemForm]]
        destination <- (__ \ "destination").readNullable[io.flow.experience.v0.models.OrderAddress]
        selections <- (__ \ "selections").readNullable[Seq[String]]
      } yield OrderEstimateForm(items, destination, selections)
    }

    def jsObjectOrderEstimateForm(obj: io.flow.experience.v0.models.OrderEstimateForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.destination match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination" -> jsObjectOrderAddress(x))
      }) ++
      (obj.selections match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("selections" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceOrderEstimateForm: play.api.libs.json.Writes[OrderEstimateForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderEstimateForm] {
        def writes(obj: io.flow.experience.v0.models.OrderEstimateForm) = {
          jsObjectOrderEstimateForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderForm: play.api.libs.json.Reads[OrderForm] = {
      for {
        customer <- (__ \ "customer").readNullable[io.flow.common.v0.models.OrderCustomerForm]
        items <- (__ \ "items").read[Seq[io.flow.common.v0.models.LineItemForm]]
        deliveredDuty <- (__ \ "delivered_duty").readNullable[io.flow.common.v0.models.DeliveredDuty]
        number <- (__ \ "number").readNullable[String]
        destination <- (__ \ "destination").readNullable[io.flow.experience.v0.models.OrderAddress]
        discount <- (__ \ "discount").readNullable[io.flow.common.v0.models.Money]
        discounts <- (__ \ "discounts").readNullable[io.flow.common.v0.models.DiscountsForm]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        authorizationKeys <- (__ \ "authorization_keys").readNullable[Seq[String]]
        options <- (__ \ "options").readNullable[io.flow.experience.v0.models.OrderOptions]
      } yield OrderForm(customer, items, deliveredDuty, number, destination, discount, discounts, attributes, authorizationKeys, options)
    }

    def jsObjectOrderForm(obj: io.flow.experience.v0.models.OrderForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.customer match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("customer" -> io.flow.common.v0.models.json.jsObjectOrderCustomerForm(x))
      }) ++
      (obj.deliveredDuty match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("delivered_duty" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.number match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.destination match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination" -> jsObjectOrderAddress(x))
      }) ++
      (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.discounts match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discounts" -> io.flow.common.v0.models.json.jsObjectDiscountsForm(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.authorizationKeys match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("authorization_keys" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.options match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("options" -> jsObjectOrderOptions(x))
      })
    }

    implicit def jsonWritesExperienceOrderForm: play.api.libs.json.Writes[OrderForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderForm] {
        def writes(obj: io.flow.experience.v0.models.OrderForm) = {
          jsObjectOrderForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderGeo: play.api.libs.json.Reads[OrderGeo] = {
      for {
        ip <- (__ \ "ip").readNullable[String]
        country <- (__ \ "country").read[String]
        currency <- (__ \ "currency").readNullable[String]
        language <- (__ \ "language").readNullable[String]
      } yield OrderGeo(ip, country, currency, language)
    }

    def jsObjectOrderGeo(obj: io.flow.experience.v0.models.OrderGeo): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "country" -> play.api.libs.json.JsString(obj.country)
      ) ++ (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.language match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("language" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceOrderGeo: play.api.libs.json.Writes[OrderGeo] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderGeo] {
        def writes(obj: io.flow.experience.v0.models.OrderGeo) = {
          jsObjectOrderGeo(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderIdentifier: play.api.libs.json.Reads[OrderIdentifier] = {
      for {
        id <- (__ \ "id").read[String]
        order <- (__ \ "order").read[io.flow.experience.v0.models.OrderReference]
        name <- (__ \ "name").read[String]
        identifier <- (__ \ "identifier").read[String]
        primary <- (__ \ "primary").read[Boolean]
        number <- (__ \ "number").readNullable[String]
      } yield OrderIdentifier(id, order, name, identifier, primary, number)
    }

    def jsObjectOrderIdentifier(obj: io.flow.experience.v0.models.OrderIdentifier): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "order" -> jsObjectOrderReference(obj.order),
        "name" -> play.api.libs.json.JsString(obj.name),
        "identifier" -> play.api.libs.json.JsString(obj.identifier),
        "primary" -> play.api.libs.json.JsBoolean(obj.primary)
      ) ++ (obj.number match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("number" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceOrderIdentifier: play.api.libs.json.Writes[OrderIdentifier] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderIdentifier] {
        def writes(obj: io.flow.experience.v0.models.OrderIdentifier) = {
          jsObjectOrderIdentifier(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderIdentifierForm: play.api.libs.json.Reads[OrderIdentifierForm] = {
      for {
        order <- (__ \ "order").read[String]
        name <- (__ \ "name").readNullable[String]
        identifier <- (__ \ "identifier").readNullable[String]
        number <- (__ \ "number").readNullable[String]
        primary <- (__ \ "primary").readNullable[Boolean]
      } yield OrderIdentifierForm(order, name, identifier, number, primary)
    }

    def jsObjectOrderIdentifierForm(obj: io.flow.experience.v0.models.OrderIdentifierForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "order" -> play.api.libs.json.JsString(obj.order)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.identifier match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("identifier" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.number match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.primary match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("primary" -> play.api.libs.json.JsBoolean(x))
      })
    }

    implicit def jsonWritesExperienceOrderIdentifierForm: play.api.libs.json.Writes[OrderIdentifierForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderIdentifierForm] {
        def writes(obj: io.flow.experience.v0.models.OrderIdentifierForm) = {
          jsObjectOrderIdentifierForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderIdentifierPutForm: play.api.libs.json.Reads[OrderIdentifierPutForm] = {
      for {
        order <- (__ \ "order").read[String]
        name <- (__ \ "name").readNullable[String]
        primary <- (__ \ "primary").readNullable[Boolean]
      } yield OrderIdentifierPutForm(order, name, primary)
    }

    def jsObjectOrderIdentifierPutForm(obj: io.flow.experience.v0.models.OrderIdentifierPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "order" -> play.api.libs.json.JsString(obj.order)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.primary match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("primary" -> play.api.libs.json.JsBoolean(x))
      })
    }

    implicit def jsonWritesExperienceOrderIdentifierPutForm: play.api.libs.json.Writes[OrderIdentifierPutForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderIdentifierPutForm] {
        def writes(obj: io.flow.experience.v0.models.OrderIdentifierPutForm) = {
          jsObjectOrderIdentifierPutForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderIdentifierVersion: play.api.libs.json.Reads[OrderIdentifierVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        orderIdentifier <- (__ \ "order_identifier").read[io.flow.experience.v0.models.OrderIdentifier]
      } yield OrderIdentifierVersion(id, timestamp, `type`, orderIdentifier)
    }

    def jsObjectOrderIdentifierVersion(obj: io.flow.experience.v0.models.OrderIdentifierVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "order_identifier" -> jsObjectOrderIdentifier(obj.orderIdentifier)
      )
    }

    implicit def jsonWritesExperienceOrderIdentifierVersion: play.api.libs.json.Writes[OrderIdentifierVersion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderIdentifierVersion] {
        def writes(obj: io.flow.experience.v0.models.OrderIdentifierVersion) = {
          jsObjectOrderIdentifierVersion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderNumberGeneratorDefaults: play.api.libs.json.Reads[OrderNumberGeneratorDefaults] = {
      for {
        startsWith <- (__ \ "starts_with").read[Long]
        minHexLength <- (__ \ "min_hex_length").read[Int]
        minStartsWith <- (__ \ "min_starts_with").read[Long]
      } yield OrderNumberGeneratorDefaults(startsWith, minHexLength, minStartsWith)
    }

    def jsObjectOrderNumberGeneratorDefaults(obj: io.flow.experience.v0.models.OrderNumberGeneratorDefaults): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "starts_with" -> play.api.libs.json.JsNumber(obj.startsWith),
        "min_hex_length" -> play.api.libs.json.JsNumber(obj.minHexLength),
        "min_starts_with" -> play.api.libs.json.JsNumber(obj.minStartsWith)
      )
    }

    implicit def jsonWritesExperienceOrderNumberGeneratorDefaults: play.api.libs.json.Writes[OrderNumberGeneratorDefaults] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderNumberGeneratorDefaults] {
        def writes(obj: io.flow.experience.v0.models.OrderNumberGeneratorDefaults) = {
          jsObjectOrderNumberGeneratorDefaults(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderNumberGeneratorFixedLength: play.api.libs.json.Reads[OrderNumberGeneratorFixedLength] = {
      for {
        length <- (__ \ "length").read[Int]
        padding <- (__ \ "padding").read[String]
      } yield OrderNumberGeneratorFixedLength(length, padding)
    }

    def jsObjectOrderNumberGeneratorFixedLength(obj: io.flow.experience.v0.models.OrderNumberGeneratorFixedLength): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "length" -> play.api.libs.json.JsNumber(obj.length),
        "padding" -> play.api.libs.json.JsString(obj.padding)
      )
    }

    implicit def jsonWritesExperienceOrderNumberGeneratorFixedLength: play.api.libs.json.Writes[OrderNumberGeneratorFixedLength] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderNumberGeneratorFixedLength] {
        def writes(obj: io.flow.experience.v0.models.OrderNumberGeneratorFixedLength) = {
          jsObjectOrderNumberGeneratorFixedLength(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderNumberGeneratorGeneratedNumber: play.api.libs.json.Reads[OrderNumberGeneratorGeneratedNumber] = {
      (__ \ "number").read[String].map { x => new OrderNumberGeneratorGeneratedNumber(number = x) }
    }

    def jsObjectOrderNumberGeneratorGeneratedNumber(obj: io.flow.experience.v0.models.OrderNumberGeneratorGeneratedNumber): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonWritesExperienceOrderNumberGeneratorGeneratedNumber: play.api.libs.json.Writes[OrderNumberGeneratorGeneratedNumber] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderNumberGeneratorGeneratedNumber] {
        def writes(obj: io.flow.experience.v0.models.OrderNumberGeneratorGeneratedNumber) = {
          jsObjectOrderNumberGeneratorGeneratedNumber(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderNumberGeneratorHexadecimal: play.api.libs.json.Reads[OrderNumberGeneratorHexadecimal] = {
      (__ \ "length").read[Int].map { x => new OrderNumberGeneratorHexadecimal(length = x) }
    }

    def jsObjectOrderNumberGeneratorHexadecimal(obj: io.flow.experience.v0.models.OrderNumberGeneratorHexadecimal): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "length" -> play.api.libs.json.JsNumber(obj.length)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "hexadecimal")
    }

    implicit def jsonWritesExperienceOrderNumberGeneratorHexadecimal: play.api.libs.json.Writes[OrderNumberGeneratorHexadecimal] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderNumberGeneratorHexadecimal] {
        def writes(obj: io.flow.experience.v0.models.OrderNumberGeneratorHexadecimal) = {
          jsObjectOrderNumberGeneratorHexadecimal(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderNumberGeneratorPrefixSuffix: play.api.libs.json.Reads[OrderNumberGeneratorPrefixSuffix] = {
      for {
        prefix <- (__ \ "prefix").readNullable[String]
        startsWith <- (__ \ "starts_with").readNullable[Long]
        suffix <- (__ \ "suffix").readNullable[String]
        fixedLength <- (__ \ "fixed_length").readNullable[io.flow.experience.v0.models.OrderNumberGeneratorFixedLength]
      } yield OrderNumberGeneratorPrefixSuffix(prefix, startsWith, suffix, fixedLength)
    }

    def jsObjectOrderNumberGeneratorPrefixSuffix(obj: io.flow.experience.v0.models.OrderNumberGeneratorPrefixSuffix): play.api.libs.json.JsObject = {
      (obj.prefix match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("prefix" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.startsWith match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("starts_with" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.suffix match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("suffix" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.fixedLength match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("fixed_length" -> jsObjectOrderNumberGeneratorFixedLength(x))
      }) ++ play.api.libs.json.Json.obj("discriminator" -> "prefix_suffix")
    }

    implicit def jsonWritesExperienceOrderNumberGeneratorPrefixSuffix: play.api.libs.json.Writes[OrderNumberGeneratorPrefixSuffix] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderNumberGeneratorPrefixSuffix] {
        def writes(obj: io.flow.experience.v0.models.OrderNumberGeneratorPrefixSuffix) = {
          jsObjectOrderNumberGeneratorPrefixSuffix(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderNumberGeneratorUuid: play.api.libs.json.Reads[OrderNumberGeneratorUuid] = {
      (__ \ "prefix").readWithDefault[String]("ord-").map { x => new OrderNumberGeneratorUuid(prefix = x) }
    }

    def jsObjectOrderNumberGeneratorUuid(obj: io.flow.experience.v0.models.OrderNumberGeneratorUuid): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "prefix" -> play.api.libs.json.JsString(obj.prefix)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "uuid")
    }

    implicit def jsonWritesExperienceOrderNumberGeneratorUuid: play.api.libs.json.Writes[OrderNumberGeneratorUuid] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderNumberGeneratorUuid] {
        def writes(obj: io.flow.experience.v0.models.OrderNumberGeneratorUuid) = {
          jsObjectOrderNumberGeneratorUuid(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderNumberReference: play.api.libs.json.Reads[OrderNumberReference] = {
      (__ \ "number").read[String].map { x => new OrderNumberReference(number = x) }
    }

    def jsObjectOrderNumberReference(obj: io.flow.experience.v0.models.OrderNumberReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonWritesExperienceOrderNumberReference: play.api.libs.json.Writes[OrderNumberReference] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderNumberReference] {
        def writes(obj: io.flow.experience.v0.models.OrderNumberReference) = {
          jsObjectOrderNumberReference(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderOptions: play.api.libs.json.Reads[OrderOptions] = {
      (__ \ "storage").read[io.flow.experience.v0.models.OrderStorage].map { x => new OrderOptions(storage = x) }
    }

    def jsObjectOrderOptions(obj: io.flow.experience.v0.models.OrderOptions): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "storage" -> play.api.libs.json.JsString(obj.storage.toString)
      )
    }

    implicit def jsonWritesExperienceOrderOptions: play.api.libs.json.Writes[OrderOptions] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderOptions] {
        def writes(obj: io.flow.experience.v0.models.OrderOptions) = {
          jsObjectOrderOptions(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderPayment: play.api.libs.json.Reads[OrderPayment] = {
      for {
        id <- (__ \ "id").read[String]
        `type` <- (__ \ "type").read[io.flow.experience.v0.models.OrderPaymentType]
        merchantOfRecord <- (__ \ "merchant_of_record").readWithDefault[io.flow.common.v0.models.MerchantOfRecord](io.flow.common.v0.models.MerchantOfRecord.Flow)
        reference <- (__ \ "reference").read[String]
        description <- (__ \ "description").read[String]
        total <- (__ \ "total").read[io.flow.common.v0.models.PriceWithBase]
        address <- (__ \ "address").readNullable[io.flow.common.v0.models.BillingAddress]
        date <- (__ \ "date").readNullable[_root_.org.joda.time.DateTime]
        attributes <- (__ \ "attributes").readWithDefault[Map[String, String]](Map.empty)
        method <- (__ \ "method").readNullable[String]
      } yield OrderPayment(id, `type`, merchantOfRecord, reference, description, total, address, date, attributes, method)
    }

    def jsObjectOrderPayment(obj: io.flow.experience.v0.models.OrderPayment): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "merchant_of_record" -> play.api.libs.json.JsString(obj.merchantOfRecord.toString),
        "reference" -> play.api.libs.json.JsString(obj.reference),
        "description" -> play.api.libs.json.JsString(obj.description),
        "total" -> io.flow.common.v0.models.json.jsObjectPriceWithBase(obj.total),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      ) ++ (obj.address match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("address" -> io.flow.common.v0.models.json.jsObjectBillingAddress(x))
      }) ++
      (obj.date match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("date" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      }) ++
      (obj.method match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("method" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceOrderPayment: play.api.libs.json.Writes[OrderPayment] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPayment] {
        def writes(obj: io.flow.experience.v0.models.OrderPayment) = {
          jsObjectOrderPayment(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderPromotionTrigger: play.api.libs.json.Reads[OrderPromotionTrigger] = {
      for {
        `type` <- (__ \ "type").read[io.flow.experience.v0.models.PromotionTriggerType]
        min <- (__ \ "min").readNullable[io.flow.common.v0.models.Price]
      } yield OrderPromotionTrigger(`type`, min)
    }

    def jsObjectOrderPromotionTrigger(obj: io.flow.experience.v0.models.OrderPromotionTrigger): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      ) ++ (obj.min match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("min" -> io.flow.common.v0.models.json.jsObjectPrice(x))
      })
    }

    implicit def jsonWritesExperienceOrderPromotionTrigger: play.api.libs.json.Writes[OrderPromotionTrigger] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPromotionTrigger] {
        def writes(obj: io.flow.experience.v0.models.OrderPromotionTrigger) = {
          jsObjectOrderPromotionTrigger(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderPutForm: play.api.libs.json.Reads[OrderPutForm] = {
      for {
        orderType <- (__ \ "order_type").readWithDefault[io.flow.experience.v0.models.OrderType](io.flow.experience.v0.models.OrderType.Standard)
        items <- (__ \ "items").read[Seq[io.flow.common.v0.models.LineItemForm]]
        customer <- (__ \ "customer").readNullable[io.flow.common.v0.models.OrderCustomerForm]
        deliveredDuty <- (__ \ "delivered_duty").readNullable[io.flow.common.v0.models.DeliveredDuty]
        selections <- (__ \ "selections").readNullable[Seq[String]]
        destination <- (__ \ "destination").readNullable[io.flow.experience.v0.models.OrderAddress]
        discount <- (__ \ "discount").readNullable[io.flow.common.v0.models.Money]
        discounts <- (__ \ "discounts").readNullable[io.flow.common.v0.models.DiscountsForm]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
        authorizationKeys <- (__ \ "authorization_keys").readNullable[Seq[String]]
        options <- (__ \ "options").readNullable[io.flow.experience.v0.models.OrderOptions]
      } yield OrderPutForm(orderType, items, customer, deliveredDuty, selections, destination, discount, discounts, attributes, authorizationKeys, options)
    }

    def jsObjectOrderPutForm(obj: io.flow.experience.v0.models.OrderPutForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "order_type" -> play.api.libs.json.JsString(obj.orderType.toString),
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.customer match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("customer" -> io.flow.common.v0.models.json.jsObjectOrderCustomerForm(x))
      }) ++
      (obj.deliveredDuty match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("delivered_duty" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.selections match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("selections" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.destination match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination" -> jsObjectOrderAddress(x))
      }) ++
      (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> io.flow.common.v0.models.json.jsObjectMoney(x))
      }) ++
      (obj.discounts match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discounts" -> io.flow.common.v0.models.json.jsObjectDiscountsForm(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.authorizationKeys match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("authorization_keys" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.options match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("options" -> jsObjectOrderOptions(x))
      })
    }

    implicit def jsonWritesExperienceOrderPutForm: play.api.libs.json.Writes[OrderPutForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPutForm] {
        def writes(obj: io.flow.experience.v0.models.OrderPutForm) = {
          jsObjectOrderPutForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderReference: play.api.libs.json.Reads[OrderReference] = {
      for {
        id <- (__ \ "id").read[String]
        number <- (__ \ "number").read[String]
      } yield OrderReference(id, number)
    }

    def jsObjectOrderReference(obj: io.flow.experience.v0.models.OrderReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "order_reference")
    }

    implicit def jsonWritesExperienceOrderReference: play.api.libs.json.Writes[OrderReference] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderReference] {
        def writes(obj: io.flow.experience.v0.models.OrderReference) = {
          jsObjectOrderReference(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderRefundSummary: play.api.libs.json.Reads[OrderRefundSummary] = {
      for {
        currency <- (__ \ "currency").read[String]
        amounts <- (__ \ "amounts").read[io.flow.experience.v0.models.OrderRefundSummaryAmounts]
      } yield OrderRefundSummary(currency, amounts)
    }

    def jsObjectOrderRefundSummary(obj: io.flow.experience.v0.models.OrderRefundSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amounts" -> jsObjectOrderRefundSummaryAmounts(obj.amounts)
      )
    }

    implicit def jsonWritesExperienceOrderRefundSummary: play.api.libs.json.Writes[OrderRefundSummary] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderRefundSummary] {
        def writes(obj: io.flow.experience.v0.models.OrderRefundSummary) = {
          jsObjectOrderRefundSummary(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderRefundSummaryAmounts: play.api.libs.json.Reads[OrderRefundSummaryAmounts] = {
      for {
        balance <- (__ \ "balance").read[BigDecimal]
        itemSubtotal <- (__ \ "item_subtotal").read[BigDecimal]
        discount <- (__ \ "discount").readNullable[BigDecimal]
        refundTotal <- (__ \ "refund_total").read[BigDecimal]
        shipping <- (__ \ "shipping").read[BigDecimal]
        vat <- (__ \ "vat").read[BigDecimal]
        duty <- (__ \ "duty").read[BigDecimal]
      } yield OrderRefundSummaryAmounts(balance, itemSubtotal, discount, refundTotal, shipping, vat, duty)
    }

    def jsObjectOrderRefundSummaryAmounts(obj: io.flow.experience.v0.models.OrderRefundSummaryAmounts): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "balance" -> play.api.libs.json.JsNumber(obj.balance),
        "item_subtotal" -> play.api.libs.json.JsNumber(obj.itemSubtotal),
        "refund_total" -> play.api.libs.json.JsNumber(obj.refundTotal),
        "shipping" -> play.api.libs.json.JsNumber(obj.shipping),
        "vat" -> play.api.libs.json.JsNumber(obj.vat),
        "duty" -> play.api.libs.json.JsNumber(obj.duty)
      ) ++ (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesExperienceOrderRefundSummaryAmounts: play.api.libs.json.Writes[OrderRefundSummaryAmounts] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderRefundSummaryAmounts] {
        def writes(obj: io.flow.experience.v0.models.OrderRefundSummaryAmounts) = {
          jsObjectOrderRefundSummaryAmounts(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderRefundSummaryFullForm: play.api.libs.json.Reads[OrderRefundSummaryFullForm] = {
      (__ \ "includes").read[Seq[io.flow.experience.v0.models.OrderRefundSummaryIncludes]].map { x => new OrderRefundSummaryFullForm(includes = x) }
    }

    def jsObjectOrderRefundSummaryFullForm(obj: io.flow.experience.v0.models.OrderRefundSummaryFullForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "includes" -> play.api.libs.json.Json.toJson(obj.includes)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "order_refund_summary_full_form")
    }

    implicit def jsonWritesExperienceOrderRefundSummaryFullForm: play.api.libs.json.Writes[OrderRefundSummaryFullForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderRefundSummaryFullForm] {
        def writes(obj: io.flow.experience.v0.models.OrderRefundSummaryFullForm) = {
          jsObjectOrderRefundSummaryFullForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderRefundSummaryItem: play.api.libs.json.Reads[OrderRefundSummaryItem] = {
      for {
        number <- (__ \ "number").read[String]
        quantityToRefund <- (__ \ "quantity_to_refund").read[Long]
      } yield OrderRefundSummaryItem(number, quantityToRefund)
    }

    def jsObjectOrderRefundSummaryItem(obj: io.flow.experience.v0.models.OrderRefundSummaryItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "quantity_to_refund" -> play.api.libs.json.JsNumber(obj.quantityToRefund)
      )
    }

    implicit def jsonWritesExperienceOrderRefundSummaryItem: play.api.libs.json.Writes[OrderRefundSummaryItem] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderRefundSummaryItem] {
        def writes(obj: io.flow.experience.v0.models.OrderRefundSummaryItem) = {
          jsObjectOrderRefundSummaryItem(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderRefundSummaryPartialForm: play.api.libs.json.Reads[OrderRefundSummaryPartialForm] = {
      for {
        includes <- (__ \ "includes").read[Seq[io.flow.experience.v0.models.OrderRefundSummaryPartialIncludes]]
        items <- (__ \ "items").read[Seq[io.flow.experience.v0.models.OrderRefundSummaryItem]]
      } yield OrderRefundSummaryPartialForm(includes, items)
    }

    def jsObjectOrderRefundSummaryPartialForm(obj: io.flow.experience.v0.models.OrderRefundSummaryPartialForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "includes" -> play.api.libs.json.Json.toJson(obj.includes),
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ play.api.libs.json.Json.obj("discriminator" -> "order_refund_summary_partial_form")
    }

    implicit def jsonWritesExperienceOrderRefundSummaryPartialForm: play.api.libs.json.Writes[OrderRefundSummaryPartialForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderRefundSummaryPartialForm] {
        def writes(obj: io.flow.experience.v0.models.OrderRefundSummaryPartialForm) = {
          jsObjectOrderRefundSummaryPartialForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderRefundSummaryPartialIncludes: play.api.libs.json.Reads[OrderRefundSummaryPartialIncludes] = {
      for {
        key <- (__ \ "key").read[io.flow.experience.v0.models.OrderRefundSummaryIncludes]
        charged <- (__ \ "charged").read[io.flow.experience.v0.models.OrderRefundSummaryPartialCharged]
      } yield OrderRefundSummaryPartialIncludes(key, charged)
    }

    def jsObjectOrderRefundSummaryPartialIncludes(obj: io.flow.experience.v0.models.OrderRefundSummaryPartialIncludes): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "charged" -> play.api.libs.json.JsString(obj.charged.toString)
      )
    }

    implicit def jsonWritesExperienceOrderRefundSummaryPartialIncludes: play.api.libs.json.Writes[OrderRefundSummaryPartialIncludes] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderRefundSummaryPartialIncludes] {
        def writes(obj: io.flow.experience.v0.models.OrderRefundSummaryPartialIncludes) = {
          jsObjectOrderRefundSummaryPartialIncludes(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderReplacement: play.api.libs.json.Reads[OrderReplacement] = {
      for {
        id <- (__ \ "id").read[String]
        parentOrder <- (__ \ "parent_order").read[io.flow.experience.v0.models.Order]
        replacementOrder <- (__ \ "replacement_order").read[io.flow.experience.v0.models.Order]
      } yield OrderReplacement(id, parentOrder, replacementOrder)
    }

    def jsObjectOrderReplacement(obj: io.flow.experience.v0.models.OrderReplacement): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "parent_order" -> jsObjectOrder(obj.parentOrder),
        "replacement_order" -> jsObjectOrder(obj.replacementOrder)
      )
    }

    implicit def jsonWritesExperienceOrderReplacement: play.api.libs.json.Writes[OrderReplacement] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderReplacement] {
        def writes(obj: io.flow.experience.v0.models.OrderReplacement) = {
          jsObjectOrderReplacement(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderReplacementForm: play.api.libs.json.Reads[OrderReplacementForm] = {
      (__ \ "items").readNullable[Seq[io.flow.common.v0.models.LineItemForm]].map { x => new OrderReplacementForm(items = x) }
    }

    def jsObjectOrderReplacementForm(obj: io.flow.experience.v0.models.OrderReplacementForm): play.api.libs.json.JsObject = {
      (obj.items match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("items" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceOrderReplacementForm: play.api.libs.json.Writes[OrderReplacementForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderReplacementForm] {
        def writes(obj: io.flow.experience.v0.models.OrderReplacementForm) = {
          jsObjectOrderReplacementForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderRuleReference: play.api.libs.json.Reads[OrderRuleReference] = {
      for {
        id <- (__ \ "id").read[String]
        key <- (__ \ "key").read[String]
      } yield OrderRuleReference(id, key)
    }

    def jsObjectOrderRuleReference(obj: io.flow.experience.v0.models.OrderRuleReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonWritesExperienceOrderRuleReference: play.api.libs.json.Writes[OrderRuleReference] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderRuleReference] {
        def writes(obj: io.flow.experience.v0.models.OrderRuleReference) = {
          jsObjectOrderRuleReference(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderRulesSummary: play.api.libs.json.Reads[OrderRulesSummary] = {
      (__ \ "applied").read[Seq[io.flow.experience.v0.models.OrderRuleReference]].map { x => new OrderRulesSummary(applied = x) }
    }

    def jsObjectOrderRulesSummary(obj: io.flow.experience.v0.models.OrderRulesSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "applied" -> play.api.libs.json.Json.toJson(obj.applied)
      )
    }

    implicit def jsonWritesExperienceOrderRulesSummary: play.api.libs.json.Writes[OrderRulesSummary] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderRulesSummary] {
        def writes(obj: io.flow.experience.v0.models.OrderRulesSummary) = {
          jsObjectOrderRulesSummary(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderServiceChange: play.api.libs.json.Reads[OrderServiceChange] = {
      for {
        id <- (__ \ "id").read[String]
        from <- (__ \ "from").read[io.flow.reference.v0.models.CarrierService]
        to <- (__ \ "to").read[io.flow.reference.v0.models.CarrierService]
      } yield OrderServiceChange(id, from, to)
    }

    def jsObjectOrderServiceChange(obj: io.flow.experience.v0.models.OrderServiceChange): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "from" -> io.flow.reference.v0.models.json.jsObjectCarrierService(obj.from),
        "to" -> io.flow.reference.v0.models.json.jsObjectCarrierService(obj.to)
      )
    }

    implicit def jsonWritesExperienceOrderServiceChange: play.api.libs.json.Writes[OrderServiceChange] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderServiceChange] {
        def writes(obj: io.flow.experience.v0.models.OrderServiceChange) = {
          jsObjectOrderServiceChange(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderServiceChangeForm: play.api.libs.json.Reads[OrderServiceChangeForm] = {
      for {
        fromServiceId <- (__ \ "from_service_id").read[String]
        toServiceId <- (__ \ "to_service_id").read[String]
      } yield OrderServiceChangeForm(fromServiceId, toServiceId)
    }

    def jsObjectOrderServiceChangeForm(obj: io.flow.experience.v0.models.OrderServiceChangeForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "from_service_id" -> play.api.libs.json.JsString(obj.fromServiceId),
        "to_service_id" -> play.api.libs.json.JsString(obj.toServiceId)
      )
    }

    implicit def jsonWritesExperienceOrderServiceChangeForm: play.api.libs.json.Writes[OrderServiceChangeForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderServiceChangeForm] {
        def writes(obj: io.flow.experience.v0.models.OrderServiceChangeForm) = {
          jsObjectOrderServiceChangeForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderServiceChangeRequestData: play.api.libs.json.Reads[OrderServiceChangeRequestData] = {
      for {
        id <- (__ \ "id").read[String]
        sourceUrl <- (__ \ "source_url").read[String]
        filename <- (__ \ "filename").readNullable[String]
      } yield OrderServiceChangeRequestData(id, sourceUrl, filename)
    }

    def jsObjectOrderServiceChangeRequestData(obj: io.flow.experience.v0.models.OrderServiceChangeRequestData): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "source_url" -> play.api.libs.json.JsString(obj.sourceUrl)
      ) ++ (obj.filename match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("filename" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceOrderServiceChangeRequestData: play.api.libs.json.Writes[OrderServiceChangeRequestData] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderServiceChangeRequestData] {
        def writes(obj: io.flow.experience.v0.models.OrderServiceChangeRequestData) = {
          jsObjectOrderServiceChangeRequestData(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderSubmissionForm: play.api.libs.json.Reads[OrderSubmissionForm] = {
      (__ \ "identifiers").readWithDefault[Seq[io.flow.experience.v0.models.OrderSubmissionIdentifierForm]](Nil).map { x => new OrderSubmissionForm(identifiers = x) }
    }

    def jsObjectOrderSubmissionForm(obj: io.flow.experience.v0.models.OrderSubmissionForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "identifiers" -> play.api.libs.json.Json.toJson(obj.identifiers)
      )
    }

    implicit def jsonWritesExperienceOrderSubmissionForm: play.api.libs.json.Writes[OrderSubmissionForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderSubmissionForm] {
        def writes(obj: io.flow.experience.v0.models.OrderSubmissionForm) = {
          jsObjectOrderSubmissionForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderSubmissionIdentifierForm: play.api.libs.json.Reads[OrderSubmissionIdentifierForm] = {
      for {
        identifier <- (__ \ "identifier").read[String]
        name <- (__ \ "name").readNullable[String]
        primary <- (__ \ "primary").readNullable[Boolean]
      } yield OrderSubmissionIdentifierForm(identifier, name, primary)
    }

    def jsObjectOrderSubmissionIdentifierForm(obj: io.flow.experience.v0.models.OrderSubmissionIdentifierForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "identifier" -> play.api.libs.json.JsString(obj.identifier)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.primary match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("primary" -> play.api.libs.json.JsBoolean(x))
      })
    }

    implicit def jsonWritesExperienceOrderSubmissionIdentifierForm: play.api.libs.json.Writes[OrderSubmissionIdentifierForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderSubmissionIdentifierForm] {
        def writes(obj: io.flow.experience.v0.models.OrderSubmissionIdentifierForm) = {
          jsObjectOrderSubmissionIdentifierForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderSummary: play.api.libs.json.Reads[OrderSummary] = {
      for {
        number <- (__ \ "number").read[String]
        subtotal <- (__ \ "subtotal").read[io.flow.experience.v0.models.OrderSummaryPriceDetail]
        shipping <- (__ \ "shipping").readNullable[io.flow.experience.v0.models.OrderSummaryPriceDetail]
        tax <- (__ \ "tax").readNullable[io.flow.experience.v0.models.OrderSummaryPriceDetail]
        duty <- (__ \ "duty").readNullable[io.flow.experience.v0.models.OrderSummaryPriceDetail]
        insurance <- (__ \ "insurance").readNullable[io.flow.experience.v0.models.OrderSummaryPriceDetail]
        discount <- (__ \ "discount").readNullable[io.flow.experience.v0.models.OrderSummaryPriceDetail]
        surcharges <- (__ \ "surcharges").readNullable[io.flow.experience.v0.models.OrderSummaryPriceDetail]
        adjustment <- (__ \ "adjustment").readNullable[io.flow.experience.v0.models.OrderSummaryPriceDetail]
        total <- (__ \ "total").read[io.flow.experience.v0.models.OrderSummaryPriceDetail]
        lines <- (__ \ "lines").read[Seq[io.flow.experience.v0.models.OrderSummaryLineItem]]
        identifiers <- (__ \ "identifiers").readNullable[Map[String, String]]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield OrderSummary(number, subtotal, shipping, tax, duty, insurance, discount, surcharges, adjustment, total, lines, identifiers, attributes)
    }

    def jsObjectOrderSummary(obj: io.flow.experience.v0.models.OrderSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "subtotal" -> jsObjectOrderSummaryPriceDetail(obj.subtotal),
        "total" -> jsObjectOrderSummaryPriceDetail(obj.total),
        "lines" -> play.api.libs.json.Json.toJson(obj.lines)
      ) ++ (obj.shipping match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("shipping" -> jsObjectOrderSummaryPriceDetail(x))
      }) ++
      (obj.tax match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tax" -> jsObjectOrderSummaryPriceDetail(x))
      }) ++
      (obj.duty match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("duty" -> jsObjectOrderSummaryPriceDetail(x))
      }) ++
      (obj.insurance match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("insurance" -> jsObjectOrderSummaryPriceDetail(x))
      }) ++
      (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> jsObjectOrderSummaryPriceDetail(x))
      }) ++
      (obj.surcharges match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("surcharges" -> jsObjectOrderSummaryPriceDetail(x))
      }) ++
      (obj.adjustment match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("adjustment" -> jsObjectOrderSummaryPriceDetail(x))
      }) ++
      (obj.identifiers match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("identifiers" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceOrderSummary: play.api.libs.json.Writes[OrderSummary] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderSummary] {
        def writes(obj: io.flow.experience.v0.models.OrderSummary) = {
          jsObjectOrderSummary(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderSummaryImage: play.api.libs.json.Reads[OrderSummaryImage] = {
      (__ \ "url").read[String].map { x => new OrderSummaryImage(url = x) }
    }

    def jsObjectOrderSummaryImage(obj: io.flow.experience.v0.models.OrderSummaryImage): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "url" -> play.api.libs.json.JsString(obj.url)
      )
    }

    implicit def jsonWritesExperienceOrderSummaryImage: play.api.libs.json.Writes[OrderSummaryImage] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderSummaryImage] {
        def writes(obj: io.flow.experience.v0.models.OrderSummaryImage) = {
          jsObjectOrderSummaryImage(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderSummaryItem: play.api.libs.json.Reads[OrderSummaryItem] = {
      for {
        number <- (__ \ "number").read[String]
        name <- (__ \ "name").read[String]
        description <- (__ \ "description").readNullable[String]
        attributes <- (__ \ "attributes").read[Seq[io.flow.experience.v0.models.CheckoutItemContentAttribute]]
        image <- (__ \ "image").readNullable[io.flow.experience.v0.models.OrderSummaryImage]
        price <- (__ \ "price").read[io.flow.common.v0.models.Price]
        discount <- (__ \ "discount").readNullable[io.flow.common.v0.models.Price]
        tax <- (__ \ "tax").readNullable[io.flow.experience.v0.models.OrderSummaryLevy]
        duty <- (__ \ "duty").readNullable[io.flow.experience.v0.models.OrderSummaryLevy]
        priceAttributes <- (__ \ "price_attributes").read[Map[String, io.flow.common.v0.models.Price]]
      } yield OrderSummaryItem(number, name, description, attributes, image, price, discount, tax, duty, priceAttributes)
    }

    def jsObjectOrderSummaryItem(obj: io.flow.experience.v0.models.OrderSummaryItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "name" -> play.api.libs.json.JsString(obj.name),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes),
        "price" -> io.flow.common.v0.models.json.jsObjectPrice(obj.price),
        "price_attributes" -> play.api.libs.json.Json.toJson(obj.priceAttributes)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.image match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("image" -> jsObjectOrderSummaryImage(x))
      }) ++
      (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> io.flow.common.v0.models.json.jsObjectPrice(x))
      }) ++
      (obj.tax match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tax" -> jsObjectOrderSummaryLevy(x))
      }) ++
      (obj.duty match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("duty" -> jsObjectOrderSummaryLevy(x))
      })
    }

    implicit def jsonWritesExperienceOrderSummaryItem: play.api.libs.json.Writes[OrderSummaryItem] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderSummaryItem] {
        def writes(obj: io.flow.experience.v0.models.OrderSummaryItem) = {
          jsObjectOrderSummaryItem(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderSummaryLevy: play.api.libs.json.Reads[OrderSummaryLevy] = {
      for {
        rate <- (__ \ "rate").read[BigDecimal]
        rateLabel <- (__ \ "rate_label").readNullable[String]
        value <- (__ \ "value").read[io.flow.common.v0.models.Price]
      } yield OrderSummaryLevy(rate, rateLabel, value)
    }

    def jsObjectOrderSummaryLevy(obj: io.flow.experience.v0.models.OrderSummaryLevy): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "rate" -> play.api.libs.json.JsNumber(obj.rate),
        "value" -> io.flow.common.v0.models.json.jsObjectPrice(obj.value)
      ) ++ (obj.rateLabel match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("rate_label" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceOrderSummaryLevy: play.api.libs.json.Writes[OrderSummaryLevy] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderSummaryLevy] {
        def writes(obj: io.flow.experience.v0.models.OrderSummaryLevy) = {
          jsObjectOrderSummaryLevy(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderSummaryLineItem: play.api.libs.json.Reads[OrderSummaryLineItem] = {
      for {
        id <- (__ \ "id").readNullable[String]
        item <- (__ \ "item").read[io.flow.experience.v0.models.OrderSummaryItem]
        quantity <- (__ \ "quantity").read[Long]
        discount <- (__ \ "discount").readNullable[io.flow.common.v0.models.Price]
        tax <- (__ \ "tax").readNullable[io.flow.experience.v0.models.OrderSummaryLevy]
        duty <- (__ \ "duty").readNullable[io.flow.experience.v0.models.OrderSummaryLevy]
        total <- (__ \ "total").read[io.flow.common.v0.models.Price]
        priceAttributes <- (__ \ "price_attributes").read[Map[String, io.flow.common.v0.models.Price]]
        attributes <- (__ \ "attributes").readNullable[Map[String, String]]
      } yield OrderSummaryLineItem(id, item, quantity, discount, tax, duty, total, priceAttributes, attributes)
    }

    def jsObjectOrderSummaryLineItem(obj: io.flow.experience.v0.models.OrderSummaryLineItem): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "item" -> jsObjectOrderSummaryItem(obj.item),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "total" -> io.flow.common.v0.models.json.jsObjectPrice(obj.total),
        "price_attributes" -> play.api.libs.json.Json.toJson(obj.priceAttributes)
      ) ++ (obj.id match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> io.flow.common.v0.models.json.jsObjectPrice(x))
      }) ++
      (obj.tax match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tax" -> jsObjectOrderSummaryLevy(x))
      }) ++
      (obj.duty match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("duty" -> jsObjectOrderSummaryLevy(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesExperienceOrderSummaryLineItem: play.api.libs.json.Writes[OrderSummaryLineItem] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderSummaryLineItem] {
        def writes(obj: io.flow.experience.v0.models.OrderSummaryLineItem) = {
          jsObjectOrderSummaryLineItem(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderSummaryPriceDetail: play.api.libs.json.Reads[OrderSummaryPriceDetail] = {
      for {
        price <- (__ \ "price").read[io.flow.common.v0.models.Price]
        name <- (__ \ "name").readNullable[String]
        rate <- (__ \ "rate").readNullable[BigDecimal]
        rateLabel <- (__ \ "rate_label").readNullable[String]
      } yield OrderSummaryPriceDetail(price, name, rate, rateLabel)
    }

    def jsObjectOrderSummaryPriceDetail(obj: io.flow.experience.v0.models.OrderSummaryPriceDetail): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "price" -> io.flow.common.v0.models.json.jsObjectPrice(obj.price)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.rate match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("rate" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.rateLabel match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("rate_label" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesExperienceOrderSummaryPriceDetail: play.api.libs.json.Writes[OrderSummaryPriceDetail] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderSummaryPriceDetail] {
        def writes(obj: io.flow.experience.v0.models.OrderSummaryPriceDetail) = {
          jsObjectOrderSummaryPriceDetail(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderVersion: play.api.libs.json.Reads[OrderVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        order <- (__ \ "order").read[io.flow.experience.v0.models.Order]
      } yield OrderVersion(id, timestamp, `type`, order)
    }

    def jsObjectOrderVersion(obj: io.flow.experience.v0.models.OrderVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "order" -> jsObjectOrder(obj.order)
      )
    }

    implicit def jsonWritesExperienceOrderVersion: play.api.libs.json.Writes[OrderVersion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderVersion] {
        def writes(obj: io.flow.experience.v0.models.OrderVersion) = {
          jsObjectOrderVersion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderWithDiscountsForm: play.api.libs.json.Reads[OrderWithDiscountsForm] = {
      for {
        order <- (__ \ "order").read[io.flow.experience.v0.models.OrderForm]
        discounts <- (__ \ "discounts").read[Seq[String]]
      } yield OrderWithDiscountsForm(order, discounts)
    }

    def jsObjectOrderWithDiscountsForm(obj: io.flow.experience.v0.models.OrderWithDiscountsForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "order" -> jsObjectOrderForm(obj.order),
        "discounts" -> play.api.libs.json.Json.toJson(obj.discounts)
      )
    }

    implicit def jsonWritesExperienceOrderWithDiscountsForm: play.api.libs.json.Writes[OrderWithDiscountsForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderWithDiscountsForm] {
        def writes(obj: io.flow.experience.v0.models.OrderWithDiscountsForm) = {
          jsObjectOrderWithDiscountsForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOriginalPrices: play.api.libs.json.Reads[OriginalPrices] = {
      for {
        value <- (__ \ "value").read[io.flow.common.v0.models.Price]
        max <- (__ \ "max").read[io.flow.common.v0.models.Price]
      } yield OriginalPrices(value, max)
    }

    def jsObjectOriginalPrices(obj: io.flow.experience.v0.models.OriginalPrices): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "value" -> io.flow.common.v0.models.json.jsObjectPrice(obj.value),
        "max" -> io.flow.common.v0.models.json.jsObjectPrice(obj.max)
      )
    }

    implicit def jsonWritesExperienceOriginalPrices: play.api.libs.json.Writes[OriginalPrices] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OriginalPrices] {
        def writes(obj: io.flow.experience.v0.models.OriginalPrices) = {
          jsObjectOriginalPrices(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePaymentMethodIssuer: play.api.libs.json.Reads[PaymentMethodIssuer] = {
      for {
        id <- (__ \ "id").read[String]
        name <- (__ \ "name").read[String]
      } yield PaymentMethodIssuer(id, name)
    }

    def jsObjectPaymentMethodIssuer(obj: io.flow.experience.v0.models.PaymentMethodIssuer): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "name" -> play.api.libs.json.JsString(obj.name)
      )
    }

    implicit def jsonWritesExperiencePaymentMethodIssuer: play.api.libs.json.Writes[PaymentMethodIssuer] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PaymentMethodIssuer] {
        def writes(obj: io.flow.experience.v0.models.PaymentMethodIssuer) = {
          jsObjectPaymentMethodIssuer(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePaymentMethodRule: play.api.libs.json.Reads[PaymentMethodRule] = {
      for {
        tags <- (__ \ "tags").read[Seq[io.flow.experience.v0.models.PaymentMethodTag]]
        paymentMethod <- (__ \ "payment_method").read[io.flow.reference.v0.models.PaymentMethod]
        displayPosition <- (__ \ "display_position").read[Int]
        content <- (__ \ "content").readNullable[Seq[io.flow.experience.v0.models.PaymentMethodRuleContent]]
        issuers <- (__ \ "issuers").readNullable[Seq[io.flow.experience.v0.models.PaymentMethodIssuer]]
        programs <- (__ \ "programs").readNullable[Seq[_root_.play.api.libs.json.JsObject]]
        q <- (__ \ "q").readNullable[io.flow.query.builder.v0.models.Query]
      } yield PaymentMethodRule(tags, paymentMethod, displayPosition, content, issuers, programs, q)
    }

    def jsObjectPaymentMethodRule(obj: io.flow.experience.v0.models.PaymentMethodRule): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "tags" -> play.api.libs.json.Json.toJson(obj.tags),
        "payment_method" -> io.flow.reference.v0.models.json.jsObjectPaymentMethod(obj.paymentMethod),
        "display_position" -> play.api.libs.json.JsNumber(obj.displayPosition)
      ) ++ (obj.content match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("content" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.issuers match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("issuers" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.programs match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("programs" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.q match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("q" -> io.flow.query.builder.v0.models.json.jsObjectQuery(x))
      })
    }

    implicit def jsonWritesExperiencePaymentMethodRule: play.api.libs.json.Writes[PaymentMethodRule] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PaymentMethodRule] {
        def writes(obj: io.flow.experience.v0.models.PaymentMethodRule) = {
          jsObjectPaymentMethodRule(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePaymentMethodRuleContent: play.api.libs.json.Reads[PaymentMethodRuleContent] = {
      for {
        key <- (__ \ "key").read[io.flow.experience.v0.models.PaymentMethodRuleContentKey]
        value <- (__ \ "value").read[String]
      } yield PaymentMethodRuleContent(key, value)
    }

    def jsObjectPaymentMethodRuleContent(obj: io.flow.experience.v0.models.PaymentMethodRuleContent): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "value" -> play.api.libs.json.JsString(obj.value)
      )
    }

    implicit def jsonWritesExperiencePaymentMethodRuleContent: play.api.libs.json.Writes[PaymentMethodRuleContent] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PaymentMethodRuleContent] {
        def writes(obj: io.flow.experience.v0.models.PaymentMethodRuleContent) = {
          jsObjectPaymentMethodRuleContent(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePricingSettings: play.api.libs.json.Reads[PricingSettings] = {
      for {
        editable <- (__ \ "editable").read[Boolean]
        defaultTaxDisplay <- (__ \ "default_tax_display").read[io.flow.price.v0.models.PricingLevySetting]
        defaultDutyDisplay <- (__ \ "default_duty_display").read[io.flow.price.v0.models.PricingLevySetting]
      } yield PricingSettings(editable, defaultTaxDisplay, defaultDutyDisplay)
    }

    def jsObjectPricingSettings(obj: io.flow.experience.v0.models.PricingSettings): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "editable" -> play.api.libs.json.JsBoolean(obj.editable),
        "default_tax_display" -> play.api.libs.json.JsString(obj.defaultTaxDisplay.toString),
        "default_duty_display" -> play.api.libs.json.JsString(obj.defaultDutyDisplay.toString)
      )
    }

    implicit def jsonWritesExperiencePricingSettings: play.api.libs.json.Writes[PricingSettings] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PricingSettings] {
        def writes(obj: io.flow.experience.v0.models.PricingSettings) = {
          jsObjectPricingSettings(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePricingVersion: play.api.libs.json.Reads[PricingVersion] = {
      for {
        id <- (__ \ "id").read[String]
        timestamp <- (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
        `type` <- (__ \ "type").read[io.flow.common.v0.models.ChangeType]
        pricing <- (__ \ "pricing").read[io.flow.price.v0.models.Pricing]
      } yield PricingVersion(id, timestamp, `type`, pricing)
    }

    def jsObjectPricingVersion(obj: io.flow.experience.v0.models.PricingVersion): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "pricing" -> io.flow.price.v0.models.json.jsObjectPricing(obj.pricing)
      )
    }

    implicit def jsonWritesExperiencePricingVersion: play.api.libs.json.Writes[PricingVersion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PricingVersion] {
        def writes(obj: io.flow.experience.v0.models.PricingVersion) = {
          jsObjectPricingVersion(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePromotionTrigger: play.api.libs.json.Reads[PromotionTrigger] = {
      for {
        `type` <- (__ \ "type").read[io.flow.experience.v0.models.PromotionTriggerType]
        min <- (__ \ "min").read[io.flow.common.v0.models.Price]
        remaining <- (__ \ "remaining").read[io.flow.common.v0.models.Price]
      } yield PromotionTrigger(`type`, min, remaining)
    }

    def jsObjectPromotionTrigger(obj: io.flow.experience.v0.models.PromotionTrigger): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "min" -> io.flow.common.v0.models.json.jsObjectPrice(obj.min),
        "remaining" -> io.flow.common.v0.models.json.jsObjectPrice(obj.remaining)
      )
    }

    implicit def jsonWritesExperiencePromotionTrigger: play.api.libs.json.Writes[PromotionTrigger] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PromotionTrigger] {
        def writes(obj: io.flow.experience.v0.models.PromotionTrigger) = {
          jsObjectPromotionTrigger(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePromotionTriggerForm: play.api.libs.json.Reads[PromotionTriggerForm] = {
      for {
        `type` <- (__ \ "type").read[io.flow.experience.v0.models.PromotionTriggerType]
        min <- (__ \ "min").readNullable[io.flow.common.v0.models.PriceForm]
      } yield PromotionTriggerForm(`type`, min)
    }

    def jsObjectPromotionTriggerForm(obj: io.flow.experience.v0.models.PromotionTriggerForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      ) ++ (obj.min match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("min" -> io.flow.common.v0.models.json.jsObjectPriceForm(x))
      })
    }

    implicit def jsonWritesExperiencePromotionTriggerForm: play.api.libs.json.Writes[PromotionTriggerForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PromotionTriggerForm] {
        def writes(obj: io.flow.experience.v0.models.PromotionTriggerForm) = {
          jsObjectPromotionTriggerForm(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePromotions: play.api.libs.json.Reads[Promotions] = {
      for {
        applied <- (__ \ "applied").read[Seq[io.flow.experience.v0.models.Promotion]]
        available <- (__ \ "available").read[Seq[io.flow.experience.v0.models.Promotion]]
      } yield Promotions(applied, available)
    }

    def jsObjectPromotions(obj: io.flow.experience.v0.models.Promotions): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "applied" -> play.api.libs.json.Json.toJson(obj.applied),
        "available" -> play.api.libs.json.Json.toJson(obj.available)
      )
    }

    implicit def jsonWritesExperiencePromotions: play.api.libs.json.Writes[Promotions] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.Promotions] {
        def writes(obj: io.flow.experience.v0.models.Promotions) = {
          jsObjectPromotions(obj)
        }
      }
    }

    implicit def jsonReadsExperienceRegionReference: play.api.libs.json.Reads[RegionReference] = {
      (__ \ "id").read[String].map { x => new RegionReference(id = x) }
    }

    def jsObjectRegionReference(obj: io.flow.experience.v0.models.RegionReference): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesExperienceRegionReference: play.api.libs.json.Writes[RegionReference] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.RegionReference] {
        def writes(obj: io.flow.experience.v0.models.RegionReference) = {
          jsObjectRegionReference(obj)
        }
      }
    }

    implicit def jsonReadsExperienceValueThresholdExceededDetails: play.api.libs.json.Reads[ValueThresholdExceededDetails] = {
      for {
        local <- (__ \ "local").read[io.flow.common.v0.models.Price]
        original <- (__ \ "original").read[io.flow.common.v0.models.Price]
      } yield ValueThresholdExceededDetails(local, original)
    }

    def jsObjectValueThresholdExceededDetails(obj: io.flow.experience.v0.models.ValueThresholdExceededDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "local" -> io.flow.common.v0.models.json.jsObjectPrice(obj.local),
        "original" -> io.flow.common.v0.models.json.jsObjectPrice(obj.original)
      )
    }

    implicit def jsonWritesExperienceValueThresholdExceededDetails: play.api.libs.json.Writes[ValueThresholdExceededDetails] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ValueThresholdExceededDetails] {
        def writes(obj: io.flow.experience.v0.models.ValueThresholdExceededDetails) = {
          jsObjectValueThresholdExceededDetails(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationComponent: play.api.libs.json.Reads[AllocationComponent] = new play.api.libs.json.Reads[AllocationComponent] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[AllocationComponent] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[AllocationComponent] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "allocation_detail_component" => js.validate[io.flow.experience.v0.models.AllocationDetailComponent]
          case "allocation_levy_component" => js.validate[io.flow.experience.v0.models.AllocationLevyComponent]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.AllocationComponentUndefinedType(other))
        }
      }
    }

    def jsObjectAllocationComponent(obj: io.flow.experience.v0.models.AllocationComponent): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.AllocationDetailComponent => jsObjectAllocationDetailComponent(x)
        case x: io.flow.experience.v0.models.AllocationLevyComponent => jsObjectAllocationLevyComponent(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceAllocationComponent: play.api.libs.json.Writes[AllocationComponent] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AllocationComponent] {
        def writes(obj: io.flow.experience.v0.models.AllocationComponent) = {
          jsObjectAllocationComponent(obj)
        }
      }
    }

    implicit def jsonReadsExperienceAllocationDetail: play.api.libs.json.Reads[AllocationDetail] = new play.api.libs.json.Reads[AllocationDetail] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[AllocationDetail] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[AllocationDetail] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "allocation_line_detail" => js.validate[io.flow.experience.v0.models.AllocationLineDetail]
          case "allocation_order_detail" => js.validate[io.flow.experience.v0.models.AllocationOrderDetail]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.AllocationDetailUndefinedType(other))
        }
      }
    }

    def jsObjectAllocationDetail(obj: io.flow.experience.v0.models.AllocationDetail): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.AllocationLineDetail => jsObjectAllocationLineDetail(x)
        case x: io.flow.experience.v0.models.AllocationOrderDetail => jsObjectAllocationOrderDetail(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceAllocationDetail: play.api.libs.json.Writes[AllocationDetail] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.AllocationDetail] {
        def writes(obj: io.flow.experience.v0.models.AllocationDetail) = {
          jsObjectAllocationDetail(obj)
        }
      }
    }

    implicit def jsonReadsExperienceDiscountRuleEntitlement: play.api.libs.json.Reads[DiscountRuleEntitlement] = new play.api.libs.json.Reads[DiscountRuleEntitlement] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[DiscountRuleEntitlement] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[DiscountRuleEntitlement] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "subsidy" => js.validate[io.flow.experience.v0.models.DiscountRuleSubsidyEntitlement]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.DiscountRuleEntitlementUndefinedType(other))
        }
      }
    }

    def jsObjectDiscountRuleEntitlement(obj: io.flow.experience.v0.models.DiscountRuleEntitlement): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.DiscountRuleSubsidyEntitlement => jsObjectDiscountRuleSubsidyEntitlement(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceDiscountRuleEntitlement: play.api.libs.json.Writes[DiscountRuleEntitlement] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.DiscountRuleEntitlement] {
        def writes(obj: io.flow.experience.v0.models.DiscountRuleEntitlement) = {
          jsObjectDiscountRuleEntitlement(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExpandableExperience: play.api.libs.json.Reads[ExpandableExperience] = new play.api.libs.json.Reads[ExpandableExperience] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[ExpandableExperience] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[ExpandableExperience] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "experience" => js.validate[io.flow.experience.v0.models.Experience]
          case "experience_reference" => js.validate[io.flow.experience.v0.models.ExperienceReference]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExpandableExperienceUndefinedType(other))
        }
      }
    }

    def jsObjectExpandableExperience(obj: io.flow.experience.v0.models.ExpandableExperience): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.Experience => jsObjectExperience(x)
        case x: io.flow.experience.v0.models.ExperienceReference => jsObjectExperienceReference(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceExpandableExperience: play.api.libs.json.Writes[ExpandableExperience] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExpandableExperience] {
        def writes(obj: io.flow.experience.v0.models.ExpandableExperience) = {
          jsObjectExpandableExperience(obj)
        }
      }
    }

    implicit def jsonReadsExperienceExpandableOrder: play.api.libs.json.Reads[ExpandableOrder] = new play.api.libs.json.Reads[ExpandableOrder] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[ExpandableOrder] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[ExpandableOrder] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "order" => js.validate[io.flow.experience.v0.models.Order]
          case "order_reference" => js.validate[io.flow.experience.v0.models.OrderReference]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.ExpandableOrderUndefinedType(other))
        }
      }
    }

    def jsObjectExpandableOrder(obj: io.flow.experience.v0.models.ExpandableOrder): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.Order => jsObjectOrder(x)
        case x: io.flow.experience.v0.models.OrderReference => jsObjectOrderReference(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceExpandableOrder: play.api.libs.json.Writes[ExpandableOrder] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.ExpandableOrder] {
        def writes(obj: io.flow.experience.v0.models.ExpandableOrder) = {
          jsObjectExpandableOrder(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderNumberGenerator: play.api.libs.json.Reads[OrderNumberGenerator] = new play.api.libs.json.Reads[OrderNumberGenerator] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[OrderNumberGenerator] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[OrderNumberGenerator] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "uuid" => js.validate[io.flow.experience.v0.models.OrderNumberGeneratorUuid]
          case "hexadecimal" => js.validate[io.flow.experience.v0.models.OrderNumberGeneratorHexadecimal]
          case "prefix_suffix" => js.validate[io.flow.experience.v0.models.OrderNumberGeneratorPrefixSuffix]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderNumberGeneratorUndefinedType(other))
        }
      }
    }

    def jsObjectOrderNumberGenerator(obj: io.flow.experience.v0.models.OrderNumberGenerator): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.OrderNumberGeneratorUuid => jsObjectOrderNumberGeneratorUuid(x)
        case x: io.flow.experience.v0.models.OrderNumberGeneratorHexadecimal => jsObjectOrderNumberGeneratorHexadecimal(x)
        case x: io.flow.experience.v0.models.OrderNumberGeneratorPrefixSuffix => jsObjectOrderNumberGeneratorPrefixSuffix(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceOrderNumberGenerator: play.api.libs.json.Writes[OrderNumberGenerator] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderNumberGenerator] {
        def writes(obj: io.flow.experience.v0.models.OrderNumberGenerator) = {
          jsObjectOrderNumberGenerator(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderPromotion: play.api.libs.json.Reads[OrderPromotion] = new play.api.libs.json.Reads[OrderPromotion] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[OrderPromotion] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[OrderPromotion] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "free_shipping_order_promotion" => js.validate[io.flow.experience.v0.models.FreeShippingOrderPromotion]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPromotionUndefinedType(other))
        }
      }
    }

    def jsObjectOrderPromotion(obj: io.flow.experience.v0.models.OrderPromotion): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.FreeShippingOrderPromotion => jsObjectFreeShippingOrderPromotion(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceOrderPromotion: play.api.libs.json.Writes[OrderPromotion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPromotion] {
        def writes(obj: io.flow.experience.v0.models.OrderPromotion) = {
          jsObjectOrderPromotion(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderPromotionForm: play.api.libs.json.Reads[OrderPromotionForm] = new play.api.libs.json.Reads[OrderPromotionForm] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[OrderPromotionForm] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[OrderPromotionForm] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "free_shipping_order_promotion_form" => js.validate[io.flow.experience.v0.models.FreeShippingOrderPromotionForm]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderPromotionFormUndefinedType(other))
        }
      }
    }

    def jsObjectOrderPromotionForm(obj: io.flow.experience.v0.models.OrderPromotionForm): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.FreeShippingOrderPromotionForm => jsObjectFreeShippingOrderPromotionForm(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceOrderPromotionForm: play.api.libs.json.Writes[OrderPromotionForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderPromotionForm] {
        def writes(obj: io.flow.experience.v0.models.OrderPromotionForm) = {
          jsObjectOrderPromotionForm(obj)
        }
      }
    }

    implicit def jsonReadsExperienceOrderRefundSummaryForm: play.api.libs.json.Reads[OrderRefundSummaryForm] = new play.api.libs.json.Reads[OrderRefundSummaryForm] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[OrderRefundSummaryForm] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[OrderRefundSummaryForm] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "order_refund_summary_full_form" => js.validate[io.flow.experience.v0.models.OrderRefundSummaryFullForm]
          case "order_refund_summary_partial_form" => js.validate[io.flow.experience.v0.models.OrderRefundSummaryPartialForm]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.OrderRefundSummaryFormUndefinedType(other))
        }
      }
    }

    def jsObjectOrderRefundSummaryForm(obj: io.flow.experience.v0.models.OrderRefundSummaryForm): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.OrderRefundSummaryFullForm => jsObjectOrderRefundSummaryFullForm(x)
        case x: io.flow.experience.v0.models.OrderRefundSummaryPartialForm => jsObjectOrderRefundSummaryPartialForm(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperienceOrderRefundSummaryForm: play.api.libs.json.Writes[OrderRefundSummaryForm] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.OrderRefundSummaryForm] {
        def writes(obj: io.flow.experience.v0.models.OrderRefundSummaryForm) = {
          jsObjectOrderRefundSummaryForm(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePaymentMethodTag: play.api.libs.json.Reads[PaymentMethodTag] = new play.api.libs.json.Reads[PaymentMethodTag] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[PaymentMethodTag] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[PaymentMethodTag] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "organization_payment_method_tag" => js.validate[io.flow.experience.v0.models.OrganizationPaymentMethodTag]
          case "experience_payment_method_tag" => js.validate[io.flow.experience.v0.models.ExperiencePaymentMethodTag]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PaymentMethodTagUndefinedType(other))
        }
      }
    }

    def jsObjectPaymentMethodTag(obj: io.flow.experience.v0.models.PaymentMethodTag): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.OrganizationPaymentMethodTag => jsObjectOrganizationPaymentMethodTag(x)
        case x: io.flow.experience.v0.models.ExperiencePaymentMethodTag => jsObjectExperiencePaymentMethodTag(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperiencePaymentMethodTag: play.api.libs.json.Writes[PaymentMethodTag] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.PaymentMethodTag] {
        def writes(obj: io.flow.experience.v0.models.PaymentMethodTag) = {
          jsObjectPaymentMethodTag(obj)
        }
      }
    }

    implicit def jsonReadsExperiencePromotion: play.api.libs.json.Reads[Promotion] = new play.api.libs.json.Reads[Promotion] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[Promotion] = {
        (js \ "discriminator").asOpt[String].getOrElse { sys.error("Union[Promotion] requires a discriminator named 'discriminator' - this field was not found in the Json Value") } match {
          case "free_shipping" => js.validate[io.flow.experience.v0.models.FreeShipping]
          case "discount" => js.validate[io.flow.experience.v0.models.Discount]
          case other => play.api.libs.json.JsSuccess(io.flow.experience.v0.models.PromotionUndefinedType(other))
        }
      }
    }

    def jsObjectPromotion(obj: io.flow.experience.v0.models.Promotion): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.experience.v0.models.FreeShipping => jsObjectFreeShipping(x)
        case x: io.flow.experience.v0.models.Discount => jsObjectDiscount(x)
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesExperiencePromotion: play.api.libs.json.Writes[Promotion] = {
      new play.api.libs.json.Writes[io.flow.experience.v0.models.Promotion] {
        def writes(obj: io.flow.experience.v0.models.Promotion) = {
          jsObjectPromotion(obj)
        }
      }
    }
  }
}

package io.flow.experience.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}

    // import models directly for backwards compatibility with prior versions of the generator
    import Core._
    import Models._

    object Core {
      implicit def pathBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.DateTime] = ApibuilderPathBindable(ApibuilderTypes.dateTimeIso8601)
      implicit def queryStringBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.DateTime] = ApibuilderQueryStringBindable(ApibuilderTypes.dateTimeIso8601)

      implicit def pathBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.LocalDate] = ApibuilderPathBindable(ApibuilderTypes.dateIso8601)
      implicit def queryStringBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.LocalDate] = ApibuilderQueryStringBindable(ApibuilderTypes.dateIso8601)
    }

    object Models {
      import io.flow.experience.v0.models._

      val addressFieldNameConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.AddressFieldName] = new ApibuilderTypeConverter[io.flow.experience.v0.models.AddressFieldName] {
        override def convert(value: String): io.flow.experience.v0.models.AddressFieldName = io.flow.experience.v0.models.AddressFieldName(value)
        override def convert(value: io.flow.experience.v0.models.AddressFieldName): String = value.toString
        override def example: io.flow.experience.v0.models.AddressFieldName = io.flow.experience.v0.models.AddressFieldName.FirstName
        override def validValues: Seq[io.flow.experience.v0.models.AddressFieldName] = io.flow.experience.v0.models.AddressFieldName.all
      }
      implicit def pathBindableAddressFieldName(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.AddressFieldName] = ApibuilderPathBindable(addressFieldNameConverter)
      implicit def queryStringBindableAddressFieldName(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.AddressFieldName] = ApibuilderQueryStringBindable(addressFieldNameConverter)

      val creditPaymentErrorCodeConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.CreditPaymentErrorCode] = new ApibuilderTypeConverter[io.flow.experience.v0.models.CreditPaymentErrorCode] {
        override def convert(value: String): io.flow.experience.v0.models.CreditPaymentErrorCode = io.flow.experience.v0.models.CreditPaymentErrorCode(value)
        override def convert(value: io.flow.experience.v0.models.CreditPaymentErrorCode): String = value.toString
        override def example: io.flow.experience.v0.models.CreditPaymentErrorCode = io.flow.experience.v0.models.CreditPaymentErrorCode.GenericError
        override def validValues: Seq[io.flow.experience.v0.models.CreditPaymentErrorCode] = io.flow.experience.v0.models.CreditPaymentErrorCode.all
      }
      implicit def pathBindableCreditPaymentErrorCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.CreditPaymentErrorCode] = ApibuilderPathBindable(creditPaymentErrorCodeConverter)
      implicit def queryStringBindableCreditPaymentErrorCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.CreditPaymentErrorCode] = ApibuilderQueryStringBindable(creditPaymentErrorCodeConverter)

      val deliveredDutyDisplayTypeConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.DeliveredDutyDisplayType] = new ApibuilderTypeConverter[io.flow.experience.v0.models.DeliveredDutyDisplayType] {
        override def convert(value: String): io.flow.experience.v0.models.DeliveredDutyDisplayType = io.flow.experience.v0.models.DeliveredDutyDisplayType(value)
        override def convert(value: io.flow.experience.v0.models.DeliveredDutyDisplayType): String = value.toString
        override def example: io.flow.experience.v0.models.DeliveredDutyDisplayType = io.flow.experience.v0.models.DeliveredDutyDisplayType.All
        override def validValues: Seq[io.flow.experience.v0.models.DeliveredDutyDisplayType] = io.flow.experience.v0.models.DeliveredDutyDisplayType.all
      }
      implicit def pathBindableDeliveredDutyDisplayType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.DeliveredDutyDisplayType] = ApibuilderPathBindable(deliveredDutyDisplayTypeConverter)
      implicit def queryStringBindableDeliveredDutyDisplayType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.DeliveredDutyDisplayType] = ApibuilderQueryStringBindable(deliveredDutyDisplayTypeConverter)

      val discountRuleStatusConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.DiscountRuleStatus] = new ApibuilderTypeConverter[io.flow.experience.v0.models.DiscountRuleStatus] {
        override def convert(value: String): io.flow.experience.v0.models.DiscountRuleStatus = io.flow.experience.v0.models.DiscountRuleStatus(value)
        override def convert(value: io.flow.experience.v0.models.DiscountRuleStatus): String = value.toString
        override def example: io.flow.experience.v0.models.DiscountRuleStatus = io.flow.experience.v0.models.DiscountRuleStatus.Active
        override def validValues: Seq[io.flow.experience.v0.models.DiscountRuleStatus] = io.flow.experience.v0.models.DiscountRuleStatus.all
      }
      implicit def pathBindableDiscountRuleStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.DiscountRuleStatus] = ApibuilderPathBindable(discountRuleStatusConverter)
      implicit def queryStringBindableDiscountRuleStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.DiscountRuleStatus] = ApibuilderQueryStringBindable(discountRuleStatusConverter)

      val discountRuleSubsidyTargetConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.DiscountRuleSubsidyTarget] = new ApibuilderTypeConverter[io.flow.experience.v0.models.DiscountRuleSubsidyTarget] {
        override def convert(value: String): io.flow.experience.v0.models.DiscountRuleSubsidyTarget = io.flow.experience.v0.models.DiscountRuleSubsidyTarget(value)
        override def convert(value: io.flow.experience.v0.models.DiscountRuleSubsidyTarget): String = value.toString
        override def example: io.flow.experience.v0.models.DiscountRuleSubsidyTarget = io.flow.experience.v0.models.DiscountRuleSubsidyTarget.Vat
        override def validValues: Seq[io.flow.experience.v0.models.DiscountRuleSubsidyTarget] = io.flow.experience.v0.models.DiscountRuleSubsidyTarget.all
      }
      implicit def pathBindableDiscountRuleSubsidyTarget(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.DiscountRuleSubsidyTarget] = ApibuilderPathBindable(discountRuleSubsidyTargetConverter)
      implicit def queryStringBindableDiscountRuleSubsidyTarget(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.DiscountRuleSubsidyTarget] = ApibuilderQueryStringBindable(discountRuleSubsidyTargetConverter)

      val experienceCloneStatusConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.ExperienceCloneStatus] = new ApibuilderTypeConverter[io.flow.experience.v0.models.ExperienceCloneStatus] {
        override def convert(value: String): io.flow.experience.v0.models.ExperienceCloneStatus = io.flow.experience.v0.models.ExperienceCloneStatus(value)
        override def convert(value: io.flow.experience.v0.models.ExperienceCloneStatus): String = value.toString
        override def example: io.flow.experience.v0.models.ExperienceCloneStatus = io.flow.experience.v0.models.ExperienceCloneStatus.Pending
        override def validValues: Seq[io.flow.experience.v0.models.ExperienceCloneStatus] = io.flow.experience.v0.models.ExperienceCloneStatus.all
      }
      implicit def pathBindableExperienceCloneStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.ExperienceCloneStatus] = ApibuilderPathBindable(experienceCloneStatusConverter)
      implicit def queryStringBindableExperienceCloneStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.ExperienceCloneStatus] = ApibuilderQueryStringBindable(experienceCloneStatusConverter)

      val experienceCountryStatusConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.ExperienceCountryStatus] = new ApibuilderTypeConverter[io.flow.experience.v0.models.ExperienceCountryStatus] {
        override def convert(value: String): io.flow.experience.v0.models.ExperienceCountryStatus = io.flow.experience.v0.models.ExperienceCountryStatus(value)
        override def convert(value: io.flow.experience.v0.models.ExperienceCountryStatus): String = value.toString
        override def example: io.flow.experience.v0.models.ExperienceCountryStatus = io.flow.experience.v0.models.ExperienceCountryStatus.Enabled
        override def validValues: Seq[io.flow.experience.v0.models.ExperienceCountryStatus] = io.flow.experience.v0.models.ExperienceCountryStatus.all
      }
      implicit def pathBindableExperienceCountryStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.ExperienceCountryStatus] = ApibuilderPathBindable(experienceCountryStatusConverter)
      implicit def queryStringBindableExperienceCountryStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.ExperienceCountryStatus] = ApibuilderQueryStringBindable(experienceCountryStatusConverter)

      val experiencePaymentMethodTagConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.ExperiencePaymentMethodTag] = new ApibuilderTypeConverter[io.flow.experience.v0.models.ExperiencePaymentMethodTag] {
        override def convert(value: String): io.flow.experience.v0.models.ExperiencePaymentMethodTag = io.flow.experience.v0.models.ExperiencePaymentMethodTag(value)
        override def convert(value: io.flow.experience.v0.models.ExperiencePaymentMethodTag): String = value.toString
        override def example: io.flow.experience.v0.models.ExperiencePaymentMethodTag = io.flow.experience.v0.models.ExperiencePaymentMethodTag.Display
        override def validValues: Seq[io.flow.experience.v0.models.ExperiencePaymentMethodTag] = io.flow.experience.v0.models.ExperiencePaymentMethodTag.all
      }
      implicit def pathBindableExperiencePaymentMethodTag(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.ExperiencePaymentMethodTag] = ApibuilderPathBindable(experiencePaymentMethodTagConverter)
      implicit def queryStringBindableExperiencePaymentMethodTag(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.ExperiencePaymentMethodTag] = ApibuilderQueryStringBindable(experiencePaymentMethodTagConverter)

      val experienceStatusConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.ExperienceStatus] = new ApibuilderTypeConverter[io.flow.experience.v0.models.ExperienceStatus] {
        override def convert(value: String): io.flow.experience.v0.models.ExperienceStatus = io.flow.experience.v0.models.ExperienceStatus(value)
        override def convert(value: io.flow.experience.v0.models.ExperienceStatus): String = value.toString
        override def example: io.flow.experience.v0.models.ExperienceStatus = io.flow.experience.v0.models.ExperienceStatus.Draft
        override def validValues: Seq[io.flow.experience.v0.models.ExperienceStatus] = io.flow.experience.v0.models.ExperienceStatus.all
      }
      implicit def pathBindableExperienceStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.ExperienceStatus] = ApibuilderPathBindable(experienceStatusConverter)
      implicit def queryStringBindableExperienceStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.ExperienceStatus] = ApibuilderQueryStringBindable(experienceStatusConverter)

      val orderErrorCodeConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.OrderErrorCode] = new ApibuilderTypeConverter[io.flow.experience.v0.models.OrderErrorCode] {
        override def convert(value: String): io.flow.experience.v0.models.OrderErrorCode = io.flow.experience.v0.models.OrderErrorCode(value)
        override def convert(value: io.flow.experience.v0.models.OrderErrorCode): String = value.toString
        override def example: io.flow.experience.v0.models.OrderErrorCode = io.flow.experience.v0.models.OrderErrorCode.GenericError
        override def validValues: Seq[io.flow.experience.v0.models.OrderErrorCode] = io.flow.experience.v0.models.OrderErrorCode.all
      }
      implicit def pathBindableOrderErrorCode(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.OrderErrorCode] = ApibuilderPathBindable(orderErrorCodeConverter)
      implicit def queryStringBindableOrderErrorCode(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.OrderErrorCode] = ApibuilderQueryStringBindable(orderErrorCodeConverter)

      val orderPaymentTypeConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.OrderPaymentType] = new ApibuilderTypeConverter[io.flow.experience.v0.models.OrderPaymentType] {
        override def convert(value: String): io.flow.experience.v0.models.OrderPaymentType = io.flow.experience.v0.models.OrderPaymentType(value)
        override def convert(value: io.flow.experience.v0.models.OrderPaymentType): String = value.toString
        override def example: io.flow.experience.v0.models.OrderPaymentType = io.flow.experience.v0.models.OrderPaymentType.Card
        override def validValues: Seq[io.flow.experience.v0.models.OrderPaymentType] = io.flow.experience.v0.models.OrderPaymentType.all
      }
      implicit def pathBindableOrderPaymentType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.OrderPaymentType] = ApibuilderPathBindable(orderPaymentTypeConverter)
      implicit def queryStringBindableOrderPaymentType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.OrderPaymentType] = ApibuilderQueryStringBindable(orderPaymentTypeConverter)

      val orderRefundSummaryIncludesConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.OrderRefundSummaryIncludes] = new ApibuilderTypeConverter[io.flow.experience.v0.models.OrderRefundSummaryIncludes] {
        override def convert(value: String): io.flow.experience.v0.models.OrderRefundSummaryIncludes = io.flow.experience.v0.models.OrderRefundSummaryIncludes(value)
        override def convert(value: io.flow.experience.v0.models.OrderRefundSummaryIncludes): String = value.toString
        override def example: io.flow.experience.v0.models.OrderRefundSummaryIncludes = io.flow.experience.v0.models.OrderRefundSummaryIncludes.Duties
        override def validValues: Seq[io.flow.experience.v0.models.OrderRefundSummaryIncludes] = io.flow.experience.v0.models.OrderRefundSummaryIncludes.all
      }
      implicit def pathBindableOrderRefundSummaryIncludes(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.OrderRefundSummaryIncludes] = ApibuilderPathBindable(orderRefundSummaryIncludesConverter)
      implicit def queryStringBindableOrderRefundSummaryIncludes(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.OrderRefundSummaryIncludes] = ApibuilderQueryStringBindable(orderRefundSummaryIncludesConverter)

      val orderRefundSummaryPartialChargedConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.OrderRefundSummaryPartialCharged] = new ApibuilderTypeConverter[io.flow.experience.v0.models.OrderRefundSummaryPartialCharged] {
        override def convert(value: String): io.flow.experience.v0.models.OrderRefundSummaryPartialCharged = io.flow.experience.v0.models.OrderRefundSummaryPartialCharged(value)
        override def convert(value: io.flow.experience.v0.models.OrderRefundSummaryPartialCharged): String = value.toString
        override def example: io.flow.experience.v0.models.OrderRefundSummaryPartialCharged = io.flow.experience.v0.models.OrderRefundSummaryPartialCharged.PerItem
        override def validValues: Seq[io.flow.experience.v0.models.OrderRefundSummaryPartialCharged] = io.flow.experience.v0.models.OrderRefundSummaryPartialCharged.all
      }
      implicit def pathBindableOrderRefundSummaryPartialCharged(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.OrderRefundSummaryPartialCharged] = ApibuilderPathBindable(orderRefundSummaryPartialChargedConverter)
      implicit def queryStringBindableOrderRefundSummaryPartialCharged(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.OrderRefundSummaryPartialCharged] = ApibuilderQueryStringBindable(orderRefundSummaryPartialChargedConverter)

      val orderStatusConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.OrderStatus] = new ApibuilderTypeConverter[io.flow.experience.v0.models.OrderStatus] {
        override def convert(value: String): io.flow.experience.v0.models.OrderStatus = io.flow.experience.v0.models.OrderStatus(value)
        override def convert(value: io.flow.experience.v0.models.OrderStatus): String = value.toString
        override def example: io.flow.experience.v0.models.OrderStatus = io.flow.experience.v0.models.OrderStatus.Open
        override def validValues: Seq[io.flow.experience.v0.models.OrderStatus] = io.flow.experience.v0.models.OrderStatus.all
      }
      implicit def pathBindableOrderStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.OrderStatus] = ApibuilderPathBindable(orderStatusConverter)
      implicit def queryStringBindableOrderStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.OrderStatus] = ApibuilderQueryStringBindable(orderStatusConverter)

      val orderStorageConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.OrderStorage] = new ApibuilderTypeConverter[io.flow.experience.v0.models.OrderStorage] {
        override def convert(value: String): io.flow.experience.v0.models.OrderStorage = io.flow.experience.v0.models.OrderStorage(value)
        override def convert(value: io.flow.experience.v0.models.OrderStorage): String = value.toString
        override def example: io.flow.experience.v0.models.OrderStorage = io.flow.experience.v0.models.OrderStorage.DoNotPersist
        override def validValues: Seq[io.flow.experience.v0.models.OrderStorage] = io.flow.experience.v0.models.OrderStorage.all
      }
      implicit def pathBindableOrderStorage(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.OrderStorage] = ApibuilderPathBindable(orderStorageConverter)
      implicit def queryStringBindableOrderStorage(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.OrderStorage] = ApibuilderQueryStringBindable(orderStorageConverter)

      val orderTypeConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.OrderType] = new ApibuilderTypeConverter[io.flow.experience.v0.models.OrderType] {
        override def convert(value: String): io.flow.experience.v0.models.OrderType = io.flow.experience.v0.models.OrderType(value)
        override def convert(value: io.flow.experience.v0.models.OrderType): String = value.toString
        override def example: io.flow.experience.v0.models.OrderType = io.flow.experience.v0.models.OrderType.Standard
        override def validValues: Seq[io.flow.experience.v0.models.OrderType] = io.flow.experience.v0.models.OrderType.all
      }
      implicit def pathBindableOrderType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.OrderType] = ApibuilderPathBindable(orderTypeConverter)
      implicit def queryStringBindableOrderType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.OrderType] = ApibuilderQueryStringBindable(orderTypeConverter)

      val organizationPaymentMethodTagConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.OrganizationPaymentMethodTag] = new ApibuilderTypeConverter[io.flow.experience.v0.models.OrganizationPaymentMethodTag] {
        override def convert(value: String): io.flow.experience.v0.models.OrganizationPaymentMethodTag = io.flow.experience.v0.models.OrganizationPaymentMethodTag(value)
        override def convert(value: io.flow.experience.v0.models.OrganizationPaymentMethodTag): String = value.toString
        override def example: io.flow.experience.v0.models.OrganizationPaymentMethodTag = io.flow.experience.v0.models.OrganizationPaymentMethodTag.Deny
        override def validValues: Seq[io.flow.experience.v0.models.OrganizationPaymentMethodTag] = io.flow.experience.v0.models.OrganizationPaymentMethodTag.all
      }
      implicit def pathBindableOrganizationPaymentMethodTag(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.OrganizationPaymentMethodTag] = ApibuilderPathBindable(organizationPaymentMethodTagConverter)
      implicit def queryStringBindableOrganizationPaymentMethodTag(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.OrganizationPaymentMethodTag] = ApibuilderQueryStringBindable(organizationPaymentMethodTagConverter)

      val paymentMethodRuleContentKeyConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.PaymentMethodRuleContentKey] = new ApibuilderTypeConverter[io.flow.experience.v0.models.PaymentMethodRuleContentKey] {
        override def convert(value: String): io.flow.experience.v0.models.PaymentMethodRuleContentKey = io.flow.experience.v0.models.PaymentMethodRuleContentKey(value)
        override def convert(value: io.flow.experience.v0.models.PaymentMethodRuleContentKey): String = value.toString
        override def example: io.flow.experience.v0.models.PaymentMethodRuleContentKey = io.flow.experience.v0.models.PaymentMethodRuleContentKey.Description
        override def validValues: Seq[io.flow.experience.v0.models.PaymentMethodRuleContentKey] = io.flow.experience.v0.models.PaymentMethodRuleContentKey.all
      }
      implicit def pathBindablePaymentMethodRuleContentKey(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.PaymentMethodRuleContentKey] = ApibuilderPathBindable(paymentMethodRuleContentKeyConverter)
      implicit def queryStringBindablePaymentMethodRuleContentKey(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.PaymentMethodRuleContentKey] = ApibuilderQueryStringBindable(paymentMethodRuleContentKeyConverter)

      val priceFacetBoundaryConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.PriceFacetBoundary] = new ApibuilderTypeConverter[io.flow.experience.v0.models.PriceFacetBoundary] {
        override def convert(value: String): io.flow.experience.v0.models.PriceFacetBoundary = io.flow.experience.v0.models.PriceFacetBoundary(value)
        override def convert(value: io.flow.experience.v0.models.PriceFacetBoundary): String = value.toString
        override def example: io.flow.experience.v0.models.PriceFacetBoundary = io.flow.experience.v0.models.PriceFacetBoundary.Min
        override def validValues: Seq[io.flow.experience.v0.models.PriceFacetBoundary] = io.flow.experience.v0.models.PriceFacetBoundary.all
      }
      implicit def pathBindablePriceFacetBoundary(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.PriceFacetBoundary] = ApibuilderPathBindable(priceFacetBoundaryConverter)
      implicit def queryStringBindablePriceFacetBoundary(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.PriceFacetBoundary] = ApibuilderQueryStringBindable(priceFacetBoundaryConverter)

      val promotionTriggerTypeConverter: ApibuilderTypeConverter[io.flow.experience.v0.models.PromotionTriggerType] = new ApibuilderTypeConverter[io.flow.experience.v0.models.PromotionTriggerType] {
        override def convert(value: String): io.flow.experience.v0.models.PromotionTriggerType = io.flow.experience.v0.models.PromotionTriggerType(value)
        override def convert(value: io.flow.experience.v0.models.PromotionTriggerType): String = value.toString
        override def example: io.flow.experience.v0.models.PromotionTriggerType = io.flow.experience.v0.models.PromotionTriggerType.Automatic
        override def validValues: Seq[io.flow.experience.v0.models.PromotionTriggerType] = io.flow.experience.v0.models.PromotionTriggerType.all
      }
      implicit def pathBindablePromotionTriggerType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.experience.v0.models.PromotionTriggerType] = ApibuilderPathBindable(promotionTriggerTypeConverter)
      implicit def queryStringBindablePromotionTriggerType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.experience.v0.models.PromotionTriggerType] = ApibuilderQueryStringBindable(promotionTriggerTypeConverter)
    }

    trait ApibuilderTypeConverter[T] {

      def convert(value: String): T

      def convert(value: T): String

      def example: T

      def validValues: Seq[T] = Nil

      def errorMessage(key: String, value: String, ex: java.lang.Exception): String = {
        val base = s"Invalid value '$value' for parameter '$key'. "
        validValues.toList match {
          case Nil => base + "Ex: " + convert(example)
          case values => base + ". Valid values are: " + values.mkString("'", "', '", "'")
        }
      }
    }

    object ApibuilderTypes {
      val dateTimeIso8601: ApibuilderTypeConverter[_root_.org.joda.time.DateTime] = new ApibuilderTypeConverter[_root_.org.joda.time.DateTime] {
        override def convert(value: String): _root_.org.joda.time.DateTime = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(value)
        override def convert(value: _root_.org.joda.time.DateTime): String = _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(value)
        override def example: _root_.org.joda.time.DateTime = _root_.org.joda.time.DateTime.now
      }

      val dateIso8601: ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] = new ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] {
        override def convert(value: String): _root_.org.joda.time.LocalDate = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(value)
        override def convert(value: _root_.org.joda.time.LocalDate): String = _root_.org.joda.time.format.ISODateTimeFormat.date.print(value)
        override def example: _root_.org.joda.time.LocalDate = _root_.org.joda.time.LocalDate.now
      }
    }

    final case class ApibuilderQueryStringBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends QueryStringBindable[T] {

      override def bind(key: String, params: Map[String, Seq[String]]): _root_.scala.Option[_root_.scala.Either[String, T]] = {
        params.getOrElse(key, Nil).headOption.map { v =>
          try {
            Right(
              converters.convert(v)
            )
          } catch {
            case ex: java.lang.Exception => Left(
              converters.errorMessage(key, v, ex)
            )
          }
        }
      }

      override def unbind(key: String, value: T): String = {
        s"$key=${converters.convert(value)}"
      }
    }

    final case class ApibuilderPathBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends PathBindable[T] {

      override def bind(key: String, value: String): _root_.scala.Either[String, T] = {
        try {
          Right(
            converters.convert(value)
          )
        } catch {
          case ex: java.lang.Exception => Left(
            converters.errorMessage(key, value, ex)
          )
        }
      }

      override def unbind(key: String, value: T): String = {
        converters.convert(value)
      }
    }

  }

}
